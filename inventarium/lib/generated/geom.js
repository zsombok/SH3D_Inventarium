var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/* Generated from Java with JSweet 2.3.8-SNAPSHOT - http://www.jsweet.org */
var sun;
(function (sun) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            var Crossings = /** @class */ (function () {
                function Crossings(xlo, ylo, xhi, yhi) {
                    this.limit = 0;
                    this.yranges = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
                    if (this.xlo === undefined)
                        this.xlo = 0;
                    if (this.ylo === undefined)
                        this.ylo = 0;
                    if (this.xhi === undefined)
                        this.xhi = 0;
                    if (this.yhi === undefined)
                        this.yhi = 0;
                    this.tmp = ([]);
                    this.xlo = xlo;
                    this.ylo = ylo;
                    this.xhi = xhi;
                    this.yhi = yhi;
                }
                Crossings.prototype.getXLo = function () {
                    return this.xlo;
                };
                Crossings.prototype.getYLo = function () {
                    return this.ylo;
                };
                Crossings.prototype.getXHi = function () {
                    return this.xhi;
                };
                Crossings.prototype.getYHi = function () {
                    return this.yhi;
                };
                Crossings.prototype.print = function () {
                    console.info("Crossings [");
                    console.info("  bounds = [" + this.ylo + ", " + this.yhi + "]");
                    for (var i = 0; i < this.limit; i += 2) {
                        {
                            console.info("  [" + this.yranges[i] + ", " + this.yranges[i + 1] + "]");
                        }
                        ;
                    }
                    console.info("]");
                };
                Crossings.prototype.isEmpty = function () {
                    return (this.limit === 0);
                };
                Crossings.findCrossings$java_util_Vector$double$double$double$double = function (curves, xlo, ylo, xhi, yhi) {
                    var cross = new Crossings.EvenOdd(xlo, ylo, xhi, yhi);
                    var enum_ = (function (a) { var i = 0; return { nextElement: function () { return i < a.length ? a[i++] : null; }, hasMoreElements: function () { return i < a.length; } }; })(curves);
                    while ((enum_.hasMoreElements())) {
                        {
                            var c = enum_.nextElement();
                            if (c.accumulateCrossings(cross)) {
                                return null;
                            }
                        }
                    }
                    ;
                    if (Crossings.debug) {
                        cross.print();
                    }
                    return cross;
                };
                Crossings.findCrossings = function (curves, xlo, ylo, xhi, yhi) {
                    if (((curves != null && (curves instanceof Array)) || curves === null) && ((typeof xlo === 'number') || xlo === null) && ((typeof ylo === 'number') || ylo === null) && ((typeof xhi === 'number') || xhi === null) && ((typeof yhi === 'number') || yhi === null)) {
                        return sun.awt.geom.Crossings.findCrossings$java_util_Vector$double$double$double$double(curves, xlo, ylo, xhi, yhi);
                    }
                    else if (((curves != null && (curves["__interfaces"] != null && curves["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0 || curves.constructor != null && curves.constructor["__interfaces"] != null && curves.constructor["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0)) || curves === null) && ((typeof xlo === 'number') || xlo === null) && ((typeof ylo === 'number') || ylo === null) && ((typeof xhi === 'number') || xhi === null) && ((typeof yhi === 'number') || yhi === null)) {
                        return sun.awt.geom.Crossings.findCrossings$java_awt_geom_PathIterator$double$double$double$double(curves, xlo, ylo, xhi, yhi);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Crossings.findCrossings$java_awt_geom_PathIterator$double$double$double$double = function (pi, xlo, ylo, xhi, yhi) {
                    var cross;
                    if (pi.getWindingRule() === java.awt.geom.PathIterator.WIND_EVEN_ODD) {
                        cross = new Crossings.EvenOdd(xlo, ylo, xhi, yhi);
                    }
                    else {
                        cross = new Crossings.NonZero(xlo, ylo, xhi, yhi);
                    }
                    var coords = (function (s) { var a = []; while (s-- > 0)
                        a.push(0); return a; })(23);
                    var movx = 0;
                    var movy = 0;
                    var curx = 0;
                    var cury = 0;
                    var newx;
                    var newy;
                    while ((!pi.isDone())) {
                        {
                            var type = pi['currentSegment$double_A'](coords);
                            switch ((type)) {
                                case java.awt.geom.PathIterator.SEG_MOVETO:
                                    if (movy !== cury && cross.accumulateLine$double$double$double$double(curx, cury, movx, movy)) {
                                        return null;
                                    }
                                    movx = curx = coords[0];
                                    movy = cury = coords[1];
                                    break;
                                case java.awt.geom.PathIterator.SEG_LINETO:
                                    newx = coords[0];
                                    newy = coords[1];
                                    if (cross.accumulateLine$double$double$double$double(curx, cury, newx, newy)) {
                                        return null;
                                    }
                                    curx = newx;
                                    cury = newy;
                                    break;
                                case java.awt.geom.PathIterator.SEG_QUADTO:
                                    newx = coords[2];
                                    newy = coords[3];
                                    if (cross.accumulateQuad(curx, cury, coords)) {
                                        return null;
                                    }
                                    curx = newx;
                                    cury = newy;
                                    break;
                                case java.awt.geom.PathIterator.SEG_CUBICTO:
                                    newx = coords[4];
                                    newy = coords[5];
                                    if (cross.accumulateCubic(curx, cury, coords)) {
                                        return null;
                                    }
                                    curx = newx;
                                    cury = newy;
                                    break;
                                case java.awt.geom.PathIterator.SEG_CLOSE:
                                    if (movy !== cury && cross.accumulateLine$double$double$double$double(curx, cury, movx, movy)) {
                                        return null;
                                    }
                                    curx = movx;
                                    cury = movy;
                                    break;
                            }
                            pi.next();
                        }
                    }
                    ;
                    if (movy !== cury) {
                        if (cross.accumulateLine$double$double$double$double(curx, cury, movx, movy)) {
                            return null;
                        }
                    }
                    if (Crossings.debug) {
                        cross.print();
                    }
                    return cross;
                };
                Crossings.prototype.accumulateLine$double$double$double$double = function (x0, y0, x1, y1) {
                    if (y0 <= y1) {
                        return this.accumulateLine$double$double$double$double$int(x0, y0, x1, y1, 1);
                    }
                    else {
                        return this.accumulateLine$double$double$double$double$int(x1, y1, x0, y0, -1);
                    }
                };
                Crossings.prototype.accumulateLine$double$double$double$double$int = function (x0, y0, x1, y1, direction) {
                    if (this.yhi <= y0 || this.ylo >= y1) {
                        return false;
                    }
                    if (x0 >= this.xhi && x1 >= this.xhi) {
                        return false;
                    }
                    if (y0 === y1) {
                        return (x0 >= this.xlo || x1 >= this.xlo);
                    }
                    var xstart;
                    var ystart;
                    var xend;
                    var yend;
                    var dx = (x1 - x0);
                    var dy = (y1 - y0);
                    if (y0 < this.ylo) {
                        xstart = x0 + (this.ylo - y0) * dx / dy;
                        ystart = this.ylo;
                    }
                    else {
                        xstart = x0;
                        ystart = y0;
                    }
                    if (this.yhi < y1) {
                        xend = x0 + (this.yhi - y0) * dx / dy;
                        yend = this.yhi;
                    }
                    else {
                        xend = x1;
                        yend = y1;
                    }
                    if (xstart >= this.xhi && xend >= this.xhi) {
                        return false;
                    }
                    if (xstart > this.xlo || xend > this.xlo) {
                        return true;
                    }
                    this.record(ystart, yend, direction);
                    return false;
                };
                Crossings.prototype.accumulateLine = function (x0, y0, x1, y1, direction) {
                    if (((typeof x0 === 'number') || x0 === null) && ((typeof y0 === 'number') || y0 === null) && ((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof direction === 'number') || direction === null)) {
                        return this.accumulateLine$double$double$double$double$int(x0, y0, x1, y1, direction);
                    }
                    else if (((typeof x0 === 'number') || x0 === null) && ((typeof y0 === 'number') || y0 === null) && ((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && direction === undefined) {
                        return this.accumulateLine$double$double$double$double(x0, y0, x1, y1);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Crossings.prototype.accumulateQuad = function (x0, y0, coords) {
                    if (y0 < this.ylo && coords[1] < this.ylo && coords[3] < this.ylo) {
                        return false;
                    }
                    if (y0 > this.yhi && coords[1] > this.yhi && coords[3] > this.yhi) {
                        return false;
                    }
                    if (x0 > this.xhi && coords[0] > this.xhi && coords[2] > this.xhi) {
                        return false;
                    }
                    if (x0 < this.xlo && coords[0] < this.xlo && coords[2] < this.xlo) {
                        if (y0 < coords[3]) {
                            this.record(Math.max(y0, this.ylo), Math.min(coords[3], this.yhi), 1);
                        }
                        else if (y0 > coords[3]) {
                            this.record(Math.max(coords[3], this.ylo), Math.min(y0, this.yhi), -1);
                        }
                        return false;
                    }
                    sun.awt.geom.Curve.insertQuad(this.tmp, x0, y0, coords);
                    var enum_ = (function (a) { var i = 0; return { nextElement: function () { return i < a.length ? a[i++] : null; }, hasMoreElements: function () { return i < a.length; } }; })(this.tmp);
                    while ((enum_.hasMoreElements())) {
                        {
                            var c = enum_.nextElement();
                            if (c.accumulateCrossings(this)) {
                                return true;
                            }
                        }
                    }
                    ;
                    /* clear */ (this.tmp.length = 0);
                    return false;
                };
                Crossings.prototype.accumulateCubic = function (x0, y0, coords) {
                    if (y0 < this.ylo && coords[1] < this.ylo && coords[3] < this.ylo && coords[5] < this.ylo) {
                        return false;
                    }
                    if (y0 > this.yhi && coords[1] > this.yhi && coords[3] > this.yhi && coords[5] > this.yhi) {
                        return false;
                    }
                    if (x0 > this.xhi && coords[0] > this.xhi && coords[2] > this.xhi && coords[4] > this.xhi) {
                        return false;
                    }
                    if (x0 < this.xlo && coords[0] < this.xlo && coords[2] < this.xlo && coords[4] < this.xlo) {
                        if (y0 <= coords[5]) {
                            this.record(Math.max(y0, this.ylo), Math.min(coords[5], this.yhi), 1);
                        }
                        else {
                            this.record(Math.max(coords[5], this.ylo), Math.min(y0, this.yhi), -1);
                        }
                        return false;
                    }
                    sun.awt.geom.Curve.insertCubic(this.tmp, x0, y0, coords);
                    var enum_ = (function (a) { var i = 0; return { nextElement: function () { return i < a.length ? a[i++] : null; }, hasMoreElements: function () { return i < a.length; } }; })(this.tmp);
                    while ((enum_.hasMoreElements())) {
                        {
                            var c = enum_.nextElement();
                            if (c.accumulateCrossings(this)) {
                                return true;
                            }
                        }
                    }
                    ;
                    /* clear */ (this.tmp.length = 0);
                    return false;
                };
                Crossings.debug = false;
                return Crossings;
            }());
            geom.Crossings = Crossings;
            Crossings["__class"] = "sun.awt.geom.Crossings";
            (function (Crossings) {
                var EvenOdd = /** @class */ (function (_super) {
                    __extends(EvenOdd, _super);
                    function EvenOdd(xlo, ylo, xhi, yhi) {
                        return _super.call(this, xlo, ylo, xhi, yhi) || this;
                    }
                    EvenOdd.prototype.covers = function (ystart, yend) {
                        return (this.limit === 2 && this.yranges[0] <= ystart && this.yranges[1] >= yend);
                    };
                    EvenOdd.prototype.record = function (ystart, yend, direction) {
                        if (ystart >= yend) {
                            return;
                        }
                        var from = 0;
                        while ((from < this.limit && ystart > this.yranges[from + 1])) {
                            {
                                from += 2;
                            }
                        }
                        ;
                        var to = from;
                        while ((from < this.limit)) {
                            {
                                var yrlo = this.yranges[from++];
                                var yrhi = this.yranges[from++];
                                if (yend < yrlo) {
                                    this.yranges[to++] = ystart;
                                    this.yranges[to++] = yend;
                                    ystart = yrlo;
                                    yend = yrhi;
                                    continue;
                                }
                                var yll = void 0;
                                var ylh = void 0;
                                var yhl = void 0;
                                var yhh = void 0;
                                if (ystart < yrlo) {
                                    yll = ystart;
                                    ylh = yrlo;
                                }
                                else {
                                    yll = yrlo;
                                    ylh = ystart;
                                }
                                if (yend < yrhi) {
                                    yhl = yend;
                                    yhh = yrhi;
                                }
                                else {
                                    yhl = yrhi;
                                    yhh = yend;
                                }
                                if (ylh === yhl) {
                                    ystart = yll;
                                    yend = yhh;
                                }
                                else {
                                    if (ylh > yhl) {
                                        ystart = yhl;
                                        yhl = ylh;
                                        ylh = ystart;
                                    }
                                    if (yll !== ylh) {
                                        this.yranges[to++] = yll;
                                        this.yranges[to++] = ylh;
                                    }
                                    ystart = yhl;
                                    yend = yhh;
                                }
                                if (ystart >= yend) {
                                    break;
                                }
                            }
                        }
                        ;
                        if (to < from && from < this.limit) {
                            java.awt.geom.Helper.arraycopy(this.yranges, from, this.yranges, to, this.limit - from);
                        }
                        to += (this.limit - from);
                        if (ystart < yend) {
                            if (to >= this.yranges.length) {
                                var newranges = (function (s) { var a = []; while (s-- > 0)
                                    a.push(0); return a; })(to + 10);
                                java.awt.geom.Helper.arraycopy(this.yranges, 0, newranges, 0, to);
                                this.yranges = newranges;
                            }
                            this.yranges[to++] = ystart;
                            this.yranges[to++] = yend;
                        }
                        this.limit = to;
                    };
                    return EvenOdd;
                }(sun.awt.geom.Crossings));
                Crossings.EvenOdd = EvenOdd;
                EvenOdd["__class"] = "sun.awt.geom.Crossings.EvenOdd";
                var NonZero = /** @class */ (function (_super) {
                    __extends(NonZero, _super);
                    function NonZero(xlo, ylo, xhi, yhi) {
                        var _this = _super.call(this, xlo, ylo, xhi, yhi) || this;
                        if (_this.crosscounts === undefined)
                            _this.crosscounts = null;
                        _this.crosscounts = (function (s) { var a = []; while (s-- > 0)
                            a.push(0); return a; })((_this.yranges.length / 2 | 0));
                        return _this;
                    }
                    NonZero.prototype.covers = function (ystart, yend) {
                        var i = 0;
                        while ((i < this.limit)) {
                            {
                                var ylo = this.yranges[i++];
                                var yhi = this.yranges[i++];
                                if (ystart >= yhi) {
                                    continue;
                                }
                                if (ystart < ylo) {
                                    return false;
                                }
                                if (yend <= yhi) {
                                    return true;
                                }
                                ystart = yhi;
                            }
                        }
                        ;
                        return (ystart >= yend);
                    };
                    NonZero.prototype.remove = function (cur) {
                        this.limit -= 2;
                        var rem = this.limit - cur;
                        if (rem > 0) {
                            java.awt.geom.Helper.arraycopy(this.yranges, cur + 2, this.yranges, cur, rem);
                            java.awt.geom.Helper.arraycopy(this.crosscounts, (cur / 2 | 0) + 1, this.crosscounts, (cur / 2 | 0), (rem / 2 | 0));
                        }
                    };
                    NonZero.prototype.insert = function (cur, lo, hi, dir) {
                        var rem = this.limit - cur;
                        var oldranges = this.yranges;
                        var oldcounts = this.crosscounts;
                        if (this.limit >= this.yranges.length) {
                            this.yranges = (function (s) { var a = []; while (s-- > 0)
                                a.push(0); return a; })(this.limit + 10);
                            java.awt.geom.Helper.arraycopy(oldranges, 0, this.yranges, 0, cur);
                            this.crosscounts = (function (s) { var a = []; while (s-- > 0)
                                a.push(0); return a; })(((this.limit + 10) / 2 | 0));
                            java.awt.geom.Helper.arraycopy(oldcounts, 0, this.crosscounts, 0, (cur / 2 | 0));
                        }
                        if (rem > 0) {
                            java.awt.geom.Helper.arraycopy(oldranges, cur, this.yranges, cur + 2, rem);
                            java.awt.geom.Helper.arraycopy(oldcounts, (cur / 2 | 0), this.crosscounts, (cur / 2 | 0) + 1, (rem / 2 | 0));
                        }
                        this.yranges[cur + 0] = lo;
                        this.yranges[cur + 1] = hi;
                        this.crosscounts[(cur / 2 | 0)] = dir;
                        this.limit += 2;
                    };
                    NonZero.prototype.record = function (ystart, yend, direction) {
                        if (ystart >= yend) {
                            return;
                        }
                        var cur = 0;
                        while ((cur < this.limit && ystart > this.yranges[cur + 1])) {
                            {
                                cur += 2;
                            }
                        }
                        ;
                        if (cur < this.limit) {
                            var rdir = this.crosscounts[(cur / 2 | 0)];
                            var yrlo = this.yranges[cur + 0];
                            var yrhi = this.yranges[cur + 1];
                            if (yrhi === ystart && rdir === direction) {
                                if (cur + 2 === this.limit) {
                                    this.yranges[cur + 1] = yend;
                                    return;
                                }
                                this.remove(cur);
                                ystart = yrlo;
                                rdir = this.crosscounts[(cur / 2 | 0)];
                                yrlo = this.yranges[cur + 0];
                                yrhi = this.yranges[cur + 1];
                            }
                            if (yend < yrlo) {
                                this.insert(cur, ystart, yend, direction);
                                return;
                            }
                            if (yend === yrlo && rdir === direction) {
                                this.yranges[cur] = ystart;
                                return;
                            }
                            if (ystart < yrlo) {
                                this.insert(cur, ystart, yrlo, direction);
                                cur += 2;
                                ystart = yrlo;
                            }
                            else if (yrlo < ystart) {
                                this.insert(cur, yrlo, ystart, rdir);
                                cur += 2;
                                yrlo = ystart;
                            }
                            var newdir = rdir + direction;
                            var newend = Math.min(yend, yrhi);
                            if (newdir === 0) {
                                this.remove(cur);
                            }
                            else {
                                this.crosscounts[(cur / 2 | 0)] = newdir;
                                this.yranges[cur++] = ystart;
                                this.yranges[cur++] = newend;
                            }
                            ystart = yrlo = newend;
                            if (yrlo < yrhi) {
                                this.insert(cur, yrlo, yrhi, rdir);
                            }
                        }
                        if (ystart < yend) {
                            this.insert(cur, ystart, yend, direction);
                        }
                    };
                    return NonZero;
                }(sun.awt.geom.Crossings));
                Crossings.NonZero = NonZero;
                NonZero["__class"] = "sun.awt.geom.Crossings.NonZero";
            })(Crossings = geom.Crossings || (geom.Crossings = {}));
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = sun.awt || (sun.awt = {}));
})(sun || (sun = {}));
(function (sun) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            var ChainEnd = /** @class */ (function () {
                function ChainEnd(first, partner) {
                    if (this.head === undefined)
                        this.head = null;
                    if (this.tail === undefined)
                        this.tail = null;
                    if (this.partner === undefined)
                        this.partner = null;
                    if (this.etag === undefined)
                        this.etag = 0;
                    this.head = first;
                    this.tail = first;
                    this.partner = partner;
                    this.etag = first.getEdgeTag();
                }
                ChainEnd.prototype.getChain = function () {
                    return this.head;
                };
                ChainEnd.prototype.setOtherEnd = function (partner) {
                    this.partner = partner;
                };
                ChainEnd.prototype.getPartner = function () {
                    return this.partner;
                };
                ChainEnd.prototype.linkTo = function (that) {
                    if (this.etag === sun.awt.geom.AreaOp.ETAG_IGNORE || that.etag === sun.awt.geom.AreaOp.ETAG_IGNORE) {
                        throw Object.defineProperty(new Error("ChainEnd linked more than once!"), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.VirtualMachineError', 'java.lang.InternalError', 'java.lang.Error', 'java.lang.Object'] });
                    }
                    if (this.etag === that.etag) {
                        throw Object.defineProperty(new Error("Linking chains of the same type!"), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.VirtualMachineError', 'java.lang.InternalError', 'java.lang.Error', 'java.lang.Object'] });
                    }
                    var enter;
                    var exit;
                    if (this.etag === sun.awt.geom.AreaOp.ETAG_ENTER) {
                        enter = this;
                        exit = that;
                    }
                    else {
                        enter = that;
                        exit = this;
                    }
                    this.etag = sun.awt.geom.AreaOp.ETAG_IGNORE;
                    that.etag = sun.awt.geom.AreaOp.ETAG_IGNORE;
                    enter.tail.setNext(exit.head);
                    enter.tail = exit.tail;
                    if (this.partner === that) {
                        return enter.head;
                    }
                    var otherenter = exit.partner;
                    var otherexit = enter.partner;
                    otherenter.partner = otherexit;
                    otherexit.partner = otherenter;
                    if (enter.head.getYTop() < otherenter.head.getYTop()) {
                        enter.tail.setNext(otherenter.head);
                        otherenter.head = enter.head;
                    }
                    else {
                        otherexit.tail.setNext(enter.head);
                        otherexit.tail = enter.tail;
                    }
                    return null;
                };
                ChainEnd.prototype.addLink = function (newlink) {
                    if (this.etag === sun.awt.geom.AreaOp.ETAG_ENTER) {
                        this.tail.setNext(newlink);
                        this.tail = newlink;
                    }
                    else {
                        newlink.setNext(this.head);
                        this.head = newlink;
                    }
                };
                ChainEnd.prototype.getX = function () {
                    if (this.etag === sun.awt.geom.AreaOp.ETAG_ENTER) {
                        return this.tail.getXBot();
                    }
                    else {
                        return this.head.getXBot();
                    }
                };
                return ChainEnd;
            }());
            geom.ChainEnd = ChainEnd;
            ChainEnd["__class"] = "sun.awt.geom.ChainEnd";
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = sun.awt || (sun.awt = {}));
})(sun || (sun = {}));
(function (sun) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            var Curve = /** @class */ (function () {
                function Curve(direction) {
                    if (this.direction === undefined)
                        this.direction = 0;
                    this.direction = direction;
                }
                Curve.insertMove = function (curves, x, y) {
                    /* add */ (curves.push(new sun.awt.geom.Order0(x, y)) > 0);
                };
                Curve.insertLine = function (curves, x0, y0, x1, y1) {
                    if (y0 < y1) {
                        /* add */ (curves.push(new sun.awt.geom.Order1(x0, y0, x1, y1, Curve.INCREASING)) > 0);
                    }
                    else if (y0 > y1) {
                        /* add */ (curves.push(new sun.awt.geom.Order1(x1, y1, x0, y0, Curve.DECREASING)) > 0);
                    }
                    else {
                    }
                };
                Curve.insertQuad = function (curves, x0, y0, coords) {
                    var y1 = coords[3];
                    if (y0 > y1) {
                        sun.awt.geom.Order2.insert(curves, coords, coords[2], y1, coords[0], coords[1], x0, y0, Curve.DECREASING);
                    }
                    else if (y0 === y1 && y0 === coords[1]) {
                        return;
                    }
                    else {
                        sun.awt.geom.Order2.insert(curves, coords, x0, y0, coords[0], coords[1], coords[2], y1, Curve.INCREASING);
                    }
                };
                Curve.insertCubic = function (curves, x0, y0, coords) {
                    var y1 = coords[5];
                    if (y0 > y1) {
                        sun.awt.geom.Order3.insert(curves, coords, coords[4], y1, coords[2], coords[3], coords[0], coords[1], x0, y0, Curve.DECREASING);
                    }
                    else if (y0 === y1 && y0 === coords[1] && y0 === coords[3]) {
                        return;
                    }
                    else {
                        sun.awt.geom.Order3.insert(curves, coords, x0, y0, coords[0], coords[1], coords[2], coords[3], coords[4], y1, Curve.INCREASING);
                    }
                };
                /**
                 * Calculates the number of times the given path crosses the ray extending
                 * to the right from (px,py). If the point lies on a part of the path, then
                 * no crossings are counted for that intersection. +1 is added for each
                 * crossing where the Y coordinate is increasing -1 is added for each
                 * crossing where the Y coordinate is decreasing The return value is the sum
                 * of all crossings for every segment in the path. The path must start with
                 * a SEG_MOVETO, otherwise an exception is thrown. The caller must check
                 * p[xy] for NaN values. The caller may also reject infinite p[xy] values as
                 * well.
                 * @param {*} pi
                 * @param {number} px
                 * @param {number} py
                 * @return {number}
                 */
                Curve.pointCrossingsForPath = function (pi, px, py) {
                    if (pi.isDone()) {
                        return 0;
                    }
                    var coords = [0, 0, 0, 0, 0, 0];
                    if (pi['currentSegment$double_A'](coords) !== java.awt.geom.PathIterator.SEG_MOVETO) {
                        throw Object.defineProperty(new Error("missing initial moveto in path definition"), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.Object', 'java.awt.geom.IllegalPathStateException', 'java.lang.RuntimeException', 'java.lang.Exception'] });
                    }
                    pi.next();
                    var movx = coords[0];
                    var movy = coords[1];
                    var curx = movx;
                    var cury = movy;
                    var endx;
                    var endy;
                    var crossings = 0;
                    while ((!pi.isDone())) {
                        {
                            switch ((pi['currentSegment$double_A'](coords))) {
                                case java.awt.geom.PathIterator.SEG_MOVETO:
                                    if (cury !== movy) {
                                        crossings += Curve.pointCrossingsForLine(px, py, curx, cury, movx, movy);
                                    }
                                    movx = curx = coords[0];
                                    movy = cury = coords[1];
                                    break;
                                case java.awt.geom.PathIterator.SEG_LINETO:
                                    endx = coords[0];
                                    endy = coords[1];
                                    crossings += Curve.pointCrossingsForLine(px, py, curx, cury, endx, endy);
                                    curx = endx;
                                    cury = endy;
                                    break;
                                case java.awt.geom.PathIterator.SEG_QUADTO:
                                    endx = coords[2];
                                    endy = coords[3];
                                    crossings += Curve.pointCrossingsForQuad(px, py, curx, cury, coords[0], coords[1], endx, endy, 0);
                                    curx = endx;
                                    cury = endy;
                                    break;
                                case java.awt.geom.PathIterator.SEG_CUBICTO:
                                    endx = coords[4];
                                    endy = coords[5];
                                    crossings += Curve.pointCrossingsForCubic(px, py, curx, cury, coords[0], coords[1], coords[2], coords[3], endx, endy, 0);
                                    curx = endx;
                                    cury = endy;
                                    break;
                                case java.awt.geom.PathIterator.SEG_CLOSE:
                                    if (cury !== movy) {
                                        crossings += Curve.pointCrossingsForLine(px, py, curx, cury, movx, movy);
                                    }
                                    curx = movx;
                                    cury = movy;
                                    break;
                            }
                            pi.next();
                        }
                    }
                    ;
                    if (cury !== movy) {
                        crossings += Curve.pointCrossingsForLine(px, py, curx, cury, movx, movy);
                    }
                    return crossings;
                };
                /**
                 * Calculates the number of times the line from (x0,y0) to (x1,y1) crosses
                 * the ray extending to the right from (px,py). If the point lies on the
                 * line, then no crossings are recorded. +1 is returned for a crossing where
                 * the Y coordinate is increasing -1 is returned for a crossing where the Y
                 * coordinate is decreasing
                 * @param {number} px
                 * @param {number} py
                 * @param {number} x0
                 * @param {number} y0
                 * @param {number} x1
                 * @param {number} y1
                 * @return {number}
                 */
                Curve.pointCrossingsForLine = function (px, py, x0, y0, x1, y1) {
                    if (py < y0 && py < y1)
                        return 0;
                    if (py >= y0 && py >= y1)
                        return 0;
                    if (px >= x0 && px >= x1)
                        return 0;
                    if (px < x0 && px < x1)
                        return (y0 < y1) ? 1 : -1;
                    var xintercept = x0 + (py - y0) * (x1 - x0) / (y1 - y0);
                    if (px >= xintercept)
                        return 0;
                    return (y0 < y1) ? 1 : -1;
                };
                /**
                 * Calculates the number of times the quad from (x0,y0) to (x1,y1) crosses
                 * the ray extending to the right from (px,py). If the point lies on a part
                 * of the curve, then no crossings are counted for that intersection. the
                 * level parameter should be 0 at the top-level call and will count up for
                 * each recursion level to prevent infinite recursion +1 is added for each
                 * crossing where the Y coordinate is increasing -1 is added for each
                 * crossing where the Y coordinate is decreasing
                 * @param {number} px
                 * @param {number} py
                 * @param {number} x0
                 * @param {number} y0
                 * @param {number} xc
                 * @param {number} yc
                 * @param {number} x1
                 * @param {number} y1
                 * @param {number} level
                 * @return {number}
                 */
                Curve.pointCrossingsForQuad = function (px, py, x0, y0, xc, yc, x1, y1, level) {
                    if (py < y0 && py < yc && py < y1)
                        return 0;
                    if (py >= y0 && py >= yc && py >= y1)
                        return 0;
                    if (px >= x0 && px >= xc && px >= x1)
                        return 0;
                    if (px < x0 && px < xc && px < x1) {
                        if (py >= y0) {
                            if (py < y1)
                                return 1;
                        }
                        else {
                            if (py >= y1)
                                return -1;
                        }
                        return 0;
                    }
                    if (level > 52)
                        return Curve.pointCrossingsForLine(px, py, x0, y0, x1, y1);
                    var x0c = (x0 + xc) / 2;
                    var y0c = (y0 + yc) / 2;
                    var xc1 = (xc + x1) / 2;
                    var yc1 = (yc + y1) / 2;
                    xc = (x0c + xc1) / 2;
                    yc = (y0c + yc1) / 2;
                    if ( /* isNaN */isNaN(xc) || /* isNaN */ isNaN(yc)) {
                        return 0;
                    }
                    return (Curve.pointCrossingsForQuad(px, py, x0, y0, x0c, y0c, xc, yc, level + 1) + Curve.pointCrossingsForQuad(px, py, xc, yc, xc1, yc1, x1, y1, level + 1));
                };
                /**
                 * Calculates the number of times the cubic from (x0,y0) to (x1,y1) crosses
                 * the ray extending to the right from (px,py). If the point lies on a part
                 * of the curve, then no crossings are counted for that intersection. the
                 * level parameter should be 0 at the top-level call and will count up for
                 * each recursion level to prevent infinite recursion +1 is added for each
                 * crossing where the Y coordinate is increasing -1 is added for each
                 * crossing where the Y coordinate is decreasing
                 * @param {number} px
                 * @param {number} py
                 * @param {number} x0
                 * @param {number} y0
                 * @param {number} xc0
                 * @param {number} yc0
                 * @param {number} xc1
                 * @param {number} yc1
                 * @param {number} x1
                 * @param {number} y1
                 * @param {number} level
                 * @return {number}
                 */
                Curve.pointCrossingsForCubic = function (px, py, x0, y0, xc0, yc0, xc1, yc1, x1, y1, level) {
                    if (py < y0 && py < yc0 && py < yc1 && py < y1)
                        return 0;
                    if (py >= y0 && py >= yc0 && py >= yc1 && py >= y1)
                        return 0;
                    if (px >= x0 && px >= xc0 && px >= xc1 && px >= x1)
                        return 0;
                    if (px < x0 && px < xc0 && px < xc1 && px < x1) {
                        if (py >= y0) {
                            if (py < y1)
                                return 1;
                        }
                        else {
                            if (py >= y1)
                                return -1;
                        }
                        return 0;
                    }
                    if (level > 52)
                        return Curve.pointCrossingsForLine(px, py, x0, y0, x1, y1);
                    var xmid = (xc0 + xc1) / 2;
                    var ymid = (yc0 + yc1) / 2;
                    xc0 = (x0 + xc0) / 2;
                    yc0 = (y0 + yc0) / 2;
                    xc1 = (xc1 + x1) / 2;
                    yc1 = (yc1 + y1) / 2;
                    var xc0m = (xc0 + xmid) / 2;
                    var yc0m = (yc0 + ymid) / 2;
                    var xmc1 = (xmid + xc1) / 2;
                    var ymc1 = (ymid + yc1) / 2;
                    xmid = (xc0m + xmc1) / 2;
                    ymid = (yc0m + ymc1) / 2;
                    if ( /* isNaN */isNaN(xmid) || /* isNaN */ isNaN(ymid)) {
                        return 0;
                    }
                    return (Curve.pointCrossingsForCubic(px, py, x0, y0, xc0, yc0, xc0m, yc0m, xmid, ymid, level + 1) + Curve.pointCrossingsForCubic(px, py, xmid, ymid, xmc1, ymc1, xc1, yc1, x1, y1, level + 1));
                };
                /**
                 * Accumulate the number of times the path crosses the shadow extending to
                 * the right of the rectangle. See the comment for the RECT_INTERSECTS
                 * constant for more complete details. The return value is the sum of all
                 * crossings for both the top and bottom of the shadow for every segment in
                 * the path, or the special value RECT_INTERSECTS if the path ever enters
                 * the interior of the rectangle. The path must start with a SEG_MOVETO,
                 * otherwise an exception is thrown. The caller must check r[xy]{min,max}
                 * for NaN values.
                 * @param {*} pi
                 * @param {number} rxmin
                 * @param {number} rymin
                 * @param {number} rxmax
                 * @param {number} rymax
                 * @return {number}
                 */
                Curve.rectCrossingsForPath = function (pi, rxmin, rymin, rxmax, rymax) {
                    if (rxmax <= rxmin || rymax <= rymin) {
                        return 0;
                    }
                    if (pi.isDone()) {
                        return 0;
                    }
                    var coords = [0, 0, 0, 0, 0, 0];
                    if (pi['currentSegment$double_A'](coords) !== java.awt.geom.PathIterator.SEG_MOVETO) {
                        throw Object.defineProperty(new Error("missing initial moveto in path definition"), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.Object', 'java.awt.geom.IllegalPathStateException', 'java.lang.RuntimeException', 'java.lang.Exception'] });
                    }
                    pi.next();
                    var curx;
                    var cury;
                    var movx;
                    var movy;
                    var endx;
                    var endy;
                    curx = movx = coords[0];
                    cury = movy = coords[1];
                    var crossings = 0;
                    while ((crossings !== Curve.RECT_INTERSECTS && !pi.isDone())) {
                        {
                            switch ((pi['currentSegment$double_A'](coords))) {
                                case java.awt.geom.PathIterator.SEG_MOVETO:
                                    if (curx !== movx || cury !== movy) {
                                        crossings = Curve.rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, curx, cury, movx, movy);
                                    }
                                    movx = curx = coords[0];
                                    movy = cury = coords[1];
                                    break;
                                case java.awt.geom.PathIterator.SEG_LINETO:
                                    endx = coords[0];
                                    endy = coords[1];
                                    crossings = Curve.rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, curx, cury, endx, endy);
                                    curx = endx;
                                    cury = endy;
                                    break;
                                case java.awt.geom.PathIterator.SEG_QUADTO:
                                    endx = coords[2];
                                    endy = coords[3];
                                    crossings = Curve.rectCrossingsForQuad(crossings, rxmin, rymin, rxmax, rymax, curx, cury, coords[0], coords[1], endx, endy, 0);
                                    curx = endx;
                                    cury = endy;
                                    break;
                                case java.awt.geom.PathIterator.SEG_CUBICTO:
                                    endx = coords[4];
                                    endy = coords[5];
                                    crossings = Curve.rectCrossingsForCubic(crossings, rxmin, rymin, rxmax, rymax, curx, cury, coords[0], coords[1], coords[2], coords[3], endx, endy, 0);
                                    curx = endx;
                                    cury = endy;
                                    break;
                                case java.awt.geom.PathIterator.SEG_CLOSE:
                                    if (curx !== movx || cury !== movy) {
                                        crossings = Curve.rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, curx, cury, movx, movy);
                                    }
                                    curx = movx;
                                    cury = movy;
                                    break;
                            }
                            pi.next();
                        }
                    }
                    ;
                    if (crossings !== Curve.RECT_INTERSECTS && (curx !== movx || cury !== movy)) {
                        crossings = Curve.rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, curx, cury, movx, movy);
                    }
                    return crossings;
                };
                /**
                 * Accumulate the number of times the line crosses the shadow extending to
                 * the right of the rectangle. See the comment for the RECT_INTERSECTS
                 * constant for more complete details.
                 * @param {number} crossings
                 * @param {number} rxmin
                 * @param {number} rymin
                 * @param {number} rxmax
                 * @param {number} rymax
                 * @param {number} x0
                 * @param {number} y0
                 * @param {number} x1
                 * @param {number} y1
                 * @return {number}
                 */
                Curve.rectCrossingsForLine = function (crossings, rxmin, rymin, rxmax, rymax, x0, y0, x1, y1) {
                    if (y0 >= rymax && y1 >= rymax)
                        return crossings;
                    if (y0 <= rymin && y1 <= rymin)
                        return crossings;
                    if (x0 <= rxmin && x1 <= rxmin)
                        return crossings;
                    if (x0 >= rxmax && x1 >= rxmax) {
                        if (y0 < y1) {
                            if (y0 <= rymin)
                                crossings++;
                            if (y1 >= rymax)
                                crossings++;
                        }
                        else if (y1 < y0) {
                            if (y1 <= rymin)
                                crossings--;
                            if (y0 >= rymax)
                                crossings--;
                        }
                        return crossings;
                    }
                    if ((x0 > rxmin && x0 < rxmax && y0 > rymin && y0 < rymax) || (x1 > rxmin && x1 < rxmax && y1 > rymin && y1 < rymax)) {
                        return Curve.RECT_INTERSECTS;
                    }
                    var xi0 = x0;
                    if (y0 < rymin) {
                        xi0 += ((rymin - y0) * (x1 - x0) / (y1 - y0));
                    }
                    else if (y0 > rymax) {
                        xi0 += ((rymax - y0) * (x1 - x0) / (y1 - y0));
                    }
                    var xi1 = x1;
                    if (y1 < rymin) {
                        xi1 += ((rymin - y1) * (x0 - x1) / (y0 - y1));
                    }
                    else if (y1 > rymax) {
                        xi1 += ((rymax - y1) * (x0 - x1) / (y0 - y1));
                    }
                    if (xi0 <= rxmin && xi1 <= rxmin)
                        return crossings;
                    if (xi0 >= rxmax && xi1 >= rxmax) {
                        if (y0 < y1) {
                            if (y0 <= rymin)
                                crossings++;
                            if (y1 >= rymax)
                                crossings++;
                        }
                        else if (y1 < y0) {
                            if (y1 <= rymin)
                                crossings--;
                            if (y0 >= rymax)
                                crossings--;
                        }
                        return crossings;
                    }
                    return Curve.RECT_INTERSECTS;
                };
                /**
                 * Accumulate the number of times the quad crosses the shadow extending to
                 * the right of the rectangle. See the comment for the RECT_INTERSECTS
                 * constant for more complete details.
                 * @param {number} crossings
                 * @param {number} rxmin
                 * @param {number} rymin
                 * @param {number} rxmax
                 * @param {number} rymax
                 * @param {number} x0
                 * @param {number} y0
                 * @param {number} xc
                 * @param {number} yc
                 * @param {number} x1
                 * @param {number} y1
                 * @param {number} level
                 * @return {number}
                 */
                Curve.rectCrossingsForQuad = function (crossings, rxmin, rymin, rxmax, rymax, x0, y0, xc, yc, x1, y1, level) {
                    if (y0 >= rymax && yc >= rymax && y1 >= rymax)
                        return crossings;
                    if (y0 <= rymin && yc <= rymin && y1 <= rymin)
                        return crossings;
                    if (x0 <= rxmin && xc <= rxmin && x1 <= rxmin)
                        return crossings;
                    if (x0 >= rxmax && xc >= rxmax && x1 >= rxmax) {
                        if (y0 < y1) {
                            if (y0 <= rymin && y1 > rymin)
                                crossings++;
                            if (y0 < rymax && y1 >= rymax)
                                crossings++;
                        }
                        else if (y1 < y0) {
                            if (y1 <= rymin && y0 > rymin)
                                crossings--;
                            if (y1 < rymax && y0 >= rymax)
                                crossings--;
                        }
                        return crossings;
                    }
                    if ((x0 < rxmax && x0 > rxmin && y0 < rymax && y0 > rymin) || (x1 < rxmax && x1 > rxmin && y1 < rymax && y1 > rymin)) {
                        return Curve.RECT_INTERSECTS;
                    }
                    if (level > 52) {
                        return Curve.rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, x0, y0, x1, y1);
                    }
                    var x0c = (x0 + xc) / 2;
                    var y0c = (y0 + yc) / 2;
                    var xc1 = (xc + x1) / 2;
                    var yc1 = (yc + y1) / 2;
                    xc = (x0c + xc1) / 2;
                    yc = (y0c + yc1) / 2;
                    if ( /* isNaN */isNaN(xc) || /* isNaN */ isNaN(yc)) {
                        return 0;
                    }
                    crossings = Curve.rectCrossingsForQuad(crossings, rxmin, rymin, rxmax, rymax, x0, y0, x0c, y0c, xc, yc, level + 1);
                    if (crossings !== Curve.RECT_INTERSECTS) {
                        crossings = Curve.rectCrossingsForQuad(crossings, rxmin, rymin, rxmax, rymax, xc, yc, xc1, yc1, x1, y1, level + 1);
                    }
                    return crossings;
                };
                /**
                 * Accumulate the number of times the cubic crosses the shadow extending to
                 * the right of the rectangle. See the comment for the RECT_INTERSECTS
                 * constant for more complete details.
                 * @param {number} crossings
                 * @param {number} rxmin
                 * @param {number} rymin
                 * @param {number} rxmax
                 * @param {number} rymax
                 * @param {number} x0
                 * @param {number} y0
                 * @param {number} xc0
                 * @param {number} yc0
                 * @param {number} xc1
                 * @param {number} yc1
                 * @param {number} x1
                 * @param {number} y1
                 * @param {number} level
                 * @return {number}
                 */
                Curve.rectCrossingsForCubic = function (crossings, rxmin, rymin, rxmax, rymax, x0, y0, xc0, yc0, xc1, yc1, x1, y1, level) {
                    if (y0 >= rymax && yc0 >= rymax && yc1 >= rymax && y1 >= rymax) {
                        return crossings;
                    }
                    if (y0 <= rymin && yc0 <= rymin && yc1 <= rymin && y1 <= rymin) {
                        return crossings;
                    }
                    if (x0 <= rxmin && xc0 <= rxmin && xc1 <= rxmin && x1 <= rxmin) {
                        return crossings;
                    }
                    if (x0 >= rxmax && xc0 >= rxmax && xc1 >= rxmax && x1 >= rxmax) {
                        if (y0 < y1) {
                            if (y0 <= rymin && y1 > rymin)
                                crossings++;
                            if (y0 < rymax && y1 >= rymax)
                                crossings++;
                        }
                        else if (y1 < y0) {
                            if (y1 <= rymin && y0 > rymin)
                                crossings--;
                            if (y1 < rymax && y0 >= rymax)
                                crossings--;
                        }
                        return crossings;
                    }
                    if ((x0 > rxmin && x0 < rxmax && y0 > rymin && y0 < rymax) || (x1 > rxmin && x1 < rxmax && y1 > rymin && y1 < rymax)) {
                        return Curve.RECT_INTERSECTS;
                    }
                    if (level > 52) {
                        return Curve.rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, x0, y0, x1, y1);
                    }
                    var xmid = (xc0 + xc1) / 2;
                    var ymid = (yc0 + yc1) / 2;
                    xc0 = (x0 + xc0) / 2;
                    yc0 = (y0 + yc0) / 2;
                    xc1 = (xc1 + x1) / 2;
                    yc1 = (yc1 + y1) / 2;
                    var xc0m = (xc0 + xmid) / 2;
                    var yc0m = (yc0 + ymid) / 2;
                    var xmc1 = (xmid + xc1) / 2;
                    var ymc1 = (ymid + yc1) / 2;
                    xmid = (xc0m + xmc1) / 2;
                    ymid = (yc0m + ymc1) / 2;
                    if ( /* isNaN */isNaN(xmid) || /* isNaN */ isNaN(ymid)) {
                        return 0;
                    }
                    crossings = Curve.rectCrossingsForCubic(crossings, rxmin, rymin, rxmax, rymax, x0, y0, xc0, yc0, xc0m, yc0m, xmid, ymid, level + 1);
                    if (crossings !== Curve.RECT_INTERSECTS) {
                        crossings = Curve.rectCrossingsForCubic(crossings, rxmin, rymin, rxmax, rymax, xmid, ymid, xmc1, ymc1, xc1, yc1, x1, y1, level + 1);
                    }
                    return crossings;
                };
                Curve.prototype.getDirection = function () {
                    return this.direction;
                };
                Curve.prototype.getWithDirection = function (direction) {
                    return (this.direction === direction ? this : this.getReversedCurve());
                };
                Curve.round = function (v) {
                    return v;
                };
                Curve.orderof = function (x1, x2) {
                    if (x1 < x2) {
                        return -1;
                    }
                    if (x1 > x2) {
                        return 1;
                    }
                    return 0;
                };
                Curve.signeddiffbits = function (y1, y2) {
                    return ( /* doubleToLongBits */(function (f) { var buf = new ArrayBuffer(4); (new Float32Array(buf))[0] = f; return (new Uint32Array(buf))[0]; })(Math.fround(y1)) - /* doubleToLongBits */ (function (f) { var buf = new ArrayBuffer(4); (new Float32Array(buf))[0] = f; return (new Uint32Array(buf))[0]; })(Math.fround(y2)));
                };
                Curve.diffbits = function (y1, y2) {
                    return Math.abs(/* doubleToLongBits */ (function (f) { var buf = new ArrayBuffer(4); (new Float32Array(buf))[0] = f; return (new Uint32Array(buf))[0]; })(Math.fround(y1)) - /* doubleToLongBits */ (function (f) { var buf = new ArrayBuffer(4); (new Float32Array(buf))[0] = f; return (new Uint32Array(buf))[0]; })(Math.fround(y2)));
                };
                Curve.prev = function (v) {
                    return (function (v) { var buf = new ArrayBuffer(4); (new Uint32Array(buf))[0] = v; return (new Float32Array(buf))[0]; })(/* doubleToLongBits */ (function (f) { var buf = new ArrayBuffer(4); (new Float32Array(buf))[0] = f; return (new Uint32Array(buf))[0]; })(Math.fround(v)) - 1);
                };
                Curve.next = function (v) {
                    return (function (v) { var buf = new ArrayBuffer(4); (new Uint32Array(buf))[0] = v; return (new Float32Array(buf))[0]; })(/* doubleToLongBits */ (function (f) { var buf = new ArrayBuffer(4); (new Float32Array(buf))[0] = f; return (new Uint32Array(buf))[0]; })(Math.fround(v)) + 1);
                };
                Curve.prototype.toString = function () {
                    return ("Curve[" + this.getOrder() + ", " + ("(" + Curve.round(this.getX0()) + ", " + Curve.round(this.getY0()) + "), ") + this.controlPointString() + ("(" + Curve.round(this.getX1()) + ", " + Curve.round(this.getY1()) + "), ") + (this.direction === Curve.INCREASING ? "D" : "U") + "]");
                };
                Curve.prototype.controlPointString = function () {
                    return "";
                };
                Curve.prototype.crossingsFor = function (x, y) {
                    if (y >= this.getYTop() && y < this.getYBot()) {
                        if (x < this.getXMax() && (x < this.getXMin() || x < this.XforY(y))) {
                            return 1;
                        }
                    }
                    return 0;
                };
                Curve.prototype.accumulateCrossings = function (c) {
                    var xhi = c.getXHi();
                    if (this.getXMin() >= xhi) {
                        return false;
                    }
                    var xlo = c.getXLo();
                    var ylo = c.getYLo();
                    var yhi = c.getYHi();
                    var y0 = this.getYTop();
                    var y1 = this.getYBot();
                    var tstart;
                    var ystart;
                    var tend;
                    var yend;
                    if (y0 < ylo) {
                        if (y1 <= ylo) {
                            return false;
                        }
                        ystart = ylo;
                        tstart = this.TforY(ylo);
                    }
                    else {
                        if (y0 >= yhi) {
                            return false;
                        }
                        ystart = y0;
                        tstart = 0;
                    }
                    if (y1 > yhi) {
                        yend = yhi;
                        tend = this.TforY(yhi);
                    }
                    else {
                        yend = y1;
                        tend = 1;
                    }
                    var hitLo = false;
                    var hitHi = false;
                    while ((true)) {
                        {
                            var x = this.XforT(tstart);
                            if (x < xhi) {
                                if (hitHi || x > xlo) {
                                    return true;
                                }
                                hitLo = true;
                            }
                            else {
                                if (hitLo) {
                                    return true;
                                }
                                hitHi = true;
                            }
                            if (tstart >= tend) {
                                break;
                            }
                            tstart = this.nextVertical(tstart, tend);
                        }
                    }
                    ;
                    if (hitLo) {
                        c.record(ystart, yend, this.direction);
                    }
                    return false;
                };
                Curve.prototype.getSubCurve$double$double = function (ystart, yend) {
                    return this.getSubCurve$double$double$int(ystart, yend, this.direction);
                };
                Curve.prototype.getSubCurve$double$double$int = function (ystart, yend, dir) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
                Curve.prototype.getSubCurve = function (ystart, yend, dir) {
                    if (((typeof ystart === 'number') || ystart === null) && ((typeof yend === 'number') || yend === null) && ((typeof dir === 'number') || dir === null)) {
                        return this.getSubCurve$double$double$int(ystart, yend, dir);
                    }
                    else if (((typeof ystart === 'number') || ystart === null) && ((typeof yend === 'number') || yend === null) && dir === undefined) {
                        return this.getSubCurve$double$double(ystart, yend);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Curve.prototype.compareTo = function (that, yrange) {
                    var y0 = yrange[0];
                    var y1 = yrange[1];
                    y1 = Math.min(Math.min(y1, this.getYBot()), that.getYBot());
                    if (y1 <= yrange[0]) {
                        console.error("this == " + this);
                        console.error("that == " + that);
                        console.info("target range = " + yrange[0] + "=>" + yrange[1]);
                        throw Object.defineProperty(new Error("backstepping from " + yrange[0] + " to " + y1), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.VirtualMachineError', 'java.lang.InternalError', 'java.lang.Error', 'java.lang.Object'] });
                    }
                    yrange[1] = y1;
                    if (this.getXMax() <= that.getXMin()) {
                        if (this.getXMin() === that.getXMax()) {
                            return 0;
                        }
                        return -1;
                    }
                    if (this.getXMin() >= that.getXMax()) {
                        return 1;
                    }
                    var s0 = this.TforY(y0);
                    var ys0 = this.YforT(s0);
                    if (ys0 < y0) {
                        s0 = this.refineTforY(s0, ys0, y0);
                        ys0 = this.YforT(s0);
                    }
                    var s1 = this.TforY(y1);
                    if (this.YforT(s1) < y0) {
                        s1 = this.refineTforY(s1, this.YforT(s1), y0);
                    }
                    var t0 = that.TforY(y0);
                    var yt0 = that.YforT(t0);
                    if (yt0 < y0) {
                        t0 = that.refineTforY(t0, yt0, y0);
                        yt0 = that.YforT(t0);
                    }
                    var t1 = that.TforY(y1);
                    if (that.YforT(t1) < y0) {
                        t1 = that.refineTforY(t1, that.YforT(t1), y0);
                    }
                    var xs0 = this.XforT(s0);
                    var xt0 = that.XforT(t0);
                    var scale = Math.max(Math.abs(y0), Math.abs(y1));
                    var ymin = Math.max(scale * 1.0E-14, 1.0E-300);
                    if (this.fairlyClose(xs0, xt0)) {
                        var bump = ymin;
                        var maxbump = Math.min(ymin * 1.0E13, (y1 - y0) * 0.1);
                        var y = y0 + bump;
                        while ((y <= y1)) {
                            {
                                if (this.fairlyClose(this.XforY(y), that.XforY(y))) {
                                    if ((bump *= 2) > maxbump) {
                                        bump = maxbump;
                                    }
                                }
                                else {
                                    y -= bump;
                                    while ((true)) {
                                        {
                                            bump /= 2;
                                            var newy = y + bump;
                                            if (newy <= y) {
                                                break;
                                            }
                                            if (this.fairlyClose(this.XforY(newy), that.XforY(newy))) {
                                                y = newy;
                                            }
                                        }
                                    }
                                    ;
                                    break;
                                }
                                y += bump;
                            }
                        }
                        ;
                        if (y > y0) {
                            if (y < y1) {
                                yrange[1] = y;
                            }
                            return 0;
                        }
                    }
                    if (ymin <= 0) {
                        console.info("ymin = " + ymin);
                    }
                    while ((s0 < s1 && t0 < t1)) {
                        {
                            var sh = this.nextVertical(s0, s1);
                            var xsh = this.XforT(sh);
                            var ysh = this.YforT(sh);
                            var th = that.nextVertical(t0, t1);
                            var xth = that.XforT(th);
                            var yth = that.YforT(th);
                            try {
                                if (this.findIntersect(that, yrange, ymin, 0, 0, s0, xs0, ys0, sh, xsh, ysh, t0, xt0, yt0, th, xth, yth)) {
                                    break;
                                }
                            }
                            catch (t) {
                                console.error("Error: " + t);
                                console.error("y range was " + yrange[0] + "=>" + yrange[1]);
                                console.error("s y range is " + ys0 + "=>" + ysh);
                                console.error("t y range is " + yt0 + "=>" + yth);
                                console.error("ymin is " + ymin);
                                return 0;
                            }
                            ;
                            if (ysh < yth) {
                                if (ysh > yrange[0]) {
                                    if (ysh < yrange[1]) {
                                        yrange[1] = ysh;
                                    }
                                    break;
                                }
                                s0 = sh;
                                xs0 = xsh;
                                ys0 = ysh;
                            }
                            else {
                                if (yth > yrange[0]) {
                                    if (yth < yrange[1]) {
                                        yrange[1] = yth;
                                    }
                                    break;
                                }
                                t0 = th;
                                xt0 = xth;
                                yt0 = yth;
                            }
                        }
                    }
                    ;
                    var ymid = (yrange[0] + yrange[1]) / 2;
                    return Curve.orderof(this.XforY(ymid), that.XforY(ymid));
                };
                Curve.prototype.findIntersect = function (that, yrange, ymin, slevel, tlevel, s0, xs0, ys0, s1, xs1, ys1, t0, xt0, yt0, t1, xt1, yt1) {
                    if (ys0 > yt1 || yt0 > ys1) {
                        return false;
                    }
                    if (Math.min(xs0, xs1) > Math.max(xt0, xt1) || Math.max(xs0, xs1) < Math.min(xt0, xt1)) {
                        return false;
                    }
                    if (s1 - s0 > Curve.TMIN) {
                        var s = (s0 + s1) / 2;
                        var xs = this.XforT(s);
                        var ys = this.YforT(s);
                        if (s === s0 || s === s1) {
                            console.info("s0 = " + s0);
                            console.info("s1 = " + s1);
                            throw Object.defineProperty(new Error("no s progress!"), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.VirtualMachineError', 'java.lang.InternalError', 'java.lang.Error', 'java.lang.Object'] });
                        }
                        if (t1 - t0 > Curve.TMIN) {
                            var t = (t0 + t1) / 2;
                            var xt = that.XforT(t);
                            var yt = that.YforT(t);
                            if (t === t0 || t === t1) {
                                console.info("t0 = " + t0);
                                console.info("t1 = " + t1);
                                throw Object.defineProperty(new Error("no t progress!"), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.VirtualMachineError', 'java.lang.InternalError', 'java.lang.Error', 'java.lang.Object'] });
                            }
                            if (ys >= yt0 && yt >= ys0) {
                                if (this.findIntersect(that, yrange, ymin, slevel + 1, tlevel + 1, s0, xs0, ys0, s, xs, ys, t0, xt0, yt0, t, xt, yt)) {
                                    return true;
                                }
                            }
                            if (ys >= yt) {
                                if (this.findIntersect(that, yrange, ymin, slevel + 1, tlevel + 1, s0, xs0, ys0, s, xs, ys, t, xt, yt, t1, xt1, yt1)) {
                                    return true;
                                }
                            }
                            if (yt >= ys) {
                                if (this.findIntersect(that, yrange, ymin, slevel + 1, tlevel + 1, s, xs, ys, s1, xs1, ys1, t0, xt0, yt0, t, xt, yt)) {
                                    return true;
                                }
                            }
                            if (ys1 >= yt && yt1 >= ys) {
                                if (this.findIntersect(that, yrange, ymin, slevel + 1, tlevel + 1, s, xs, ys, s1, xs1, ys1, t, xt, yt, t1, xt1, yt1)) {
                                    return true;
                                }
                            }
                        }
                        else {
                            if (ys >= yt0) {
                                if (this.findIntersect(that, yrange, ymin, slevel + 1, tlevel, s0, xs0, ys0, s, xs, ys, t0, xt0, yt0, t1, xt1, yt1)) {
                                    return true;
                                }
                            }
                            if (yt1 >= ys) {
                                if (this.findIntersect(that, yrange, ymin, slevel + 1, tlevel, s, xs, ys, s1, xs1, ys1, t0, xt0, yt0, t1, xt1, yt1)) {
                                    return true;
                                }
                            }
                        }
                    }
                    else if (t1 - t0 > Curve.TMIN) {
                        var t = (t0 + t1) / 2;
                        var xt = that.XforT(t);
                        var yt = that.YforT(t);
                        if (t === t0 || t === t1) {
                            console.info("t0 = " + t0);
                            console.info("t1 = " + t1);
                            throw Object.defineProperty(new Error("no t progress!"), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.VirtualMachineError', 'java.lang.InternalError', 'java.lang.Error', 'java.lang.Object'] });
                        }
                        if (yt >= ys0) {
                            if (this.findIntersect(that, yrange, ymin, slevel, tlevel + 1, s0, xs0, ys0, s1, xs1, ys1, t0, xt0, yt0, t, xt, yt)) {
                                return true;
                            }
                        }
                        if (ys1 >= yt) {
                            if (this.findIntersect(that, yrange, ymin, slevel, tlevel + 1, s0, xs0, ys0, s1, xs1, ys1, t, xt, yt, t1, xt1, yt1)) {
                                return true;
                            }
                        }
                    }
                    else {
                        var xlk = xs1 - xs0;
                        var ylk = ys1 - ys0;
                        var xnm = xt1 - xt0;
                        var ynm = yt1 - yt0;
                        var xmk = xt0 - xs0;
                        var ymk = yt0 - ys0;
                        var det = xnm * ylk - ynm * xlk;
                        if (det !== 0) {
                            var detinv = 1 / det;
                            var s = (xnm * ymk - ynm * xmk) * detinv;
                            var t = (xlk * ymk - ylk * xmk) * detinv;
                            if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {
                                s = s0 + s * (s1 - s0);
                                t = t0 + t * (t1 - t0);
                                if (s < 0 || s > 1 || t < 0 || t > 1) {
                                    console.info("Uh oh!");
                                }
                                var y = (this.YforT(s) + that.YforT(t)) / 2;
                                if (y <= yrange[1] && y > yrange[0]) {
                                    yrange[1] = y;
                                    return true;
                                }
                            }
                        }
                    }
                    return false;
                };
                Curve.prototype.refineTforY = function (t0, yt0, y0) {
                    var t1 = 1;
                    while ((true)) {
                        {
                            var th = (t0 + t1) / 2;
                            if (th === t0 || th === t1) {
                                return t1;
                            }
                            var y = this.YforT(th);
                            if (y < y0) {
                                t0 = th;
                                yt0 = y;
                            }
                            else if (y > y0) {
                                t1 = th;
                            }
                            else {
                                return t1;
                            }
                        }
                    }
                    ;
                };
                Curve.prototype.fairlyClose = function (v1, v2) {
                    return (Math.abs(v1 - v2) < Math.max(Math.abs(v1), Math.abs(v2)) * 1.0E-10);
                };
                Curve.INCREASING = 1;
                Curve.DECREASING = -1;
                /**
                 * The rectangle intersection test counts the number of times that the path
                 * crosses through the shadow that the rectangle projects to the right
                 * towards (x => +INFINITY).
                 *
                 * During processing of the path it actually counts every time the path
                 * crosses either or both of the top and bottom edges of that shadow. If the
                 * path enters from the top, the count is incremented. If it then exits back
                 * through the top, the same way it came in, the count is decremented and
                 * there is no impact on the winding count. If, instead, the path exits out
                 * the bottom, then the count is incremented again and a full pass through
                 * the shadow is indicated by the winding count having been incremented by
                 * 2.
                 *
                 * Thus, the winding count that it accumulates is actually double the real
                 * winding count. Since the path is continuous, the final answer should be a
                 * multiple of 2, otherwise there is a logic error somewhere.
                 *
                 * If the path ever has a direct hit on the rectangle, then a special value
                 * is returned. This special value terminates all ongoing accumulation on up
                 * through the call chain and ends up getting returned to the calling
                 * function which can then produce an answer directly. For intersection
                 * tests, the answer is always "true" if the path intersects the rectangle.
                 * For containment tests, the answer is always "false" if the path
                 * intersects the rectangle. Thus, no further processing is ever needed if
                 * an intersection occurs.
                 */
                Curve.RECT_INTERSECTS = -2147483648;
                Curve.TMIN = 0.001;
                return Curve;
            }());
            geom.Curve = Curve;
            Curve["__class"] = "sun.awt.geom.Curve";
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = sun.awt || (sun.awt = {}));
})(sun || (sun = {}));
(function (sun) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            var Edge = /** @class */ (function () {
                function Edge(c, ctag, etag) {
                    var _this = this;
                    if (((c != null && c instanceof sun.awt.geom.Curve) || c === null) && ((typeof ctag === 'number') || ctag === null) && ((typeof etag === 'number') || etag === null)) {
                        var __args = arguments;
                        if (this.curve === undefined)
                            this.curve = null;
                        if (this.ctag === undefined)
                            this.ctag = 0;
                        if (this.etag === undefined)
                            this.etag = 0;
                        if (this.activey === undefined)
                            this.activey = 0;
                        if (this.equivalence === undefined)
                            this.equivalence = 0;
                        if (this.lastEdge === undefined)
                            this.lastEdge = null;
                        if (this.lastResult === undefined)
                            this.lastResult = 0;
                        if (this.lastLimit === undefined)
                            this.lastLimit = 0;
                        if (this.curve === undefined)
                            this.curve = null;
                        if (this.ctag === undefined)
                            this.ctag = 0;
                        if (this.etag === undefined)
                            this.etag = 0;
                        if (this.activey === undefined)
                            this.activey = 0;
                        if (this.equivalence === undefined)
                            this.equivalence = 0;
                        if (this.lastEdge === undefined)
                            this.lastEdge = null;
                        if (this.lastResult === undefined)
                            this.lastResult = 0;
                        if (this.lastLimit === undefined)
                            this.lastLimit = 0;
                        (function () {
                            _this.curve = c;
                            _this.ctag = ctag;
                            _this.etag = etag;
                        })();
                    }
                    else if (((c != null && c instanceof sun.awt.geom.Curve) || c === null) && ((typeof ctag === 'number') || ctag === null) && etag === undefined) {
                        var __args = arguments;
                        {
                            var __args_1 = arguments;
                            var etag_1 = sun.awt.geom.AreaOp.ETAG_IGNORE;
                            if (this.curve === undefined)
                                this.curve = null;
                            if (this.ctag === undefined)
                                this.ctag = 0;
                            if (this.etag === undefined)
                                this.etag = 0;
                            if (this.activey === undefined)
                                this.activey = 0;
                            if (this.equivalence === undefined)
                                this.equivalence = 0;
                            if (this.lastEdge === undefined)
                                this.lastEdge = null;
                            if (this.lastResult === undefined)
                                this.lastResult = 0;
                            if (this.lastLimit === undefined)
                                this.lastLimit = 0;
                            if (this.curve === undefined)
                                this.curve = null;
                            if (this.ctag === undefined)
                                this.ctag = 0;
                            if (this.etag === undefined)
                                this.etag = 0;
                            if (this.activey === undefined)
                                this.activey = 0;
                            if (this.equivalence === undefined)
                                this.equivalence = 0;
                            if (this.lastEdge === undefined)
                                this.lastEdge = null;
                            if (this.lastResult === undefined)
                                this.lastResult = 0;
                            if (this.lastLimit === undefined)
                                this.lastLimit = 0;
                            (function () {
                                _this.curve = c;
                                _this.ctag = ctag;
                                _this.etag = etag_1;
                            })();
                        }
                    }
                    else
                        throw new Error('invalid overload');
                }
                Edge.prototype.getCurve = function () {
                    return this.curve;
                };
                Edge.prototype.getCurveTag = function () {
                    return this.ctag;
                };
                Edge.prototype.getEdgeTag = function () {
                    return this.etag;
                };
                Edge.prototype.setEdgeTag = function (etag) {
                    this.etag = etag;
                };
                Edge.prototype.getEquivalence = function () {
                    return this.equivalence;
                };
                Edge.prototype.setEquivalence = function (eq) {
                    this.equivalence = eq;
                };
                Edge.prototype.compareTo = function (other, yrange) {
                    if (other === this.lastEdge && yrange[0] < this.lastLimit) {
                        if (yrange[1] > this.lastLimit) {
                            yrange[1] = this.lastLimit;
                        }
                        return this.lastResult;
                    }
                    if (this === other.lastEdge && yrange[0] < other.lastLimit) {
                        if (yrange[1] > other.lastLimit) {
                            yrange[1] = other.lastLimit;
                        }
                        return 0 - other.lastResult;
                    }
                    var ret = this.curve.compareTo(other.curve, yrange);
                    this.lastEdge = other;
                    this.lastLimit = yrange[1];
                    this.lastResult = ret;
                    return ret;
                };
                Edge.prototype.record = function (yend, etag) {
                    this.activey = yend;
                    this.etag = etag;
                };
                Edge.prototype.isActiveFor = function (y, etag) {
                    return (this.etag === etag && this.activey >= y);
                };
                Edge.prototype.toString = function () {
                    return ("Edge[" + this.curve + ", " + (this.ctag === sun.awt.geom.AreaOp.CTAG_LEFT ? "L" : "R") + ", " + (this.etag === sun.awt.geom.AreaOp.ETAG_ENTER ? "I" : (this.etag === sun.awt.geom.AreaOp.ETAG_EXIT ? "O" : "N")) + "]");
                };
                Edge.INIT_PARTS = 4;
                Edge.GROW_PARTS = 10;
                return Edge;
            }());
            geom.Edge = Edge;
            Edge["__class"] = "sun.awt.geom.Edge";
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = sun.awt || (sun.awt = {}));
})(sun || (sun = {}));
(function (sun) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            var CurveLink = /** @class */ (function () {
                function CurveLink(curve, ystart, yend, etag) {
                    if (this.curve === undefined)
                        this.curve = null;
                    if (this.ytop === undefined)
                        this.ytop = 0;
                    if (this.ybot === undefined)
                        this.ybot = 0;
                    if (this.etag === undefined)
                        this.etag = 0;
                    if (this.next === undefined)
                        this.next = null;
                    this.curve = curve;
                    this.ytop = ystart;
                    this.ybot = yend;
                    this.etag = etag;
                    if (this.ytop < curve.getYTop() || this.ybot > curve.getYBot()) {
                        throw Object.defineProperty(new Error("bad curvelink [" + this.ytop + "=>" + this.ybot + "] for " + curve), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.VirtualMachineError', 'java.lang.InternalError', 'java.lang.Error', 'java.lang.Object'] });
                    }
                }
                CurveLink.prototype.absorb$sun_awt_geom_CurveLink = function (link) {
                    return this.absorb$sun_awt_geom_Curve$double$double$int(link.curve, link.ytop, link.ybot, link.etag);
                };
                CurveLink.prototype.absorb$sun_awt_geom_Curve$double$double$int = function (curve, ystart, yend, etag) {
                    if (this.curve !== curve || this.etag !== etag || this.ybot < ystart || this.ytop > yend) {
                        return false;
                    }
                    if (ystart < curve.getYTop() || yend > curve.getYBot()) {
                        throw Object.defineProperty(new Error("bad curvelink [" + ystart + "=>" + yend + "] for " + curve), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.VirtualMachineError', 'java.lang.InternalError', 'java.lang.Error', 'java.lang.Object'] });
                    }
                    this.ytop = Math.min(this.ytop, ystart);
                    this.ybot = Math.max(this.ybot, yend);
                    return true;
                };
                CurveLink.prototype.absorb = function (curve, ystart, yend, etag) {
                    if (((curve != null && curve instanceof sun.awt.geom.Curve) || curve === null) && ((typeof ystart === 'number') || ystart === null) && ((typeof yend === 'number') || yend === null) && ((typeof etag === 'number') || etag === null)) {
                        return this.absorb$sun_awt_geom_Curve$double$double$int(curve, ystart, yend, etag);
                    }
                    else if (((curve != null && curve instanceof sun.awt.geom.CurveLink) || curve === null) && ystart === undefined && yend === undefined && etag === undefined) {
                        return this.absorb$sun_awt_geom_CurveLink(curve);
                    }
                    else
                        throw new Error('invalid overload');
                };
                CurveLink.prototype.isEmpty = function () {
                    return (this.ytop === this.ybot);
                };
                CurveLink.prototype.getCurve = function () {
                    return this.curve;
                };
                CurveLink.prototype.getSubCurve = function () {
                    if (this.ytop === this.curve.getYTop() && this.ybot === this.curve.getYBot()) {
                        return this.curve.getWithDirection(this.etag);
                    }
                    return this.curve.getSubCurve$double$double$int(this.ytop, this.ybot, this.etag);
                };
                CurveLink.prototype.getMoveto = function () {
                    return new sun.awt.geom.Order0(this.getXTop(), this.getYTop());
                };
                CurveLink.prototype.getXTop = function () {
                    return this.curve.XforY(this.ytop);
                };
                CurveLink.prototype.getYTop = function () {
                    return this.ytop;
                };
                CurveLink.prototype.getXBot = function () {
                    return this.curve.XforY(this.ybot);
                };
                CurveLink.prototype.getYBot = function () {
                    return this.ybot;
                };
                CurveLink.prototype.getX = function () {
                    return this.curve.XforY(this.ytop);
                };
                CurveLink.prototype.getEdgeTag = function () {
                    return this.etag;
                };
                CurveLink.prototype.setNext = function (link) {
                    this.next = link;
                };
                CurveLink.prototype.getNext = function () {
                    return this.next;
                };
                return CurveLink;
            }());
            geom.CurveLink = CurveLink;
            CurveLink["__class"] = "sun.awt.geom.CurveLink";
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = sun.awt || (sun.awt = {}));
})(sun || (sun = {}));
var java;
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * A utility class to iterate over the path segments of an rounded rectangle
             * through the PathIterator interface.
             *
             * @author Jim Graham
             * @class
             */
            var RoundRectIterator = /** @class */ (function () {
                function RoundRectIterator(rr, at) {
                    if (this.x === undefined)
                        this.x = 0;
                    if (this.y === undefined)
                        this.y = 0;
                    if (this.w === undefined)
                        this.w = 0;
                    if (this.h === undefined)
                        this.h = 0;
                    if (this.aw === undefined)
                        this.aw = 0;
                    if (this.ah === undefined)
                        this.ah = 0;
                    if (this.affine === undefined)
                        this.affine = null;
                    if (this.index === undefined)
                        this.index = 0;
                    this.x = rr.getX();
                    this.y = rr.getY();
                    this.w = rr.getWidth();
                    this.h = rr.getHeight();
                    this.aw = Math.min(this.w, Math.abs(rr.getArcWidth()));
                    this.ah = Math.min(this.h, Math.abs(rr.getArcHeight()));
                    this.affine = at;
                    if (this.aw < 0 || this.ah < 0) {
                        this.index = RoundRectIterator.ctrlpts_$LI$().length;
                    }
                }
                /**
                 * Return the winding rule for determining the insideness of the path.
                 *
                 * @see #WIND_EVEN_ODD
                 * @see #WIND_NON_ZERO
                 * @return {number}
                 */
                RoundRectIterator.prototype.getWindingRule = function () {
                    return java.awt.geom.PathIterator.WIND_NON_ZERO;
                };
                /**
                 * Tests if there are more points to read.
                 *
                 * @return {boolean} true if there are more points to read
                 */
                RoundRectIterator.prototype.isDone = function () {
                    return this.index >= RoundRectIterator.ctrlpts_$LI$().length;
                };
                /**
                 * Moves the iterator to the next segment of the path forwards along the
                 * primary direction of traversal as long as there are more points in that
                 * direction.
                 */
                RoundRectIterator.prototype.next = function () {
                    this.index++;
                };
                RoundRectIterator.angle_$LI$ = function () { if (RoundRectIterator.angle == null)
                    RoundRectIterator.angle = Math.PI / 4.0; return RoundRectIterator.angle; };
                ;
                RoundRectIterator.a_$LI$ = function () { if (RoundRectIterator.a == null)
                    RoundRectIterator.a = 1.0 - Math.cos(RoundRectIterator.angle_$LI$()); return RoundRectIterator.a; };
                ;
                RoundRectIterator.b_$LI$ = function () { if (RoundRectIterator.b == null)
                    RoundRectIterator.b = Math.tan(RoundRectIterator.angle_$LI$()); return RoundRectIterator.b; };
                ;
                RoundRectIterator.c_$LI$ = function () { if (RoundRectIterator.c == null)
                    RoundRectIterator.c = Math.sqrt(1.0 + RoundRectIterator.b_$LI$() * RoundRectIterator.b_$LI$()) - 1 + RoundRectIterator.a_$LI$(); return RoundRectIterator.c; };
                ;
                RoundRectIterator.cv_$LI$ = function () { if (RoundRectIterator.cv == null)
                    RoundRectIterator.cv = 4.0 / 3.0 * RoundRectIterator.a_$LI$() * RoundRectIterator.b_$LI$() / RoundRectIterator.c_$LI$(); return RoundRectIterator.cv; };
                ;
                RoundRectIterator.acv_$LI$ = function () { if (RoundRectIterator.acv == null)
                    RoundRectIterator.acv = (1.0 - RoundRectIterator.cv_$LI$()) / 2.0; return RoundRectIterator.acv; };
                ;
                RoundRectIterator.ctrlpts_$LI$ = function () { if (RoundRectIterator.ctrlpts == null)
                    RoundRectIterator.ctrlpts = [[0.0, 0.0, 0.0, 0.5], [0.0, 0.0, 1.0, -0.5], [0.0, 0.0, 1.0, -RoundRectIterator.acv_$LI$(), 0.0, RoundRectIterator.acv_$LI$(), 1.0, 0.0, 0.0, 0.5, 1.0, 0.0], [1.0, -0.5, 1.0, 0.0], [1.0, -RoundRectIterator.acv_$LI$(), 1.0, 0.0, 1.0, 0.0, 1.0, -RoundRectIterator.acv_$LI$(), 1.0, 0.0, 1.0, -0.5], [1.0, 0.0, 0.0, 0.5], [1.0, 0.0, 0.0, RoundRectIterator.acv_$LI$(), 1.0, -RoundRectIterator.acv_$LI$(), 0.0, 0.0, 1.0, -0.5, 0.0, 0.0], [0.0, 0.5, 0.0, 0.0], [0.0, RoundRectIterator.acv_$LI$(), 0.0, 0.0, 0.0, 0.0, 0.0, RoundRectIterator.acv_$LI$(), 0.0, 0.0, 0.0, 0.5], []]; return RoundRectIterator.ctrlpts; };
                ;
                RoundRectIterator.types_$LI$ = function () { if (RoundRectIterator.types == null)
                    RoundRectIterator.types = [java.awt.geom.PathIterator.SEG_MOVETO, java.awt.geom.PathIterator.SEG_LINETO, java.awt.geom.PathIterator.SEG_CUBICTO, java.awt.geom.PathIterator.SEG_LINETO, java.awt.geom.PathIterator.SEG_CUBICTO, java.awt.geom.PathIterator.SEG_LINETO, java.awt.geom.PathIterator.SEG_CUBICTO, java.awt.geom.PathIterator.SEG_LINETO, java.awt.geom.PathIterator.SEG_CUBICTO, java.awt.geom.PathIterator.SEG_CLOSE]; return RoundRectIterator.types; };
                ;
                RoundRectIterator.prototype.currentSegment$float_A = function (coords) {
                    if (this.isDone()) {
                        throw Object.defineProperty(new Error("roundrect iterator out of bounds"), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.Object', 'java.lang.RuntimeException', 'java.util.NoSuchElementException', 'java.lang.Exception'] });
                    }
                    var ctrls = RoundRectIterator.ctrlpts_$LI$()[this.index];
                    var nc = 0;
                    for (var i = 0; i < ctrls.length; i += 4) {
                        {
                            coords[nc++] = (this.x + ctrls[i + 0] * this.w + ctrls[i + 1] * this.aw);
                            coords[nc++] = (this.y + ctrls[i + 2] * this.h + ctrls[i + 3] * this.ah);
                        }
                        ;
                    }
                    if (this.affine != null) {
                        this.affine.transform$float_A$int$float_A$int$int(coords, 0, coords, 0, (nc / 2 | 0));
                    }
                    return RoundRectIterator.types_$LI$()[this.index];
                };
                /**
                 * Returns the coordinates and type of the current path segment in the
                 * iteration. The return value is the path segment type: SEG_MOVETO,
                 * SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE. A float array of
                 * length 6 must be passed in and may be used to store the coordinates of
                 * the point(s). Each point is stored as a pair of float x,y coordinates.
                 * SEG_MOVETO and SEG_LINETO types will return one point, SEG_QUADTO will
                 * return two points, SEG_CUBICTO will return 3 points and SEG_CLOSE will
                 * not return any points.
                 *
                 * @see #SEG_MOVETO
                 * @see #SEG_LINETO
                 * @see #SEG_QUADTO
                 * @see #SEG_CUBICTO
                 * @see #SEG_CLOSE
                 * @param {Array} coords
                 * @return {number}
                 */
                RoundRectIterator.prototype.currentSegment = function (coords) {
                    if (((coords != null && coords instanceof Array && (coords.length == 0 || coords[0] == null || (typeof coords[0] === 'number'))) || coords === null)) {
                        return this.currentSegment$float_A(coords);
                    }
                    else if (((coords != null && coords instanceof Array && (coords.length == 0 || coords[0] == null || (typeof coords[0] === 'number'))) || coords === null)) {
                        return this.currentSegment$double_A(coords);
                    }
                    else
                        throw new Error('invalid overload');
                };
                RoundRectIterator.prototype.currentSegment$double_A = function (coords) {
                    if (this.isDone()) {
                        throw Object.defineProperty(new Error("roundrect iterator out of bounds"), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.Object', 'java.lang.RuntimeException', 'java.util.NoSuchElementException', 'java.lang.Exception'] });
                    }
                    var ctrls = RoundRectIterator.ctrlpts_$LI$()[this.index];
                    var nc = 0;
                    for (var i = 0; i < ctrls.length; i += 4) {
                        {
                            coords[nc++] = (this.x + ctrls[i + 0] * this.w + ctrls[i + 1] * this.aw);
                            coords[nc++] = (this.y + ctrls[i + 2] * this.h + ctrls[i + 3] * this.ah);
                        }
                        ;
                    }
                    if (this.affine != null) {
                        this.affine.transform$double_A$int$double_A$int$int(coords, 0, coords, 0, (nc / 2 | 0));
                    }
                    return RoundRectIterator.types_$LI$()[this.index];
                };
                return RoundRectIterator;
            }());
            geom.RoundRectIterator = RoundRectIterator;
            RoundRectIterator["__class"] = "java.awt.geom.RoundRectIterator";
            RoundRectIterator["__interfaces"] = ["java.awt.geom.PathIterator"];
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * The <code>Point2D</code> class defines a point representing a location in
             * {@code (x,y)} coordinate space.
             * <p>
             * This class is only the abstract superclass for all objects that store a 2D
             * coordinate. The actual storage representation of the coordinates is left to
             * the subclass.
             *
             * @author Jim Graham
             * @since 1.2
             * @class
             */
            var Point2D = /** @class */ (function () {
                function Point2D() {
                }
                Point2D.prototype.setLocation$double$double = function (x, y) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
                /**
                 * Sets the location of this <code>Point2D</code> to the specified
                 * <code>double</code> coordinates.
                 *
                 * @param {number} x
                 * the new X coordinate of this {@code Point2D}
                 * @param {number} y
                 * the new Y coordinate of this {@code Point2D}
                 * @since 1.2
                 */
                Point2D.prototype.setLocation = function (x, y) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.setLocation$double$double(x, y);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && y === undefined) {
                        return this.setLocation$java_awt_geom_Point2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Point2D.prototype.setLocation$java_awt_geom_Point2D = function (p) {
                    this.setLocation$double$double(p.getX(), p.getY());
                };
                /**
                 * Returns the square of the distance between two points.
                 *
                 * @param {number} x1
                 * the X coordinate of the first specified point
                 * @param {number} y1
                 * the Y coordinate of the first specified point
                 * @param {number} x2
                 * the X coordinate of the second specified point
                 * @param {number} y2
                 * the Y coordinate of the second specified point
                 * @return {number} the square of the distance between the two sets of specified
                 * coordinates.
                 * @since 1.2
                 */
                Point2D.distanceSq = function (x1, y1, x2, y2) {
                    x1 -= x2;
                    y1 -= y2;
                    return (x1 * x1 + y1 * y1);
                };
                /**
                 * Returns the distance between two points.
                 *
                 * @param {number} x1
                 * the X coordinate of the first specified point
                 * @param {number} y1
                 * the Y coordinate of the first specified point
                 * @param {number} x2
                 * the X coordinate of the second specified point
                 * @param {number} y2
                 * the Y coordinate of the second specified point
                 * @return {number} the distance between the two sets of specified coordinates.
                 * @since 1.2
                 */
                Point2D.distance = function (x1, y1, x2, y2) {
                    x1 -= x2;
                    y1 -= y2;
                    return Math.sqrt(x1 * x1 + y1 * y1);
                };
                Point2D.prototype.distanceSq$double$double = function (px, py) {
                    px -= this.getX();
                    py -= this.getY();
                    return (px * px + py * py);
                };
                /**
                 * Returns the square of the distance from this <code>Point2D</code> to a
                 * specified point.
                 *
                 * @param {number} px
                 * the X coordinate of the specified point to be measured against
                 * this <code>Point2D</code>
                 * @param {number} py
                 * the Y coordinate of the specified point to be measured against
                 * this <code>Point2D</code>
                 * @return {number} the square of the distance between this <code>Point2D</code> and
                 * the specified point.
                 * @since 1.2
                 */
                Point2D.prototype.distanceSq = function (px, py) {
                    if (((typeof px === 'number') || px === null) && ((typeof py === 'number') || py === null)) {
                        return this.distanceSq$double$double(px, py);
                    }
                    else if (((px != null && px instanceof java.awt.geom.Point2D) || px === null) && py === undefined) {
                        return this.distanceSq$java_awt_geom_Point2D(px);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Point2D.prototype.distanceSq$java_awt_geom_Point2D = function (pt) {
                    var px = pt.getX() - this.getX();
                    var py = pt.getY() - this.getY();
                    return (px * px + py * py);
                };
                Point2D.prototype.distance$double$double = function (px, py) {
                    px -= this.getX();
                    py -= this.getY();
                    return Math.sqrt(px * px + py * py);
                };
                /**
                 * Returns the distance from this <code>Point2D</code> to a specified point.
                 *
                 * @param {number} px
                 * the X coordinate of the specified point to be measured against
                 * this <code>Point2D</code>
                 * @param {number} py
                 * the Y coordinate of the specified point to be measured against
                 * this <code>Point2D</code>
                 * @return {number} the distance between this <code>Point2D</code> and a specified
                 * point.
                 * @since 1.2
                 */
                Point2D.prototype.distance = function (px, py) {
                    if (((typeof px === 'number') || px === null) && ((typeof py === 'number') || py === null)) {
                        return this.distance$double$double(px, py);
                    }
                    else if (((px != null && px instanceof java.awt.geom.Point2D) || px === null) && py === undefined) {
                        return this.distance$java_awt_geom_Point2D(px);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Point2D.prototype.distance$java_awt_geom_Point2D = function (pt) {
                    var px = pt.getX() - this.getX();
                    var py = pt.getY() - this.getY();
                    return Math.sqrt(px * px + py * py);
                };
                /**
                 * Creates a new object of the same class and with the same contents as this
                 * object.
                 *
                 * @return {*} a clone of this instance.
                 * @exception OutOfMemoryError
                 * if there is not enough memory.
                 * @see java.lang.Cloneable
                 * @since 1.2
                 */
                Point2D.prototype.clone = function () {
                    try {
                        return /* clone */ /* clone */ (function (o) { var clone = Object.create(o); for (var p in o) {
                            if (o.hasOwnProperty(p))
                                clone[p] = o[p];
                        } return clone; })(this);
                    }
                    catch (e) {
                        throw Object.defineProperty(new Error(e.message), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.VirtualMachineError', 'java.lang.InternalError', 'java.lang.Error', 'java.lang.Object'] });
                    }
                    ;
                };
                /**
                 * Determines whether or not two points are equal. Two instances of
                 * <code>Point2D</code> are equal if the values of their <code>x</code> and
                 * <code>y</code> member fields, representing their position in the
                 * coordinate space, are the same.
                 *
                 * @param {*} obj
                 * an object to be compared with this <code>Point2D</code>
                 * @return {boolean} <code>true</code> if the object to be compared is an instance of
                 * <code>Point2D</code> and has the same values; <code>false</code>
                 * otherwise.
                 * @since 1.2
                 */
                Point2D.prototype.equals = function (obj) {
                    if (obj != null && obj instanceof java.awt.geom.Point2D) {
                        var p2d = obj;
                        return (this.getX() === p2d.getX()) && (this.getY() === p2d.getY());
                    }
                    return /* equals */ (function (o1, o2) { if (o1 && o1.equals) {
                        return o1.equals(o2);
                    }
                    else {
                        return o1 === o2;
                    } })(this, obj);
                };
                return Point2D;
            }());
            geom.Point2D = Point2D;
            Point2D["__class"] = "java.awt.geom.Point2D";
            Point2D["__interfaces"] = ["java.lang.Cloneable"];
            (function (Point2D) {
                /**
                 * Constructs and initializes a <code>Point2D</code> with the specified
                 * coordinates.
                 *
                 * @param {number} x
                 * the X coordinate of the newly constructed
                 * <code>Point2D</code>
                 * @param {number} y
                 * the Y coordinate of the newly constructed
                 * <code>Point2D</code>
                 * @since 1.2
                 * @class
                 * @extends java.awt.geom.Point2D
                 */
                var Float = /** @class */ (function (_super) {
                    __extends(Float, _super);
                    function Float(x, y) {
                        var _this = this;
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                            var __args = arguments;
                            _this = _super.call(this) || this;
                            if (_this.x === undefined)
                                _this.x = 0;
                            if (_this.y === undefined)
                                _this.y = 0;
                            if (_this.x === undefined)
                                _this.x = 0;
                            if (_this.y === undefined)
                                _this.y = 0;
                            (function () {
                                _this.x = x;
                                _this.y = y;
                            })();
                        }
                        else if (x === undefined && y === undefined) {
                            var __args = arguments;
                            _this = _super.call(this) || this;
                            if (_this.x === undefined)
                                _this.x = 0;
                            if (_this.y === undefined)
                                _this.y = 0;
                            if (_this.x === undefined)
                                _this.x = 0;
                            if (_this.y === undefined)
                                _this.y = 0;
                        }
                        else
                            throw new Error('invalid overload');
                        return _this;
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Float.prototype.getX = function () {
                        return this.x;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Float.prototype.getY = function () {
                        return this.y;
                    };
                    Float.prototype.setLocation$double$double = function (x, y) {
                        this.x = x;
                        this.y = y;
                    };
                    Float.prototype.setLocation$float$float = function (x, y) {
                        this.x = x;
                        this.y = y;
                    };
                    /**
                     * Sets the location of this <code>Point2D</code> to the specified
                     * <code>float</code> coordinates.
                     *
                     * @param {number} x
                     * the new X coordinate of this {@code Point2D}
                     * @param {number} y
                     * the new Y coordinate of this {@code Point2D}
                     * @since 1.2
                     */
                    Float.prototype.setLocation = function (x, y) {
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                            return this.setLocation$float$float(x, y);
                        }
                        else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                            return this.setLocation$double$double(x, y);
                        }
                        else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && y === undefined) {
                            return this.setLocation$java_awt_geom_Point2D(x);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * Returns a <code>String</code> that represents the value of this
                     * <code>Point2D</code>.
                     *
                     * @return {string} a string representation of this <code>Point2D</code>.
                     * @since 1.2
                     */
                    Float.prototype.toString = function () {
                        return "Point2D.Float[" + this.x + ", " + this.y + "]";
                    };
                    Float.serialVersionUID = -2870572449815403710;
                    return Float;
                }(java.awt.geom.Point2D));
                Point2D.Float = Float;
                Float["__class"] = "java.awt.geom.Point2D.Float";
                Float["__interfaces"] = ["java.lang.Cloneable", "java.io.Serializable"];
                /**
                 * Constructs and initializes a <code>Point2D</code> with the specified
                 * coordinates.
                 *
                 * @param {number} x
                 * the X coordinate of the newly constructed
                 * <code>Point2D</code>
                 * @param {number} y
                 * the Y coordinate of the newly constructed
                 * <code>Point2D</code>
                 * @since 1.2
                 * @class
                 * @extends java.awt.geom.Point2D
                 */
                var Double = /** @class */ (function (_super) {
                    __extends(Double, _super);
                    function Double(x, y) {
                        var _this = this;
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                            var __args = arguments;
                            _this = _super.call(this) || this;
                            if (_this.x === undefined)
                                _this.x = 0;
                            if (_this.y === undefined)
                                _this.y = 0;
                            if (_this.x === undefined)
                                _this.x = 0;
                            if (_this.y === undefined)
                                _this.y = 0;
                            (function () {
                                _this.x = x;
                                _this.y = y;
                            })();
                        }
                        else if (x === undefined && y === undefined) {
                            var __args = arguments;
                            _this = _super.call(this) || this;
                            if (_this.x === undefined)
                                _this.x = 0;
                            if (_this.y === undefined)
                                _this.y = 0;
                            if (_this.x === undefined)
                                _this.x = 0;
                            if (_this.y === undefined)
                                _this.y = 0;
                        }
                        else
                            throw new Error('invalid overload');
                        return _this;
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Double.prototype.getX = function () {
                        return this.x;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Double.prototype.getY = function () {
                        return this.y;
                    };
                    Double.prototype.setLocation$double$double = function (x, y) {
                        this.x = x;
                        this.y = y;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @param {number} x
                     * @param {number} y
                     */
                    Double.prototype.setLocation = function (x, y) {
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                            return this.setLocation$double$double(x, y);
                        }
                        else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && y === undefined) {
                            return this.setLocation$java_awt_geom_Point2D(x);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * Returns a <code>String</code> that represents the value of this
                     * <code>Point2D</code>.
                     *
                     * @return {string} a string representation of this <code>Point2D</code>.
                     * @since 1.2
                     */
                    Double.prototype.toString = function () {
                        return "Point2D.Double[" + this.x + ", " + this.y + "]";
                    };
                    Double.serialVersionUID = 6150783262733311327;
                    return Double;
                }(java.awt.geom.Point2D));
                Point2D.Double = Double;
                Double["__class"] = "java.awt.geom.Point2D.Double";
                Double["__interfaces"] = ["java.lang.Cloneable", "java.io.Serializable"];
            })(Point2D = geom.Point2D || (geom.Point2D = {}));
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * This <code>Line2D</code> represents a line segment in {@code (x,y)}
             * coordinate space. This class, like all of the Java 2D API, uses a default
             * coordinate system called <i>user space</i> in which the y-axis values
             * increase downward and x-axis values increase to the right. For more
             * information on the user space coordinate system, see the <a href=
             * "http://docs.oracle.com/javase/1.3/docs/guide/2d/spec/j2d-intro.fm2.html#61857">
             * Coordinate Systems</a> section of the Java 2D Programmer's Guide.
             * <p>
             * This class is only the abstract superclass for all objects that store a 2D
             * line segment. The actual storage representation of the coordinates is left to
             * the subclass.
             *
             * @author Jim Graham
             * @since 1.2
             * @class
             */
            var Line2D = /** @class */ (function () {
                function Line2D() {
                }
                Line2D.prototype.setLine$double$double$double$double = function (x1, y1, x2, y2) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
                /**
                 * Sets the location of the end points of this <code>Line2D</code> to the
                 * specified double coordinates.
                 *
                 * @param {number} x1
                 * the X coordinate of the start point
                 * @param {number} y1
                 * the Y coordinate of the start point
                 * @param {number} x2
                 * the X coordinate of the end point
                 * @param {number} y2
                 * the Y coordinate of the end point
                 * @since 1.2
                 */
                Line2D.prototype.setLine = function (x1, y1, x2, y2) {
                    if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                        return this.setLine$double$double$double$double(x1, y1, x2, y2);
                    }
                    else if (((x1 != null && x1 instanceof java.awt.geom.Point2D) || x1 === null) && ((y1 != null && y1 instanceof java.awt.geom.Point2D) || y1 === null) && x2 === undefined && y2 === undefined) {
                        return this.setLine$java_awt_geom_Point2D$java_awt_geom_Point2D(x1, y1);
                    }
                    else if (((x1 != null && x1 instanceof java.awt.geom.Line2D) || x1 === null) && y1 === undefined && x2 === undefined && y2 === undefined) {
                        return this.setLine$java_awt_geom_Line2D(x1);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Line2D.prototype.setLine$java_awt_geom_Point2D$java_awt_geom_Point2D = function (p1, p2) {
                    this.setLine$double$double$double$double(p1.getX(), p1.getY(), p2.getX(), p2.getY());
                };
                Line2D.prototype.setLine$java_awt_geom_Line2D = function (l) {
                    this.setLine$double$double$double$double(l.getX1(), l.getY1(), l.getX2(), l.getY2());
                };
                /**
                 * Returns an indicator of where the specified point {@code (px,py)} lies
                 * with respect to the line segment from {@code (x1,y1)} to {@code (x2,y2)}.
                 * The return value can be either 1, -1, or 0 and indicates in which
                 * direction the specified line must pivot around its first end point,
                 * {@code (x1,y1)}, in order to point at the specified point {@code (px,py)}
                 * .
                 * <p>
                 * A return value of 1 indicates that the line segment must turn in the
                 * direction that takes the positive X axis towards the negative Y axis. In
                 * the default coordinate system used by Java 2D, this direction is
                 * counterclockwise.
                 * <p>
                 * A return value of -1 indicates that the line segment must turn in the
                 * direction that takes the positive X axis towards the positive Y axis. In
                 * the default coordinate system, this direction is clockwise.
                 * <p>
                 * A return value of 0 indicates that the point lies exactly on the line
                 * segment. Note that an indicator value of 0 is rare and not useful for
                 * determining collinearity because of floating point rounding issues.
                 * <p>
                 * If the point is colinear with the line segment, but not between the end
                 * points, then the value will be -1 if the point lies
                 * "beyond {@code (x1,y1)}" or 1 if the point lies "beyond {@code (x2,y2)}".
                 *
                 * @param {number} x1
                 * the X coordinate of the start point of the specified line
                 * segment
                 * @param {number} y1
                 * the Y coordinate of the start point of the specified line
                 * segment
                 * @param {number} x2
                 * the X coordinate of the end point of the specified line
                 * segment
                 * @param {number} y2
                 * the Y coordinate of the end point of the specified line
                 * segment
                 * @param {number} px
                 * the X coordinate of the specified point to be compared with
                 * the specified line segment
                 * @param {number} py
                 * the Y coordinate of the specified point to be compared with
                 * the specified line segment
                 * @return {number} an integer that indicates the position of the third specified
                 * coordinates with respect to the line segment formed by the first
                 * two specified coordinates.
                 * @since 1.2
                 */
                Line2D.relativeCCW = function (x1, y1, x2, y2, px, py) {
                    x2 -= x1;
                    y2 -= y1;
                    px -= x1;
                    py -= y1;
                    var ccw = px * y2 - py * x2;
                    if (ccw === 0.0) {
                        ccw = px * x2 + py * y2;
                        if (ccw > 0.0) {
                            px -= x2;
                            py -= y2;
                            ccw = px * x2 + py * y2;
                            if (ccw < 0.0) {
                                ccw = 0.0;
                            }
                        }
                    }
                    return (ccw < 0.0) ? -1 : ((ccw > 0.0) ? 1 : 0);
                };
                Line2D.prototype.relativeCCW$double$double = function (px, py) {
                    return Line2D.relativeCCW(this.getX1(), this.getY1(), this.getX2(), this.getY2(), px, py);
                };
                /**
                 * Returns an indicator of where the specified point {@code (px,py)} lies
                 * with respect to this line segment. See the method comments of
                 * {@link #relativeCCW(double, double, double, double, double, double)} to
                 * interpret the return value.
                 *
                 * @param {number} px
                 * the X coordinate of the specified point to be compared with
                 * this <code>Line2D</code>
                 * @param {number} py
                 * the Y coordinate of the specified point to be compared with
                 * this <code>Line2D</code>
                 * @return {number} an integer that indicates the position of the specified
                 * coordinates with respect to this <code>Line2D</code>
                 * @see #relativeCCW(double, double, double, double, double, double)
                 * @since 1.2
                 */
                Line2D.prototype.relativeCCW = function (px, py) {
                    if (((typeof px === 'number') || px === null) && ((typeof py === 'number') || py === null)) {
                        return this.relativeCCW$double$double(px, py);
                    }
                    else if (((px != null && px instanceof java.awt.geom.Point2D) || px === null) && py === undefined) {
                        return this.relativeCCW$java_awt_geom_Point2D(px);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Line2D.prototype.relativeCCW$java_awt_geom_Point2D = function (p) {
                    return Line2D.relativeCCW(this.getX1(), this.getY1(), this.getX2(), this.getY2(), p.getX(), p.getY());
                };
                /**
                 * Tests if the line segment from {@code (x1,y1)} to {@code (x2,y2)}
                 * intersects the line segment from {@code (x3,y3)} to {@code (x4,y4)}.
                 *
                 * @param {number} x1
                 * the X coordinate of the start point of the first specified
                 * line segment
                 * @param {number} y1
                 * the Y coordinate of the start point of the first specified
                 * line segment
                 * @param {number} x2
                 * the X coordinate of the end point of the first specified line
                 * segment
                 * @param {number} y2
                 * the Y coordinate of the end point of the first specified line
                 * segment
                 * @param {number} x3
                 * the X coordinate of the start point of the second specified
                 * line segment
                 * @param {number} y3
                 * the Y coordinate of the start point of the second specified
                 * line segment
                 * @param {number} x4
                 * the X coordinate of the end point of the second specified line
                 * segment
                 * @param {number} y4
                 * the Y coordinate of the end point of the second specified line
                 * segment
                 * @return {boolean} <code>true</code> if the first specified line segment and the
                 * second specified line segment intersect each other;
                 * <code>false</code> otherwise.
                 * @since 1.2
                 */
                Line2D.linesIntersect = function (x1, y1, x2, y2, x3, y3, x4, y4) {
                    return ((Line2D.relativeCCW(x1, y1, x2, y2, x3, y3) * Line2D.relativeCCW(x1, y1, x2, y2, x4, y4) <= 0) && (Line2D.relativeCCW(x3, y3, x4, y4, x1, y1) * Line2D.relativeCCW(x3, y3, x4, y4, x2, y2) <= 0));
                };
                Line2D.prototype.intersectsLine$double$double$double$double = function (x1, y1, x2, y2) {
                    return Line2D.linesIntersect(x1, y1, x2, y2, this.getX1(), this.getY1(), this.getX2(), this.getY2());
                };
                /**
                 * Tests if the line segment from {@code (x1,y1)} to {@code (x2,y2)}
                 * intersects this line segment.
                 *
                 * @param {number} x1
                 * the X coordinate of the start point of the specified line
                 * segment
                 * @param {number} y1
                 * the Y coordinate of the start point of the specified line
                 * segment
                 * @param {number} x2
                 * the X coordinate of the end point of the specified line
                 * segment
                 * @param {number} y2
                 * the Y coordinate of the end point of the specified line
                 * segment
                 * @return {boolean} {@code <true>} if this line segment and the specified line
                 * segment intersect each other; <code>false</code> otherwise.
                 * @since 1.2
                 */
                Line2D.prototype.intersectsLine = function (x1, y1, x2, y2) {
                    if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                        return this.intersectsLine$double$double$double$double(x1, y1, x2, y2);
                    }
                    else if (((x1 != null && x1 instanceof java.awt.geom.Line2D) || x1 === null) && y1 === undefined && x2 === undefined && y2 === undefined) {
                        return this.intersectsLine$java_awt_geom_Line2D(x1);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Line2D.prototype.intersectsLine$java_awt_geom_Line2D = function (l) {
                    return Line2D.linesIntersect(l.getX1(), l.getY1(), l.getX2(), l.getY2(), this.getX1(), this.getY1(), this.getX2(), this.getY2());
                };
                /**
                 * Returns the square of the distance from a point to a line segment. The
                 * distance measured is the distance between the specified point and the
                 * closest point between the specified end points. If the specified point
                 * intersects the line segment in between the end points, this method
                 * returns 0.0.
                 *
                 * @param {number} x1
                 * the X coordinate of the start point of the specified line
                 * segment
                 * @param {number} y1
                 * the Y coordinate of the start point of the specified line
                 * segment
                 * @param {number} x2
                 * the X coordinate of the end point of the specified line
                 * segment
                 * @param {number} y2
                 * the Y coordinate of the end point of the specified line
                 * segment
                 * @param {number} px
                 * the X coordinate of the specified point being measured against
                 * the specified line segment
                 * @param {number} py
                 * the Y coordinate of the specified point being measured against
                 * the specified line segment
                 * @return {number} a double value that is the square of the distance from the
                 * specified point to the specified line segment.
                 * @see #ptLineDistSq(double, double, double, double, double, double)
                 * @since 1.2
                 */
                Line2D.ptSegDistSq = function (x1, y1, x2, y2, px, py) {
                    x2 -= x1;
                    y2 -= y1;
                    px -= x1;
                    py -= y1;
                    var dotprod = px * x2 + py * y2;
                    var projlenSq;
                    if (dotprod <= 0.0) {
                        projlenSq = 0.0;
                    }
                    else {
                        px = x2 - px;
                        py = y2 - py;
                        dotprod = px * x2 + py * y2;
                        if (dotprod <= 0.0) {
                            projlenSq = 0.0;
                        }
                        else {
                            projlenSq = dotprod * dotprod / (x2 * x2 + y2 * y2);
                        }
                    }
                    var lenSq = px * px + py * py - projlenSq;
                    if (lenSq < 0) {
                        lenSq = 0;
                    }
                    return lenSq;
                };
                /**
                 * Returns the distance from a point to a line segment. The distance
                 * measured is the distance between the specified point and the closest
                 * point between the specified end points. If the specified point intersects
                 * the line segment in between the end points, this method returns 0.0.
                 *
                 * @param {number} x1
                 * the X coordinate of the start point of the specified line
                 * segment
                 * @param {number} y1
                 * the Y coordinate of the start point of the specified line
                 * segment
                 * @param {number} x2
                 * the X coordinate of the end point of the specified line
                 * segment
                 * @param {number} y2
                 * the Y coordinate of the end point of the specified line
                 * segment
                 * @param {number} px
                 * the X coordinate of the specified point being measured against
                 * the specified line segment
                 * @param {number} py
                 * the Y coordinate of the specified point being measured against
                 * the specified line segment
                 * @return {number} a double value that is the distance from the specified point to
                 * the specified line segment.
                 * @see #ptLineDist(double, double, double, double, double, double)
                 * @since 1.2
                 */
                Line2D.ptSegDist = function (x1, y1, x2, y2, px, py) {
                    return Math.sqrt(Line2D.ptSegDistSq(x1, y1, x2, y2, px, py));
                };
                Line2D.prototype.ptSegDistSq$double$double = function (px, py) {
                    return Line2D.ptSegDistSq(this.getX1(), this.getY1(), this.getX2(), this.getY2(), px, py);
                };
                /**
                 * Returns the square of the distance from a point to this line segment. The
                 * distance measured is the distance between the specified point and the
                 * closest point between the current line's end points. If the specified
                 * point intersects the line segment in between the end points, this method
                 * returns 0.0.
                 *
                 * @param {number} px
                 * the X coordinate of the specified point being measured against
                 * this line segment
                 * @param {number} py
                 * the Y coordinate of the specified point being measured against
                 * this line segment
                 * @return {number} a double value that is the square of the distance from the
                 * specified point to the current line segment.
                 * @see #ptLineDistSq(double, double)
                 * @since 1.2
                 */
                Line2D.prototype.ptSegDistSq = function (px, py) {
                    if (((typeof px === 'number') || px === null) && ((typeof py === 'number') || py === null)) {
                        return this.ptSegDistSq$double$double(px, py);
                    }
                    else if (((px != null && px instanceof java.awt.geom.Point2D) || px === null) && py === undefined) {
                        return this.ptSegDistSq$java_awt_geom_Point2D(px);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Line2D.prototype.ptSegDistSq$java_awt_geom_Point2D = function (pt) {
                    return Line2D.ptSegDistSq(this.getX1(), this.getY1(), this.getX2(), this.getY2(), pt.getX(), pt.getY());
                };
                Line2D.prototype.ptSegDist$double$double = function (px, py) {
                    return Line2D.ptSegDist(this.getX1(), this.getY1(), this.getX2(), this.getY2(), px, py);
                };
                /**
                 * Returns the distance from a point to this line segment. The distance
                 * measured is the distance between the specified point and the closest
                 * point between the current line's end points. If the specified point
                 * intersects the line segment in between the end points, this method
                 * returns 0.0.
                 *
                 * @param {number} px
                 * the X coordinate of the specified point being measured against
                 * this line segment
                 * @param {number} py
                 * the Y coordinate of the specified point being measured against
                 * this line segment
                 * @return {number} a double value that is the distance from the specified point to
                 * the current line segment.
                 * @see #ptLineDist(double, double)
                 * @since 1.2
                 */
                Line2D.prototype.ptSegDist = function (px, py) {
                    if (((typeof px === 'number') || px === null) && ((typeof py === 'number') || py === null)) {
                        return this.ptSegDist$double$double(px, py);
                    }
                    else if (((px != null && px instanceof java.awt.geom.Point2D) || px === null) && py === undefined) {
                        return this.ptSegDist$java_awt_geom_Point2D(px);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Line2D.prototype.ptSegDist$java_awt_geom_Point2D = function (pt) {
                    return Line2D.ptSegDist(this.getX1(), this.getY1(), this.getX2(), this.getY2(), pt.getX(), pt.getY());
                };
                /**
                 * Returns the square of the distance from a point to a line. The distance
                 * measured is the distance between the specified point and the closest
                 * point on the infinitely-extended line defined by the specified
                 * coordinates. If the specified point intersects the line, this method
                 * returns 0.0.
                 *
                 * @param {number} x1
                 * the X coordinate of the start point of the specified line
                 * @param {number} y1
                 * the Y coordinate of the start point of the specified line
                 * @param {number} x2
                 * the X coordinate of the end point of the specified line
                 * @param {number} y2
                 * the Y coordinate of the end point of the specified line
                 * @param {number} px
                 * the X coordinate of the specified point being measured against
                 * the specified line
                 * @param {number} py
                 * the Y coordinate of the specified point being measured against
                 * the specified line
                 * @return {number} a double value that is the square of the distance from the
                 * specified point to the specified line.
                 * @see #ptSegDistSq(double, double, double, double, double, double)
                 * @since 1.2
                 */
                Line2D.ptLineDistSq = function (x1, y1, x2, y2, px, py) {
                    x2 -= x1;
                    y2 -= y1;
                    px -= x1;
                    py -= y1;
                    var dotprod = px * x2 + py * y2;
                    var projlenSq = dotprod * dotprod / (x2 * x2 + y2 * y2);
                    var lenSq = px * px + py * py - projlenSq;
                    if (lenSq < 0) {
                        lenSq = 0;
                    }
                    return lenSq;
                };
                /**
                 * Returns the distance from a point to a line. The distance measured is the
                 * distance between the specified point and the closest point on the
                 * infinitely-extended line defined by the specified coordinates. If the
                 * specified point intersects the line, this method returns 0.0.
                 *
                 * @param {number} x1
                 * the X coordinate of the start point of the specified line
                 * @param {number} y1
                 * the Y coordinate of the start point of the specified line
                 * @param {number} x2
                 * the X coordinate of the end point of the specified line
                 * @param {number} y2
                 * the Y coordinate of the end point of the specified line
                 * @param {number} px
                 * the X coordinate of the specified point being measured against
                 * the specified line
                 * @param {number} py
                 * the Y coordinate of the specified point being measured against
                 * the specified line
                 * @return {number} a double value that is the distance from the specified point to
                 * the specified line.
                 * @see #ptSegDist(double, double, double, double, double, double)
                 * @since 1.2
                 */
                Line2D.ptLineDist = function (x1, y1, x2, y2, px, py) {
                    return Math.sqrt(Line2D.ptLineDistSq(x1, y1, x2, y2, px, py));
                };
                Line2D.prototype.ptLineDistSq$double$double = function (px, py) {
                    return Line2D.ptLineDistSq(this.getX1(), this.getY1(), this.getX2(), this.getY2(), px, py);
                };
                /**
                 * Returns the square of the distance from a point to this line. The
                 * distance measured is the distance between the specified point and the
                 * closest point on the infinitely-extended line defined by this
                 * <code>Line2D</code>. If the specified point intersects the line, this
                 * method returns 0.0.
                 *
                 * @param {number} px
                 * the X coordinate of the specified point being measured against
                 * this line
                 * @param {number} py
                 * the Y coordinate of the specified point being measured against
                 * this line
                 * @return {number} a double value that is the square of the distance from a
                 * specified point to the current line.
                 * @see #ptSegDistSq(double, double)
                 * @since 1.2
                 */
                Line2D.prototype.ptLineDistSq = function (px, py) {
                    if (((typeof px === 'number') || px === null) && ((typeof py === 'number') || py === null)) {
                        return this.ptLineDistSq$double$double(px, py);
                    }
                    else if (((px != null && px instanceof java.awt.geom.Point2D) || px === null) && py === undefined) {
                        return this.ptLineDistSq$java_awt_geom_Point2D(px);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Line2D.prototype.ptLineDistSq$java_awt_geom_Point2D = function (pt) {
                    return Line2D.ptLineDistSq(this.getX1(), this.getY1(), this.getX2(), this.getY2(), pt.getX(), pt.getY());
                };
                Line2D.prototype.ptLineDist$double$double = function (px, py) {
                    return Line2D.ptLineDist(this.getX1(), this.getY1(), this.getX2(), this.getY2(), px, py);
                };
                /**
                 * Returns the distance from a point to this line. The distance measured is
                 * the distance between the specified point and the closest point on the
                 * infinitely-extended line defined by this <code>Line2D</code>. If the
                 * specified point intersects the line, this method returns 0.0.
                 *
                 * @param {number} px
                 * the X coordinate of the specified point being measured against
                 * this line
                 * @param {number} py
                 * the Y coordinate of the specified point being measured against
                 * this line
                 * @return {number} a double value that is the distance from a specified point to the
                 * current line.
                 * @see #ptSegDist(double, double)
                 * @since 1.2
                 */
                Line2D.prototype.ptLineDist = function (px, py) {
                    if (((typeof px === 'number') || px === null) && ((typeof py === 'number') || py === null)) {
                        return this.ptLineDist$double$double(px, py);
                    }
                    else if (((px != null && px instanceof java.awt.geom.Point2D) || px === null) && py === undefined) {
                        return this.ptLineDist$java_awt_geom_Point2D(px);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Line2D.prototype.ptLineDist$java_awt_geom_Point2D = function (pt) {
                    return Line2D.ptLineDist(this.getX1(), this.getY1(), this.getX2(), this.getY2(), pt.getX(), pt.getY());
                };
                Line2D.prototype.contains$double$double = function (x, y) {
                    return false;
                };
                Line2D.prototype.contains$java_awt_geom_Point2D = function (p) {
                    return false;
                };
                Line2D.prototype.intersects$double$double$double$double = function (x, y, w, h) {
                    return this.intersects$java_awt_geom_Rectangle2D(new java.awt.geom.Rectangle2D.Double(x, y, w, h));
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 * @param {number} x
                 * @param {number} y
                 * @param {number} w
                 * @param {number} h
                 * @return {boolean}
                 */
                Line2D.prototype.intersects = function (x, y, w, h) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        return this.intersects$double$double$double$double(x, y, w, h);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.intersects$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Line2D.prototype.intersects$java_awt_geom_Rectangle2D = function (r) {
                    return r.intersectsLine$double$double$double$double(this.getX1(), this.getY1(), this.getX2(), this.getY2());
                };
                Line2D.prototype.contains$double$double$double$double = function (x, y, w, h) {
                    return false;
                };
                /**
                 * Tests if the interior of this <code>Line2D</code> entirely contains the
                 * specified set of rectangular coordinates. This method is required to
                 * implement the <code>Shape</code> interface, but in the case of
                 * <code>Line2D</code> objects it always returns false since a line contains
                 * no area.
                 *
                 * @param {number} x
                 * the X coordinate of the upper-left corner of the specified
                 * rectangular area
                 * @param {number} y
                 * the Y coordinate of the upper-left corner of the specified
                 * rectangular area
                 * @param {number} w
                 * the width of the specified rectangular area
                 * @param {number} h
                 * the height of the specified rectangular area
                 * @return {boolean} <code>false</code> because a <code>Line2D</code> contains no
                 * area.
                 * @since 1.2
                 */
                Line2D.prototype.contains = function (x, y, w, h) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        return this.contains$double$double$double$double(x, y, w, h);
                    }
                    else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && w === undefined && h === undefined) {
                        return this.contains$double$double(x, y);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.contains$java_awt_geom_Point2D(x);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.contains$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Line2D.prototype.contains$java_awt_geom_Rectangle2D = function (r) {
                    return false;
                };
                Line2D.prototype.getPathIterator$java_awt_geom_AffineTransform = function (at) {
                    return new java.awt.geom.LineIterator(this, at);
                };
                Line2D.prototype.getPathIterator$java_awt_geom_AffineTransform$double = function (at, flatness) {
                    return new java.awt.geom.LineIterator(this, at);
                };
                /**
                 * Returns an iteration object that defines the boundary of this flattened
                 * <code>Line2D</code>. The iterator for this class is not multi-threaded
                 * safe, which means that this <code>Line2D</code> class does not guarantee
                 * that modifications to the geometry of this <code>Line2D</code> object do
                 * not affect any iterations of that geometry that are already in process.
                 *
                 * @param {java.awt.geom.AffineTransform} at
                 * the specified <code>AffineTransform</code>
                 * @param {number} flatness
                 * the maximum amount that the control points for a given curve
                 * can vary from colinear before a subdivided curve is replaced
                 * by a straight line connecting the end points. Since a
                 * <code>Line2D</code> object is always flat, this parameter is
                 * ignored.
                 * @return {*} a <code>PathIterator</code> that defines the boundary of the
                 * flattened <code>Line2D</code>
                 * @since 1.2
                 */
                Line2D.prototype.getPathIterator = function (at, flatness) {
                    if (((at != null && at instanceof java.awt.geom.AffineTransform) || at === null) && ((typeof flatness === 'number') || flatness === null)) {
                        return this.getPathIterator$java_awt_geom_AffineTransform$double(at, flatness);
                    }
                    else if (((at != null && at instanceof java.awt.geom.AffineTransform) || at === null) && flatness === undefined) {
                        return this.getPathIterator$java_awt_geom_AffineTransform(at);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Creates a new object of the same class as this object.
                 *
                 * @return {*} a clone of this instance.
                 * @exception OutOfMemoryError
                 * if there is not enough memory.
                 * @see java.lang.Cloneable
                 * @since 1.2
                 */
                Line2D.prototype.clone = function () {
                    try {
                        return /* clone */ /* clone */ (function (o) { var clone = Object.create(o); for (var p in o) {
                            if (o.hasOwnProperty(p))
                                clone[p] = o[p];
                        } return clone; })(this);
                    }
                    catch (e) {
                        throw Object.defineProperty(new Error(e.message), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.VirtualMachineError', 'java.lang.InternalError', 'java.lang.Error', 'java.lang.Object'] });
                    }
                    ;
                };
                return Line2D;
            }());
            geom.Line2D = Line2D;
            Line2D["__class"] = "java.awt.geom.Line2D";
            Line2D["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable"];
            (function (Line2D) {
                /**
                 * Constructs and initializes a Line from the specified coordinates.
                 *
                 * @param {number} x1
                 * the X coordinate of the start point
                 * @param {number} y1
                 * the Y coordinate of the start point
                 * @param {number} x2
                 * the X coordinate of the end point
                 * @param {number} y2
                 * the Y coordinate of the end point
                 * @since 1.2
                 * @class
                 * @extends java.awt.geom.Line2D
                 */
                var Float = /** @class */ (function (_super) {
                    __extends(Float, _super);
                    function Float(x1, y1, x2, y2) {
                        var _this = this;
                        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                            var __args = arguments;
                            _this = _super.call(this) || this;
                            if (_this.x1 === undefined)
                                _this.x1 = 0;
                            if (_this.y1 === undefined)
                                _this.y1 = 0;
                            if (_this.x2 === undefined)
                                _this.x2 = 0;
                            if (_this.y2 === undefined)
                                _this.y2 = 0;
                            if (_this.x1 === undefined)
                                _this.x1 = 0;
                            if (_this.y1 === undefined)
                                _this.y1 = 0;
                            if (_this.x2 === undefined)
                                _this.x2 = 0;
                            if (_this.y2 === undefined)
                                _this.y2 = 0;
                            (function () {
                                _this.setLine$float$float$float$float(x1, y1, x2, y2);
                            })();
                        }
                        else if (((x1 != null && x1 instanceof java.awt.geom.Point2D) || x1 === null) && ((y1 != null && y1 instanceof java.awt.geom.Point2D) || y1 === null) && x2 === undefined && y2 === undefined) {
                            var __args = arguments;
                            var p1_1 = __args[0];
                            var p2_1 = __args[1];
                            _this = _super.call(this) || this;
                            if (_this.x1 === undefined)
                                _this.x1 = 0;
                            if (_this.y1 === undefined)
                                _this.y1 = 0;
                            if (_this.x2 === undefined)
                                _this.x2 = 0;
                            if (_this.y2 === undefined)
                                _this.y2 = 0;
                            if (_this.x1 === undefined)
                                _this.x1 = 0;
                            if (_this.y1 === undefined)
                                _this.y1 = 0;
                            if (_this.x2 === undefined)
                                _this.x2 = 0;
                            if (_this.y2 === undefined)
                                _this.y2 = 0;
                            (function () {
                                _this.setLine$java_awt_geom_Point2D$java_awt_geom_Point2D(p1_1, p2_1);
                            })();
                        }
                        else if (x1 === undefined && y1 === undefined && x2 === undefined && y2 === undefined) {
                            var __args = arguments;
                            _this = _super.call(this) || this;
                            if (_this.x1 === undefined)
                                _this.x1 = 0;
                            if (_this.y1 === undefined)
                                _this.y1 = 0;
                            if (_this.x2 === undefined)
                                _this.x2 = 0;
                            if (_this.y2 === undefined)
                                _this.y2 = 0;
                            if (_this.x1 === undefined)
                                _this.x1 = 0;
                            if (_this.y1 === undefined)
                                _this.y1 = 0;
                            if (_this.x2 === undefined)
                                _this.x2 = 0;
                            if (_this.y2 === undefined)
                                _this.y2 = 0;
                        }
                        else
                            throw new Error('invalid overload');
                        return _this;
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Float.prototype.getX1 = function () {
                        return this.x1;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Float.prototype.getY1 = function () {
                        return this.y1;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {java.awt.geom.Point2D}
                     */
                    Float.prototype.getP1 = function () {
                        return new java.awt.geom.Point2D.Float(this.x1, this.y1);
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Float.prototype.getX2 = function () {
                        return this.x2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Float.prototype.getY2 = function () {
                        return this.y2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {java.awt.geom.Point2D}
                     */
                    Float.prototype.getP2 = function () {
                        return new java.awt.geom.Point2D.Float(this.x2, this.y2);
                    };
                    Float.prototype.setLine$double$double$double$double = function (x1, y1, x2, y2) {
                        this.x1 = x1;
                        this.y1 = y1;
                        this.x2 = x2;
                        this.y2 = y2;
                    };
                    Float.prototype.setLine$float$float$float$float = function (x1, y1, x2, y2) {
                        this.x1 = x1;
                        this.y1 = y1;
                        this.x2 = x2;
                        this.y2 = y2;
                    };
                    /**
                     * Sets the location of the end points of this <code>Line2D</code> to
                     * the specified float coordinates.
                     *
                     * @param {number} x1
                     * the X coordinate of the start point
                     * @param {number} y1
                     * the Y coordinate of the start point
                     * @param {number} x2
                     * the X coordinate of the end point
                     * @param {number} y2
                     * the Y coordinate of the end point
                     * @since 1.2
                     */
                    Float.prototype.setLine = function (x1, y1, x2, y2) {
                        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                            return this.setLine$float$float$float$float(x1, y1, x2, y2);
                        }
                        else if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                            return this.setLine$double$double$double$double(x1, y1, x2, y2);
                        }
                        else if (((x1 != null && x1 instanceof java.awt.geom.Point2D) || x1 === null) && ((y1 != null && y1 instanceof java.awt.geom.Point2D) || y1 === null) && x2 === undefined && y2 === undefined) {
                            return this.setLine$java_awt_geom_Point2D$java_awt_geom_Point2D(x1, y1);
                        }
                        else if (((x1 != null && x1 instanceof java.awt.geom.Line2D) || x1 === null) && y1 === undefined && x2 === undefined && y2 === undefined) {
                            return this.setLine$java_awt_geom_Line2D(x1);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {java.awt.geom.Rectangle2D}
                     */
                    Float.prototype.getBounds2D = function () {
                        var x;
                        var y;
                        var w;
                        var h;
                        if (this.x1 < this.x2) {
                            x = this.x1;
                            w = this.x2 - this.x1;
                        }
                        else {
                            x = this.x2;
                            w = this.x1 - this.x2;
                        }
                        if (this.y1 < this.y2) {
                            y = this.y1;
                            h = this.y2 - this.y1;
                        }
                        else {
                            y = this.y2;
                            h = this.y1 - this.y2;
                        }
                        return new java.awt.geom.Rectangle2D.Float(x, y, w, h);
                    };
                    Float.serialVersionUID = 6161772511649436349;
                    return Float;
                }(java.awt.geom.Line2D));
                Line2D.Float = Float;
                Float["__class"] = "java.awt.geom.Line2D.Float";
                Float["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"];
                /**
                 * Constructs and initializes a <code>Line2D</code> from the specified
                 * coordinates.
                 *
                 * @param {number} x1
                 * the X coordinate of the start point
                 * @param {number} y1
                 * the Y coordinate of the start point
                 * @param {number} x2
                 * the X coordinate of the end point
                 * @param {number} y2
                 * the Y coordinate of the end point
                 * @since 1.2
                 * @class
                 * @extends java.awt.geom.Line2D
                 */
                var Double = /** @class */ (function (_super) {
                    __extends(Double, _super);
                    function Double(x1, y1, x2, y2) {
                        var _this = this;
                        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                            var __args = arguments;
                            _this = _super.call(this) || this;
                            if (_this.x1 === undefined)
                                _this.x1 = 0;
                            if (_this.y1 === undefined)
                                _this.y1 = 0;
                            if (_this.x2 === undefined)
                                _this.x2 = 0;
                            if (_this.y2 === undefined)
                                _this.y2 = 0;
                            if (_this.x1 === undefined)
                                _this.x1 = 0;
                            if (_this.y1 === undefined)
                                _this.y1 = 0;
                            if (_this.x2 === undefined)
                                _this.x2 = 0;
                            if (_this.y2 === undefined)
                                _this.y2 = 0;
                            (function () {
                                _this.setLine$double$double$double$double(x1, y1, x2, y2);
                            })();
                        }
                        else if (((x1 != null && x1 instanceof java.awt.geom.Point2D) || x1 === null) && ((y1 != null && y1 instanceof java.awt.geom.Point2D) || y1 === null) && x2 === undefined && y2 === undefined) {
                            var __args = arguments;
                            var p1_2 = __args[0];
                            var p2_2 = __args[1];
                            _this = _super.call(this) || this;
                            if (_this.x1 === undefined)
                                _this.x1 = 0;
                            if (_this.y1 === undefined)
                                _this.y1 = 0;
                            if (_this.x2 === undefined)
                                _this.x2 = 0;
                            if (_this.y2 === undefined)
                                _this.y2 = 0;
                            if (_this.x1 === undefined)
                                _this.x1 = 0;
                            if (_this.y1 === undefined)
                                _this.y1 = 0;
                            if (_this.x2 === undefined)
                                _this.x2 = 0;
                            if (_this.y2 === undefined)
                                _this.y2 = 0;
                            (function () {
                                _this.setLine$java_awt_geom_Point2D$java_awt_geom_Point2D(p1_2, p2_2);
                            })();
                        }
                        else if (x1 === undefined && y1 === undefined && x2 === undefined && y2 === undefined) {
                            var __args = arguments;
                            _this = _super.call(this) || this;
                            if (_this.x1 === undefined)
                                _this.x1 = 0;
                            if (_this.y1 === undefined)
                                _this.y1 = 0;
                            if (_this.x2 === undefined)
                                _this.x2 = 0;
                            if (_this.y2 === undefined)
                                _this.y2 = 0;
                            if (_this.x1 === undefined)
                                _this.x1 = 0;
                            if (_this.y1 === undefined)
                                _this.y1 = 0;
                            if (_this.x2 === undefined)
                                _this.x2 = 0;
                            if (_this.y2 === undefined)
                                _this.y2 = 0;
                        }
                        else
                            throw new Error('invalid overload');
                        return _this;
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Double.prototype.getX1 = function () {
                        return this.x1;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Double.prototype.getY1 = function () {
                        return this.y1;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {java.awt.geom.Point2D}
                     */
                    Double.prototype.getP1 = function () {
                        return new java.awt.geom.Point2D.Double(this.x1, this.y1);
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Double.prototype.getX2 = function () {
                        return this.x2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Double.prototype.getY2 = function () {
                        return this.y2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {java.awt.geom.Point2D}
                     */
                    Double.prototype.getP2 = function () {
                        return new java.awt.geom.Point2D.Double(this.x2, this.y2);
                    };
                    Double.prototype.setLine$double$double$double$double = function (x1, y1, x2, y2) {
                        this.x1 = x1;
                        this.y1 = y1;
                        this.x2 = x2;
                        this.y2 = y2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @param {number} x1
                     * @param {number} y1
                     * @param {number} x2
                     * @param {number} y2
                     */
                    Double.prototype.setLine = function (x1, y1, x2, y2) {
                        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                            return this.setLine$double$double$double$double(x1, y1, x2, y2);
                        }
                        else if (((x1 != null && x1 instanceof java.awt.geom.Point2D) || x1 === null) && ((y1 != null && y1 instanceof java.awt.geom.Point2D) || y1 === null) && x2 === undefined && y2 === undefined) {
                            return this.setLine$java_awt_geom_Point2D$java_awt_geom_Point2D(x1, y1);
                        }
                        else if (((x1 != null && x1 instanceof java.awt.geom.Line2D) || x1 === null) && y1 === undefined && x2 === undefined && y2 === undefined) {
                            return this.setLine$java_awt_geom_Line2D(x1);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {java.awt.geom.Rectangle2D}
                     */
                    Double.prototype.getBounds2D = function () {
                        var x;
                        var y;
                        var w;
                        var h;
                        if (this.x1 < this.x2) {
                            x = this.x1;
                            w = this.x2 - this.x1;
                        }
                        else {
                            x = this.x2;
                            w = this.x1 - this.x2;
                        }
                        if (this.y1 < this.y2) {
                            y = this.y1;
                            h = this.y2 - this.y1;
                        }
                        else {
                            y = this.y2;
                            h = this.y1 - this.y2;
                        }
                        return new java.awt.geom.Rectangle2D.Double(x, y, w, h);
                    };
                    Double.serialVersionUID = 7979627399746467499;
                    return Double;
                }(java.awt.geom.Line2D));
                Line2D.Double = Double;
                Double["__class"] = "java.awt.geom.Line2D.Double";
                Double["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"];
            })(Line2D = geom.Line2D || (geom.Line2D = {}));
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            var Helper = /** @class */ (function () {
                function Helper() {
                }
                Helper.unsafeClone = function (array, fromIndex, toIndex) {
                    return array.slice(fromIndex, toIndex);
                };
                Helper.arraycopy = function (src, srcOfs, dest, destOfs, len) {
                    var overwrite = true;
                    if (src === dest) {
                        src = Helper.unsafeClone(src, srcOfs, srcOfs + len);
                        srcOfs = 0;
                    }
                    for (var batchStart = srcOfs, end = srcOfs + len; batchStart < end;) {
                        {
                            var batchEnd = Math.min(batchStart + Helper.ARRAY_PROCESS_BATCH_SIZE, end);
                            len = batchEnd - batchStart;
                            Helper.applySplice(dest, destOfs, overwrite ? len : 0, Helper.unsafeClone(src, batchStart, batchEnd));
                            batchStart = batchEnd;
                            destOfs += len;
                        }
                        ;
                    }
                };
                /*private*/ Helper.applySplice = function (arrayObject, index, deleteCount, arrayToAdd) {
                    Array.prototype.splice.apply(arrayObject, [index, deleteCount].concat(arrayToAdd));
                };
                Helper.ARRAY_PROCESS_BATCH_SIZE = 10000;
                return Helper;
            }());
            geom.Helper = Helper;
            Helper["__class"] = "java.awt.geom.Helper";
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * A utility class to iterate over the path segments of a cubic curve segment
             * through the PathIterator interface.
             *
             * @author Jim Graham
             * @class
             */
            var CubicIterator = /** @class */ (function () {
                function CubicIterator(q, at) {
                    if (this.cubic === undefined)
                        this.cubic = null;
                    if (this.affine === undefined)
                        this.affine = null;
                    if (this.index === undefined)
                        this.index = 0;
                    this.cubic = q;
                    this.affine = at;
                }
                /**
                 * Return the winding rule for determining the insideness of the path.
                 *
                 * @see #WIND_EVEN_ODD
                 * @see #WIND_NON_ZERO
                 * @return {number}
                 */
                CubicIterator.prototype.getWindingRule = function () {
                    return java.awt.geom.PathIterator.WIND_NON_ZERO;
                };
                /**
                 * Tests if there are more points to read.
                 *
                 * @return {boolean} true if there are more points to read
                 */
                CubicIterator.prototype.isDone = function () {
                    return (this.index > 1);
                };
                /**
                 * Moves the iterator to the next segment of the path forwards along the
                 * primary direction of traversal as long as there are more points in that
                 * direction.
                 */
                CubicIterator.prototype.next = function () {
                    this.index++;
                };
                CubicIterator.prototype.currentSegment$float_A = function (coords) {
                    if (this.isDone()) {
                        throw Object.defineProperty(new Error("cubic iterator iterator out of bounds"), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.Object', 'java.lang.RuntimeException', 'java.util.NoSuchElementException', 'java.lang.Exception'] });
                    }
                    var type;
                    if (this.index === 0) {
                        coords[0] = this.cubic.getX1();
                        coords[1] = this.cubic.getY1();
                        type = java.awt.geom.PathIterator.SEG_MOVETO;
                    }
                    else {
                        coords[0] = this.cubic.getCtrlX1();
                        coords[1] = this.cubic.getCtrlY1();
                        coords[2] = this.cubic.getCtrlX2();
                        coords[3] = this.cubic.getCtrlY2();
                        coords[4] = this.cubic.getX2();
                        coords[5] = this.cubic.getY2();
                        type = java.awt.geom.PathIterator.SEG_CUBICTO;
                    }
                    if (this.affine != null) {
                        this.affine.transform$float_A$int$float_A$int$int(coords, 0, coords, 0, this.index === 0 ? 1 : 3);
                    }
                    return type;
                };
                /**
                 * Returns the coordinates and type of the current path segment in the
                 * iteration. The return value is the path segment type: SEG_MOVETO,
                 * SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE. A float array of
                 * length 6 must be passed in and may be used to store the coordinates of
                 * the point(s). Each point is stored as a pair of float x,y coordinates.
                 * SEG_MOVETO and SEG_LINETO types will return one point, SEG_QUADTO will
                 * return two points, SEG_CUBICTO will return 3 points and SEG_CLOSE will
                 * not return any points.
                 *
                 * @see #SEG_MOVETO
                 * @see #SEG_LINETO
                 * @see #SEG_QUADTO
                 * @see #SEG_CUBICTO
                 * @see #SEG_CLOSE
                 * @param {Array} coords
                 * @return {number}
                 */
                CubicIterator.prototype.currentSegment = function (coords) {
                    if (((coords != null && coords instanceof Array && (coords.length == 0 || coords[0] == null || (typeof coords[0] === 'number'))) || coords === null)) {
                        return this.currentSegment$float_A(coords);
                    }
                    else if (((coords != null && coords instanceof Array && (coords.length == 0 || coords[0] == null || (typeof coords[0] === 'number'))) || coords === null)) {
                        return this.currentSegment$double_A(coords);
                    }
                    else
                        throw new Error('invalid overload');
                };
                CubicIterator.prototype.currentSegment$double_A = function (coords) {
                    if (this.isDone()) {
                        throw Object.defineProperty(new Error("cubic iterator iterator out of bounds"), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.Object', 'java.lang.RuntimeException', 'java.util.NoSuchElementException', 'java.lang.Exception'] });
                    }
                    var type;
                    if (this.index === 0) {
                        coords[0] = this.cubic.getX1();
                        coords[1] = this.cubic.getY1();
                        type = java.awt.geom.PathIterator.SEG_MOVETO;
                    }
                    else {
                        coords[0] = this.cubic.getCtrlX1();
                        coords[1] = this.cubic.getCtrlY1();
                        coords[2] = this.cubic.getCtrlX2();
                        coords[3] = this.cubic.getCtrlY2();
                        coords[4] = this.cubic.getX2();
                        coords[5] = this.cubic.getY2();
                        type = java.awt.geom.PathIterator.SEG_CUBICTO;
                    }
                    if (this.affine != null) {
                        this.affine.transform$double_A$int$double_A$int$int(coords, 0, coords, 0, this.index === 0 ? 1 : 3);
                    }
                    return type;
                };
                return CubicIterator;
            }());
            geom.CubicIterator = CubicIterator;
            CubicIterator["__class"] = "java.awt.geom.CubicIterator";
            CubicIterator["__interfaces"] = ["java.awt.geom.PathIterator"];
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * The <code>Dimension2D</code> class is to encapsulate a width and a height
             * dimension.
             * <p>
             * This class is only the abstract superclass for all objects that store a 2D
             * dimension. The actual storage representation of the sizes is left to the
             * subclass.
             *
             * @author Jim Graham
             * @since 1.2
             * @class
             */
            var Dimension2D = /** @class */ (function () {
                function Dimension2D() {
                }
                Dimension2D.prototype.setSize$double$double = function (width, height) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
                /**
                 * Sets the size of this <code>Dimension</code> object to the specified
                 * width and height. This method is included for completeness, to parallel
                 * the {@link java.awt.Component#getSize} method of
                 * {@link java.awt.Component}.
                 *
                 * @param {number} width
                 * the new width for the <code>Dimension</code> object
                 * @param {number} height
                 * the new height for the <code>Dimension</code> object
                 * @since 1.2
                 */
                Dimension2D.prototype.setSize = function (width, height) {
                    if (((typeof width === 'number') || width === null) && ((typeof height === 'number') || height === null)) {
                        return this.setSize$double$double(width, height);
                    }
                    else if (((width != null && width instanceof java.awt.geom.Dimension2D) || width === null) && height === undefined) {
                        return this.setSize$java_awt_geom_Dimension2D(width);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Dimension2D.prototype.setSize$java_awt_geom_Dimension2D = function (d) {
                    this.setSize$double$double(d.getWidth(), d.getHeight());
                };
                /**
                 * Creates a new object of the same class as this object.
                 *
                 * @return {*} a clone of this instance.
                 * @exception OutOfMemoryError
                 * if there is not enough memory.
                 * @see java.lang.Cloneable
                 * @since 1.2
                 */
                Dimension2D.prototype.clone = function () {
                    try {
                        return /* clone */ /* clone */ (function (o) { var clone = Object.create(o); for (var p in o) {
                            if (o.hasOwnProperty(p))
                                clone[p] = o[p];
                        } return clone; })(this);
                    }
                    catch (e) {
                        throw Object.defineProperty(new Error(e.message), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.VirtualMachineError', 'java.lang.InternalError', 'java.lang.Error', 'java.lang.Object'] });
                    }
                    ;
                };
                return Dimension2D;
            }());
            geom.Dimension2D = Dimension2D;
            Dimension2D["__class"] = "java.awt.geom.Dimension2D";
            Dimension2D["__interfaces"] = ["java.lang.Cloneable"];
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * A utility class to iterate over the path segments of an arc through the
             * PathIterator interface.
             *
             * @author Jim Graham
             * @class
             */
            var ArcIterator = /** @class */ (function () {
                function ArcIterator(a, at) {
                    if (this.x === undefined)
                        this.x = 0;
                    if (this.y === undefined)
                        this.y = 0;
                    if (this.w === undefined)
                        this.w = 0;
                    if (this.h === undefined)
                        this.h = 0;
                    if (this.angStRad === undefined)
                        this.angStRad = 0;
                    if (this.increment === undefined)
                        this.increment = 0;
                    if (this.cv === undefined)
                        this.cv = 0;
                    if (this.affine === undefined)
                        this.affine = null;
                    if (this.index === undefined)
                        this.index = 0;
                    if (this.arcSegs === undefined)
                        this.arcSegs = 0;
                    if (this.lineSegs === undefined)
                        this.lineSegs = 0;
                    this.w = a.getWidth() / 2;
                    this.h = a.getHeight() / 2;
                    this.x = a.getX() + this.w;
                    this.y = a.getY() + this.h;
                    this.angStRad = -(function (x) { return x * Math.PI / 180; })(a.getAngleStart());
                    this.affine = at;
                    var ext = -a.getAngleExtent();
                    if (ext >= 360.0 || ext <= -360) {
                        this.arcSegs = 4;
                        this.increment = Math.PI / 2;
                        this.cv = 0.5522847498307933;
                        if (ext < 0) {
                            this.increment = -this.increment;
                            this.cv = -this.cv;
                        }
                    }
                    else {
                        this.arcSegs = (Math.ceil(Math.abs(ext) / 90.0) | 0);
                        this.increment = /* toRadians */ (function (x) { return x * Math.PI / 180; })(ext / this.arcSegs);
                        this.cv = ArcIterator.btan(this.increment);
                        if (this.cv === 0) {
                            this.arcSegs = 0;
                        }
                    }
                    switch ((a.getArcType())) {
                        case java.awt.geom.Arc2D.OPEN:
                            this.lineSegs = 0;
                            break;
                        case java.awt.geom.Arc2D.CHORD:
                            this.lineSegs = 1;
                            break;
                        case java.awt.geom.Arc2D.PIE:
                            this.lineSegs = 2;
                            break;
                    }
                    if (this.w < 0 || this.h < 0) {
                        this.arcSegs = this.lineSegs = -1;
                    }
                }
                /**
                 * Return the winding rule for determining the insideness of the path.
                 *
                 * @see #WIND_EVEN_ODD
                 * @see #WIND_NON_ZERO
                 * @return {number}
                 */
                ArcIterator.prototype.getWindingRule = function () {
                    return java.awt.geom.PathIterator.WIND_NON_ZERO;
                };
                /**
                 * Tests if there are more points to read.
                 *
                 * @return {boolean} true if there are more points to read
                 */
                ArcIterator.prototype.isDone = function () {
                    return this.index > this.arcSegs + this.lineSegs;
                };
                /**
                 * Moves the iterator to the next segment of the path forwards along the
                 * primary direction of traversal as long as there are more points in that
                 * direction.
                 */
                ArcIterator.prototype.next = function () {
                    this.index++;
                };
                /*private*/ ArcIterator.btan = function (increment) {
                    increment /= 2.0;
                    return 4.0 / 3.0 * Math.sin(increment) / (1.0 + Math.cos(increment));
                };
                ArcIterator.prototype.currentSegment$float_A = function (coords) {
                    if (this.isDone()) {
                        throw Object.defineProperty(new Error("arc iterator out of bounds"), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.Object', 'java.lang.RuntimeException', 'java.util.NoSuchElementException', 'java.lang.Exception'] });
                    }
                    var angle = this.angStRad;
                    if (this.index === 0) {
                        coords[0] = (this.x + Math.cos(angle) * this.w);
                        coords[1] = (this.y + Math.sin(angle) * this.h);
                        if (this.affine != null) {
                            this.affine.transform$float_A$int$float_A$int$int(coords, 0, coords, 0, 1);
                        }
                        return java.awt.geom.PathIterator.SEG_MOVETO;
                    }
                    if (this.index > this.arcSegs) {
                        if (this.index === this.arcSegs + this.lineSegs) {
                            return java.awt.geom.PathIterator.SEG_CLOSE;
                        }
                        coords[0] = this.x;
                        coords[1] = this.y;
                        if (this.affine != null) {
                            this.affine.transform$float_A$int$float_A$int$int(coords, 0, coords, 0, 1);
                        }
                        return java.awt.geom.PathIterator.SEG_LINETO;
                    }
                    angle += this.increment * (this.index - 1);
                    var relx = Math.cos(angle);
                    var rely = Math.sin(angle);
                    coords[0] = (this.x + (relx - this.cv * rely) * this.w);
                    coords[1] = (this.y + (rely + this.cv * relx) * this.h);
                    angle += this.increment;
                    relx = Math.cos(angle);
                    rely = Math.sin(angle);
                    coords[2] = (this.x + (relx + this.cv * rely) * this.w);
                    coords[3] = (this.y + (rely - this.cv * relx) * this.h);
                    coords[4] = (this.x + relx * this.w);
                    coords[5] = (this.y + rely * this.h);
                    if (this.affine != null) {
                        this.affine.transform$float_A$int$float_A$int$int(coords, 0, coords, 0, 3);
                    }
                    return java.awt.geom.PathIterator.SEG_CUBICTO;
                };
                /**
                 * Returns the coordinates and type of the current path segment in the
                 * iteration. The return value is the path segment type: SEG_MOVETO,
                 * SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE. A float array of
                 * length 6 must be passed in and may be used to store the coordinates of
                 * the point(s). Each point is stored as a pair of float x,y coordinates.
                 * SEG_MOVETO and SEG_LINETO types will return one point, SEG_QUADTO will
                 * return two points, SEG_CUBICTO will return 3 points and SEG_CLOSE will
                 * not return any points.
                 *
                 * @see #SEG_MOVETO
                 * @see #SEG_LINETO
                 * @see #SEG_QUADTO
                 * @see #SEG_CUBICTO
                 * @see #SEG_CLOSE
                 * @param {Array} coords
                 * @return {number}
                 */
                ArcIterator.prototype.currentSegment = function (coords) {
                    if (((coords != null && coords instanceof Array && (coords.length == 0 || coords[0] == null || (typeof coords[0] === 'number'))) || coords === null)) {
                        return this.currentSegment$float_A(coords);
                    }
                    else if (((coords != null && coords instanceof Array && (coords.length == 0 || coords[0] == null || (typeof coords[0] === 'number'))) || coords === null)) {
                        return this.currentSegment$double_A(coords);
                    }
                    else
                        throw new Error('invalid overload');
                };
                ArcIterator.prototype.currentSegment$double_A = function (coords) {
                    if (this.isDone()) {
                        throw Object.defineProperty(new Error("arc iterator out of bounds"), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.Object', 'java.lang.RuntimeException', 'java.util.NoSuchElementException', 'java.lang.Exception'] });
                    }
                    var angle = this.angStRad;
                    if (this.index === 0) {
                        coords[0] = this.x + Math.cos(angle) * this.w;
                        coords[1] = this.y + Math.sin(angle) * this.h;
                        if (this.affine != null) {
                            this.affine.transform$double_A$int$double_A$int$int(coords, 0, coords, 0, 1);
                        }
                        return java.awt.geom.PathIterator.SEG_MOVETO;
                    }
                    if (this.index > this.arcSegs) {
                        if (this.index === this.arcSegs + this.lineSegs) {
                            return java.awt.geom.PathIterator.SEG_CLOSE;
                        }
                        coords[0] = this.x;
                        coords[1] = this.y;
                        if (this.affine != null) {
                            this.affine.transform$double_A$int$double_A$int$int(coords, 0, coords, 0, 1);
                        }
                        return java.awt.geom.PathIterator.SEG_LINETO;
                    }
                    angle += this.increment * (this.index - 1);
                    var relx = Math.cos(angle);
                    var rely = Math.sin(angle);
                    coords[0] = this.x + (relx - this.cv * rely) * this.w;
                    coords[1] = this.y + (rely + this.cv * relx) * this.h;
                    angle += this.increment;
                    relx = Math.cos(angle);
                    rely = Math.sin(angle);
                    coords[2] = this.x + (relx + this.cv * rely) * this.w;
                    coords[3] = this.y + (rely - this.cv * relx) * this.h;
                    coords[4] = this.x + relx * this.w;
                    coords[5] = this.y + rely * this.h;
                    if (this.affine != null) {
                        this.affine.transform$double_A$int$double_A$int$int(coords, 0, coords, 0, 3);
                    }
                    return java.awt.geom.PathIterator.SEG_CUBICTO;
                };
                return ArcIterator;
            }());
            geom.ArcIterator = ArcIterator;
            ArcIterator["__class"] = "java.awt.geom.ArcIterator";
            ArcIterator["__interfaces"] = ["java.awt.geom.PathIterator"];
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * Constructs an <code>IllegalPathStateException</code> with the
             * specified detail message.
             * @param   {string} s   the detail message
             * @since   1.2
             * @class
             * @extends Error
             */
            var IllegalPathStateException = /** @class */ (function (_super) {
                __extends(IllegalPathStateException, _super);
                function IllegalPathStateException(s) {
                    var _this = this;
                    if (((typeof s === 'string') || s === null)) {
                        var __args = arguments;
                        _this = _super.call(this, s) || this;
                        _this.message = s;
                        Object.setPrototypeOf(_this, IllegalPathStateException.prototype);
                    }
                    else if (s === undefined) {
                        var __args = arguments;
                        _this = _super.call(this) || this;
                        Object.setPrototypeOf(_this, IllegalPathStateException.prototype);
                    }
                    else
                        throw new Error('invalid overload');
                    return _this;
                }
                return IllegalPathStateException;
            }(Error));
            geom.IllegalPathStateException = IllegalPathStateException;
            IllegalPathStateException["__class"] = "java.awt.geom.IllegalPathStateException";
            IllegalPathStateException["__interfaces"] = ["java.io.Serializable"];
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            var PathIterator;
            (function (PathIterator) {
                /**
                 * The winding rule constant for specifying an even-odd rule for determining
                 * the interior of a path. The even-odd rule specifies that a point lies
                 * inside the path if a ray drawn in any direction from that point to
                 * infinity is crossed by path segments an odd number of times.
                 */
                PathIterator.WIND_EVEN_ODD = 0;
                /**
                 * The winding rule constant for specifying a non-zero rule for determining
                 * the interior of a path. The non-zero rule specifies that a point lies
                 * inside the path if a ray drawn in any direction from that point to
                 * infinity is crossed by path segments a different number of times in the
                 * counter-clockwise direction than the clockwise direction.
                 */
                PathIterator.WIND_NON_ZERO = 1;
                /**
                 * The segment type constant for a point that specifies the starting
                 * location for a new subpath.
                 */
                PathIterator.SEG_MOVETO = 0;
                /**
                 * The segment type constant for a point that specifies the end point of a
                 * line to be drawn from the most recently specified point.
                 */
                PathIterator.SEG_LINETO = 1;
                /**
                 * The segment type constant for the pair of points that specify a quadratic
                 * parametric curve to be drawn from the most recently specified point. The
                 * curve is interpolated by solving the parametric control equation in the
                 * range <code>(t=[0..1])</code> using the most recently specified (current)
                 * point (CP), the first control point (P1), and the final interpolated
                 * control point (P2). The parametric control equation for this curve is:
                 *
                 * <pre>
                 * P(t) = B(2,0)*CP + B(2,1)*P1 + B(2,2)*P2
                 * 0 &lt;= t &lt;= 1
                 *
                 * B(n,m) = mth coefficient of nth degree Bernstein polynomial
                 * = C(n,m) * t^(m) * (1 - t)^(n-m)
                 * C(n,m) = Combinations of n things, taken m at a time
                 * = n! / (m! * (n-m)!)
                 * </pre>
                 */
                PathIterator.SEG_QUADTO = 2;
                /**
                 * The segment type constant for the set of 3 points that specify a cubic
                 * parametric curve to be drawn from the most recently specified point. The
                 * curve is interpolated by solving the parametric control equation in the
                 * range <code>(t=[0..1])</code> using the most recently specified (current)
                 * point (CP), the first control point (P1), the second control point (P2),
                 * and the final interpolated control point (P3). The parametric control
                 * equation for this curve is:
                 *
                 * <pre>
                 * P(t) = B(3,0)*CP + B(3,1)*P1 + B(3,2)*P2 + B(3,3)*P3
                 * 0 &lt;= t &lt;= 1
                 *
                 * B(n,m) = mth coefficient of nth degree Bernstein polynomial
                 * = C(n,m) * t^(m) * (1 - t)^(n-m)
                 * C(n,m) = Combinations of n things, taken m at a time
                 * = n! / (m! * (n-m)!)
                 * </pre>
                 *
                 * This form of curve is commonly known as a B&eacute;zier curve.
                 */
                PathIterator.SEG_CUBICTO = 3;
                /**
                 * The segment type constant that specifies that the preceding subpath
                 * should be closed by appending a line segment back to the point
                 * corresponding to the most recent SEG_MOVETO.
                 */
                PathIterator.SEG_CLOSE = 4;
            })(PathIterator = geom.PathIterator || (geom.PathIterator = {}));
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * Constructs a new <code>AffineTransform</code> from 6 floating point
             * values representing the 6 specifiable entries of the 3x3
             * transformation matrix.
             *
             * @param {number} m00 the X coordinate scaling element of the 3x3 matrix
             * @param {number} m10 the Y coordinate shearing element of the 3x3 matrix
             * @param {number} m01 the X coordinate shearing element of the 3x3 matrix
             * @param {number} m11 the Y coordinate scaling element of the 3x3 matrix
             * @param {number} m02 the X coordinate translation element of the 3x3 matrix
             * @param {number} m12 the Y coordinate translation element of the 3x3 matrix
             * @since 1.2
             * @class
             * @author Jim Graham
             */
            var AffineTransform = /** @class */ (function () {
                function AffineTransform(m00, m10, m01, m11, m02, m12, state) {
                    var _this = this;
                    if (((typeof m00 === 'number') || m00 === null) && ((typeof m10 === 'number') || m10 === null) && ((typeof m01 === 'number') || m01 === null) && ((typeof m11 === 'number') || m11 === null) && ((typeof m02 === 'number') || m02 === null) && ((typeof m12 === 'number') || m12 === null) && ((typeof state === 'number') || state === null)) {
                        var __args = arguments;
                        if (this.m00 === undefined)
                            this.m00 = 0;
                        if (this.m10 === undefined)
                            this.m10 = 0;
                        if (this.m01 === undefined)
                            this.m01 = 0;
                        if (this.m11 === undefined)
                            this.m11 = 0;
                        if (this.m02 === undefined)
                            this.m02 = 0;
                        if (this.m12 === undefined)
                            this.m12 = 0;
                        if (this.state === undefined)
                            this.state = 0;
                        if (this.type === undefined)
                            this.type = 0;
                        if (this.m00 === undefined)
                            this.m00 = 0;
                        if (this.m10 === undefined)
                            this.m10 = 0;
                        if (this.m01 === undefined)
                            this.m01 = 0;
                        if (this.m11 === undefined)
                            this.m11 = 0;
                        if (this.m02 === undefined)
                            this.m02 = 0;
                        if (this.m12 === undefined)
                            this.m12 = 0;
                        if (this.state === undefined)
                            this.state = 0;
                        if (this.type === undefined)
                            this.type = 0;
                        (function () {
                            _this.m00 = m00;
                            _this.m10 = m10;
                            _this.m01 = m01;
                            _this.m11 = m11;
                            _this.m02 = m02;
                            _this.m12 = m12;
                            _this.state = state;
                            _this.type = AffineTransform.TYPE_UNKNOWN;
                        })();
                    }
                    else if (((typeof m00 === 'number') || m00 === null) && ((typeof m10 === 'number') || m10 === null) && ((typeof m01 === 'number') || m01 === null) && ((typeof m11 === 'number') || m11 === null) && ((typeof m02 === 'number') || m02 === null) && ((typeof m12 === 'number') || m12 === null) && state === undefined) {
                        var __args = arguments;
                        if (this.m00 === undefined)
                            this.m00 = 0;
                        if (this.m10 === undefined)
                            this.m10 = 0;
                        if (this.m01 === undefined)
                            this.m01 = 0;
                        if (this.m11 === undefined)
                            this.m11 = 0;
                        if (this.m02 === undefined)
                            this.m02 = 0;
                        if (this.m12 === undefined)
                            this.m12 = 0;
                        if (this.state === undefined)
                            this.state = 0;
                        if (this.type === undefined)
                            this.type = 0;
                        if (this.m00 === undefined)
                            this.m00 = 0;
                        if (this.m10 === undefined)
                            this.m10 = 0;
                        if (this.m01 === undefined)
                            this.m01 = 0;
                        if (this.m11 === undefined)
                            this.m11 = 0;
                        if (this.m02 === undefined)
                            this.m02 = 0;
                        if (this.m12 === undefined)
                            this.m12 = 0;
                        if (this.state === undefined)
                            this.state = 0;
                        if (this.type === undefined)
                            this.type = 0;
                        (function () {
                            _this.m00 = m00;
                            _this.m10 = m10;
                            _this.m01 = m01;
                            _this.m11 = m11;
                            _this.m02 = m02;
                            _this.m12 = m12;
                            _this.updateState();
                        })();
                    }
                    else if (((typeof m00 === 'number') || m00 === null) && ((typeof m10 === 'number') || m10 === null) && ((typeof m01 === 'number') || m01 === null) && ((typeof m11 === 'number') || m11 === null) && ((typeof m02 === 'number') || m02 === null) && ((typeof m12 === 'number') || m12 === null) && state === undefined) {
                        var __args = arguments;
                        if (this.m00 === undefined)
                            this.m00 = 0;
                        if (this.m10 === undefined)
                            this.m10 = 0;
                        if (this.m01 === undefined)
                            this.m01 = 0;
                        if (this.m11 === undefined)
                            this.m11 = 0;
                        if (this.m02 === undefined)
                            this.m02 = 0;
                        if (this.m12 === undefined)
                            this.m12 = 0;
                        if (this.state === undefined)
                            this.state = 0;
                        if (this.type === undefined)
                            this.type = 0;
                        if (this.m00 === undefined)
                            this.m00 = 0;
                        if (this.m10 === undefined)
                            this.m10 = 0;
                        if (this.m01 === undefined)
                            this.m01 = 0;
                        if (this.m11 === undefined)
                            this.m11 = 0;
                        if (this.m02 === undefined)
                            this.m02 = 0;
                        if (this.m12 === undefined)
                            this.m12 = 0;
                        if (this.state === undefined)
                            this.state = 0;
                        if (this.type === undefined)
                            this.type = 0;
                        (function () {
                            _this.m00 = m00;
                            _this.m10 = m10;
                            _this.m01 = m01;
                            _this.m11 = m11;
                            _this.m02 = m02;
                            _this.m12 = m12;
                            _this.updateState();
                        })();
                    }
                    else if (((m00 != null && m00 instanceof java.awt.geom.AffineTransform) || m00 === null) && m10 === undefined && m01 === undefined && m11 === undefined && m02 === undefined && m12 === undefined && state === undefined) {
                        var __args = arguments;
                        var Tx_1 = __args[0];
                        if (this.m00 === undefined)
                            this.m00 = 0;
                        if (this.m10 === undefined)
                            this.m10 = 0;
                        if (this.m01 === undefined)
                            this.m01 = 0;
                        if (this.m11 === undefined)
                            this.m11 = 0;
                        if (this.m02 === undefined)
                            this.m02 = 0;
                        if (this.m12 === undefined)
                            this.m12 = 0;
                        if (this.state === undefined)
                            this.state = 0;
                        if (this.type === undefined)
                            this.type = 0;
                        if (this.m00 === undefined)
                            this.m00 = 0;
                        if (this.m10 === undefined)
                            this.m10 = 0;
                        if (this.m01 === undefined)
                            this.m01 = 0;
                        if (this.m11 === undefined)
                            this.m11 = 0;
                        if (this.m02 === undefined)
                            this.m02 = 0;
                        if (this.m12 === undefined)
                            this.m12 = 0;
                        if (this.state === undefined)
                            this.state = 0;
                        if (this.type === undefined)
                            this.type = 0;
                        (function () {
                            _this.m00 = Tx_1.m00;
                            _this.m10 = Tx_1.m10;
                            _this.m01 = Tx_1.m01;
                            _this.m11 = Tx_1.m11;
                            _this.m02 = Tx_1.m02;
                            _this.m12 = Tx_1.m12;
                            _this.state = Tx_1.state;
                            _this.type = Tx_1.type;
                        })();
                    }
                    else if (((m00 != null && m00 instanceof Array && (m00.length == 0 || m00[0] == null || (typeof m00[0] === 'number'))) || m00 === null) && m10 === undefined && m01 === undefined && m11 === undefined && m02 === undefined && m12 === undefined && state === undefined) {
                        var __args = arguments;
                        var flatmatrix_1 = __args[0];
                        if (this.m00 === undefined)
                            this.m00 = 0;
                        if (this.m10 === undefined)
                            this.m10 = 0;
                        if (this.m01 === undefined)
                            this.m01 = 0;
                        if (this.m11 === undefined)
                            this.m11 = 0;
                        if (this.m02 === undefined)
                            this.m02 = 0;
                        if (this.m12 === undefined)
                            this.m12 = 0;
                        if (this.state === undefined)
                            this.state = 0;
                        if (this.type === undefined)
                            this.type = 0;
                        if (this.m00 === undefined)
                            this.m00 = 0;
                        if (this.m10 === undefined)
                            this.m10 = 0;
                        if (this.m01 === undefined)
                            this.m01 = 0;
                        if (this.m11 === undefined)
                            this.m11 = 0;
                        if (this.m02 === undefined)
                            this.m02 = 0;
                        if (this.m12 === undefined)
                            this.m12 = 0;
                        if (this.state === undefined)
                            this.state = 0;
                        if (this.type === undefined)
                            this.type = 0;
                        (function () {
                            _this.m00 = flatmatrix_1[0];
                            _this.m10 = flatmatrix_1[1];
                            _this.m01 = flatmatrix_1[2];
                            _this.m11 = flatmatrix_1[3];
                            if (flatmatrix_1.length > 5) {
                                _this.m02 = flatmatrix_1[4];
                                _this.m12 = flatmatrix_1[5];
                            }
                            _this.updateState();
                        })();
                    }
                    else if (((m00 != null && m00 instanceof Array && (m00.length == 0 || m00[0] == null || (typeof m00[0] === 'number'))) || m00 === null) && m10 === undefined && m01 === undefined && m11 === undefined && m02 === undefined && m12 === undefined && state === undefined) {
                        var __args = arguments;
                        var flatmatrix_2 = __args[0];
                        if (this.m00 === undefined)
                            this.m00 = 0;
                        if (this.m10 === undefined)
                            this.m10 = 0;
                        if (this.m01 === undefined)
                            this.m01 = 0;
                        if (this.m11 === undefined)
                            this.m11 = 0;
                        if (this.m02 === undefined)
                            this.m02 = 0;
                        if (this.m12 === undefined)
                            this.m12 = 0;
                        if (this.state === undefined)
                            this.state = 0;
                        if (this.type === undefined)
                            this.type = 0;
                        if (this.m00 === undefined)
                            this.m00 = 0;
                        if (this.m10 === undefined)
                            this.m10 = 0;
                        if (this.m01 === undefined)
                            this.m01 = 0;
                        if (this.m11 === undefined)
                            this.m11 = 0;
                        if (this.m02 === undefined)
                            this.m02 = 0;
                        if (this.m12 === undefined)
                            this.m12 = 0;
                        if (this.state === undefined)
                            this.state = 0;
                        if (this.type === undefined)
                            this.type = 0;
                        (function () {
                            _this.m00 = flatmatrix_2[0];
                            _this.m10 = flatmatrix_2[1];
                            _this.m01 = flatmatrix_2[2];
                            _this.m11 = flatmatrix_2[3];
                            if (flatmatrix_2.length > 5) {
                                _this.m02 = flatmatrix_2[4];
                                _this.m12 = flatmatrix_2[5];
                            }
                            _this.updateState();
                        })();
                    }
                    else if (m00 === undefined && m10 === undefined && m01 === undefined && m11 === undefined && m02 === undefined && m12 === undefined && state === undefined) {
                        var __args = arguments;
                        if (this.m00 === undefined)
                            this.m00 = 0;
                        if (this.m10 === undefined)
                            this.m10 = 0;
                        if (this.m01 === undefined)
                            this.m01 = 0;
                        if (this.m11 === undefined)
                            this.m11 = 0;
                        if (this.m02 === undefined)
                            this.m02 = 0;
                        if (this.m12 === undefined)
                            this.m12 = 0;
                        if (this.state === undefined)
                            this.state = 0;
                        if (this.type === undefined)
                            this.type = 0;
                        if (this.m00 === undefined)
                            this.m00 = 0;
                        if (this.m10 === undefined)
                            this.m10 = 0;
                        if (this.m01 === undefined)
                            this.m01 = 0;
                        if (this.m11 === undefined)
                            this.m11 = 0;
                        if (this.m02 === undefined)
                            this.m02 = 0;
                        if (this.m12 === undefined)
                            this.m12 = 0;
                        if (this.state === undefined)
                            this.state = 0;
                        if (this.type === undefined)
                            this.type = 0;
                        (function () {
                            _this.m00 = _this.m11 = 1.0;
                        })();
                    }
                    else
                        throw new Error('invalid overload');
                }
                AffineTransform.TYPE_MASK_SCALE_$LI$ = function () { if (AffineTransform.TYPE_MASK_SCALE == null)
                    AffineTransform.TYPE_MASK_SCALE = (AffineTransform.TYPE_UNIFORM_SCALE | AffineTransform.TYPE_GENERAL_SCALE); return AffineTransform.TYPE_MASK_SCALE; };
                ;
                AffineTransform.TYPE_MASK_ROTATION_$LI$ = function () { if (AffineTransform.TYPE_MASK_ROTATION == null)
                    AffineTransform.TYPE_MASK_ROTATION = (AffineTransform.TYPE_QUADRANT_ROTATION | AffineTransform.TYPE_GENERAL_ROTATION); return AffineTransform.TYPE_MASK_ROTATION; };
                ;
                AffineTransform.HI_IDENTITY_$LI$ = function () { if (AffineTransform.HI_IDENTITY == null)
                    AffineTransform.HI_IDENTITY = AffineTransform.APPLY_IDENTITY << AffineTransform.HI_SHIFT; return AffineTransform.HI_IDENTITY; };
                ;
                AffineTransform.HI_TRANSLATE_$LI$ = function () { if (AffineTransform.HI_TRANSLATE == null)
                    AffineTransform.HI_TRANSLATE = AffineTransform.APPLY_TRANSLATE << AffineTransform.HI_SHIFT; return AffineTransform.HI_TRANSLATE; };
                ;
                AffineTransform.HI_SCALE_$LI$ = function () { if (AffineTransform.HI_SCALE == null)
                    AffineTransform.HI_SCALE = AffineTransform.APPLY_SCALE << AffineTransform.HI_SHIFT; return AffineTransform.HI_SCALE; };
                ;
                AffineTransform.HI_SHEAR_$LI$ = function () { if (AffineTransform.HI_SHEAR == null)
                    AffineTransform.HI_SHEAR = AffineTransform.APPLY_SHEAR << AffineTransform.HI_SHIFT; return AffineTransform.HI_SHEAR; };
                ;
                /**
                 * Returns a transform representing a translation transformation.
                 * The matrix representing the returned transform is:
                 * <pre>
                 * [   1    0    tx  ]
                 * [   0    1    ty  ]
                 * [   0    0    1   ]
                 * </pre>
                 * @param {number} tx the distance by which coordinates are translated in the
                 * X axis direction
                 * @param {number} ty the distance by which coordinates are translated in the
                 * Y axis direction
                 * @return {java.awt.geom.AffineTransform} an <code>AffineTransform</code> object that represents a
                 * translation transformation, created with the specified vector.
                 * @since 1.2
                 */
                AffineTransform.getTranslateInstance = function (tx, ty) {
                    var Tx = new AffineTransform();
                    Tx.setToTranslation(tx, ty);
                    return Tx;
                };
                AffineTransform.getRotateInstance$double = function (theta) {
                    var Tx = new AffineTransform();
                    Tx.setToRotation$double(theta);
                    return Tx;
                };
                AffineTransform.getRotateInstance$double$double$double = function (theta, anchorx, anchory) {
                    var Tx = new AffineTransform();
                    Tx.setToRotation$double$double$double(theta, anchorx, anchory);
                    return Tx;
                };
                AffineTransform.getRotateInstance$double$double = function (vecx, vecy) {
                    var Tx = new AffineTransform();
                    Tx.setToRotation$double$double(vecx, vecy);
                    return Tx;
                };
                AffineTransform.getRotateInstance$double$double$double$double = function (vecx, vecy, anchorx, anchory) {
                    var Tx = new AffineTransform();
                    Tx.setToRotation$double$double$double$double(vecx, vecy, anchorx, anchory);
                    return Tx;
                };
                /**
                 * Returns a transform that rotates coordinates around an anchor
                 * point according to a rotation vector.
                 * All coordinates rotate about the specified anchor coordinates
                 * by the same amount.
                 * The amount of rotation is such that coordinates along the former
                 * positive X axis will subsequently align with the vector pointing
                 * from the origin to the specified vector coordinates.
                 * If both <code>vecx</code> and <code>vecy</code> are 0.0,
                 * an identity transform is returned.
                 * This operation is equivalent to calling:
                 * <pre>
                 * AffineTransform.getRotateInstance(Math.atan2(vecy, vecx),
                 * anchorx, anchory);
                 * </pre>
                 *
                 * @param {number} vecx the X coordinate of the rotation vector
                 * @param {number} vecy the Y coordinate of the rotation vector
                 * @param {number} anchorx the X coordinate of the rotation anchor point
                 * @param {number} anchory the Y coordinate of the rotation anchor point
                 * @return {java.awt.geom.AffineTransform} an <code>AffineTransform</code> object that rotates
                 * coordinates around the specified point according to the
                 * specified rotation vector.
                 * @since 1.6
                 */
                AffineTransform.getRotateInstance = function (vecx, vecy, anchorx, anchory) {
                    if (((typeof vecx === 'number') || vecx === null) && ((typeof vecy === 'number') || vecy === null) && ((typeof anchorx === 'number') || anchorx === null) && ((typeof anchory === 'number') || anchory === null)) {
                        return java.awt.geom.AffineTransform.getRotateInstance$double$double$double$double(vecx, vecy, anchorx, anchory);
                    }
                    else if (((typeof vecx === 'number') || vecx === null) && ((typeof vecy === 'number') || vecy === null) && ((typeof anchorx === 'number') || anchorx === null) && anchory === undefined) {
                        return java.awt.geom.AffineTransform.getRotateInstance$double$double$double(vecx, vecy, anchorx);
                    }
                    else if (((typeof vecx === 'number') || vecx === null) && ((typeof vecy === 'number') || vecy === null) && anchorx === undefined && anchory === undefined) {
                        return java.awt.geom.AffineTransform.getRotateInstance$double$double(vecx, vecy);
                    }
                    else if (((typeof vecx === 'number') || vecx === null) && vecy === undefined && anchorx === undefined && anchory === undefined) {
                        return java.awt.geom.AffineTransform.getRotateInstance$double(vecx);
                    }
                    else
                        throw new Error('invalid overload');
                };
                AffineTransform.getQuadrantRotateInstance$int = function (numquadrants) {
                    var Tx = new AffineTransform();
                    Tx.setToQuadrantRotation$int(numquadrants);
                    return Tx;
                };
                AffineTransform.getQuadrantRotateInstance$int$double$double = function (numquadrants, anchorx, anchory) {
                    var Tx = new AffineTransform();
                    Tx.setToQuadrantRotation$int$double$double(numquadrants, anchorx, anchory);
                    return Tx;
                };
                /**
                 * Returns a transform that rotates coordinates by the specified
                 * number of quadrants around the specified anchor point.
                 * This operation is equivalent to calling:
                 * <pre>
                 * AffineTransform.getRotateInstance(numquadrants * Math.PI / 2.0,
                 * anchorx, anchory);
                 * </pre>
                 * Rotating by a positive number of quadrants rotates points on
                 * the positive X axis toward the positive Y axis.
                 *
                 * @param {number} numquadrants the number of 90 degree arcs to rotate by
                 * @param {number} anchorx the X coordinate of the rotation anchor point
                 * @param {number} anchory the Y coordinate of the rotation anchor point
                 * @return {java.awt.geom.AffineTransform} an <code>AffineTransform</code> object that rotates
                 * coordinates by the specified number of quadrants around the
                 * specified anchor point.
                 * @since 1.6
                 */
                AffineTransform.getQuadrantRotateInstance = function (numquadrants, anchorx, anchory) {
                    if (((typeof numquadrants === 'number') || numquadrants === null) && ((typeof anchorx === 'number') || anchorx === null) && ((typeof anchory === 'number') || anchory === null)) {
                        return java.awt.geom.AffineTransform.getQuadrantRotateInstance$int$double$double(numquadrants, anchorx, anchory);
                    }
                    else if (((typeof numquadrants === 'number') || numquadrants === null) && anchorx === undefined && anchory === undefined) {
                        return java.awt.geom.AffineTransform.getQuadrantRotateInstance$int(numquadrants);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns a transform representing a scaling transformation.
                 * The matrix representing the returned transform is:
                 * <pre>
                 * [   sx   0    0   ]
                 * [   0    sy   0   ]
                 * [   0    0    1   ]
                 * </pre>
                 * @param {number} sx the factor by which coordinates are scaled along the
                 * X axis direction
                 * @param {number} sy the factor by which coordinates are scaled along the
                 * Y axis direction
                 * @return {java.awt.geom.AffineTransform} an <code>AffineTransform</code> object that scales
                 * coordinates by the specified factors.
                 * @since 1.2
                 */
                AffineTransform.getScaleInstance = function (sx, sy) {
                    var Tx = new AffineTransform();
                    Tx.setToScale(sx, sy);
                    return Tx;
                };
                /**
                 * Returns a transform representing a shearing transformation.
                 * The matrix representing the returned transform is:
                 * <pre>
                 * [   1   shx   0   ]
                 * [  shy   1    0   ]
                 * [   0    0    1   ]
                 * </pre>
                 * @param {number} shx the multiplier by which coordinates are shifted in the
                 * direction of the positive X axis as a factor of their Y coordinate
                 * @param {number} shy the multiplier by which coordinates are shifted in the
                 * direction of the positive Y axis as a factor of their X coordinate
                 * @return {java.awt.geom.AffineTransform} an <code>AffineTransform</code> object that shears
                 * coordinates by the specified multipliers.
                 * @since 1.2
                 */
                AffineTransform.getShearInstance = function (shx, shy) {
                    var Tx = new AffineTransform();
                    Tx.setToShear(shx, shy);
                    return Tx;
                };
                /**
                 * Retrieves the flag bits describing the conversion properties of
                 * this transform.
                 * The return value is either one of the constants TYPE_IDENTITY
                 * or TYPE_GENERAL_TRANSFORM, or a combination of the
                 * appropriate flag bits.
                 * A valid combination of flag bits is an exclusive OR operation
                 * that can combine
                 * the TYPE_TRANSLATION flag bit
                 * in addition to either of the
                 * TYPE_UNIFORM_SCALE or TYPE_GENERAL_SCALE flag bits
                 * as well as either of the
                 * TYPE_QUADRANT_ROTATION or TYPE_GENERAL_ROTATION flag bits.
                 * @return {number} the OR combination of any of the indicated flags that
                 * apply to this transform
                 * @see #TYPE_IDENTITY
                 * @see #TYPE_TRANSLATION
                 * @see #TYPE_UNIFORM_SCALE
                 * @see #TYPE_GENERAL_SCALE
                 * @see #TYPE_QUADRANT_ROTATION
                 * @see #TYPE_GENERAL_ROTATION
                 * @see #TYPE_GENERAL_TRANSFORM
                 * @since 1.2
                 */
                AffineTransform.prototype.getType = function () {
                    if (this.type === AffineTransform.TYPE_UNKNOWN) {
                        this.calculateType();
                    }
                    return this.type;
                };
                /**
                 * This is the utility function to calculate the flag bits when
                 * they have not been cached.
                 * @see #getType
                 * @private
                 */
                /*private*/ AffineTransform.prototype.calculateType = function () {
                    var ret = AffineTransform.TYPE_IDENTITY;
                    var sgn0;
                    var sgn1;
                    var M0;
                    var M1;
                    var M2;
                    var M3;
                    this.updateState();
                    switch ((this.state)) {
                        default:
                            this.stateError();
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            ret = AffineTransform.TYPE_TRANSLATION;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            if ((M0 = this.m00) * (M2 = this.m01) + (M3 = this.m10) * (M1 = this.m11) !== 0) {
                                this.type = AffineTransform.TYPE_GENERAL_TRANSFORM;
                                return;
                            }
                            sgn0 = (M0 >= 0.0);
                            sgn1 = (M1 >= 0.0);
                            if (sgn0 === sgn1) {
                                if (M0 !== M1 || M2 !== -M3) {
                                    ret |= (AffineTransform.TYPE_GENERAL_ROTATION | AffineTransform.TYPE_GENERAL_SCALE);
                                }
                                else if (M0 * M1 - M2 * M3 !== 1.0) {
                                    ret |= (AffineTransform.TYPE_GENERAL_ROTATION | AffineTransform.TYPE_UNIFORM_SCALE);
                                }
                                else {
                                    ret |= AffineTransform.TYPE_GENERAL_ROTATION;
                                }
                            }
                            else {
                                if (M0 !== -M1 || M2 !== M3) {
                                    ret |= (AffineTransform.TYPE_GENERAL_ROTATION | AffineTransform.TYPE_FLIP | AffineTransform.TYPE_GENERAL_SCALE);
                                }
                                else if (M0 * M1 - M2 * M3 !== 1.0) {
                                    ret |= (AffineTransform.TYPE_GENERAL_ROTATION | AffineTransform.TYPE_FLIP | AffineTransform.TYPE_UNIFORM_SCALE);
                                }
                                else {
                                    ret |= (AffineTransform.TYPE_GENERAL_ROTATION | AffineTransform.TYPE_FLIP);
                                }
                            }
                            break;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                            ret = AffineTransform.TYPE_TRANSLATION;
                        case (AffineTransform.APPLY_SHEAR):
                            sgn0 = ((M0 = this.m01) >= 0.0);
                            sgn1 = ((M1 = this.m10) >= 0.0);
                            if (sgn0 !== sgn1) {
                                if (M0 !== -M1) {
                                    ret |= (AffineTransform.TYPE_QUADRANT_ROTATION | AffineTransform.TYPE_GENERAL_SCALE);
                                }
                                else if (M0 !== 1.0 && M0 !== -1.0) {
                                    ret |= (AffineTransform.TYPE_QUADRANT_ROTATION | AffineTransform.TYPE_UNIFORM_SCALE);
                                }
                                else {
                                    ret |= AffineTransform.TYPE_QUADRANT_ROTATION;
                                }
                            }
                            else {
                                if (M0 === M1) {
                                    ret |= (AffineTransform.TYPE_QUADRANT_ROTATION | AffineTransform.TYPE_FLIP | AffineTransform.TYPE_UNIFORM_SCALE);
                                }
                                else {
                                    ret |= (AffineTransform.TYPE_QUADRANT_ROTATION | AffineTransform.TYPE_FLIP | AffineTransform.TYPE_GENERAL_SCALE);
                                }
                            }
                            break;
                        case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            ret = AffineTransform.TYPE_TRANSLATION;
                        case (AffineTransform.APPLY_SCALE):
                            sgn0 = ((M0 = this.m00) >= 0.0);
                            sgn1 = ((M1 = this.m11) >= 0.0);
                            if (sgn0 === sgn1) {
                                if (sgn0) {
                                    if (M0 === M1) {
                                        ret |= AffineTransform.TYPE_UNIFORM_SCALE;
                                    }
                                    else {
                                        ret |= AffineTransform.TYPE_GENERAL_SCALE;
                                    }
                                }
                                else {
                                    if (M0 !== M1) {
                                        ret |= (AffineTransform.TYPE_QUADRANT_ROTATION | AffineTransform.TYPE_GENERAL_SCALE);
                                    }
                                    else if (M0 !== -1.0) {
                                        ret |= (AffineTransform.TYPE_QUADRANT_ROTATION | AffineTransform.TYPE_UNIFORM_SCALE);
                                    }
                                    else {
                                        ret |= AffineTransform.TYPE_QUADRANT_ROTATION;
                                    }
                                }
                            }
                            else {
                                if (M0 === -M1) {
                                    if (M0 === 1.0 || M0 === -1.0) {
                                        ret |= AffineTransform.TYPE_FLIP;
                                    }
                                    else {
                                        ret |= (AffineTransform.TYPE_FLIP | AffineTransform.TYPE_UNIFORM_SCALE);
                                    }
                                }
                                else {
                                    ret |= (AffineTransform.TYPE_FLIP | AffineTransform.TYPE_GENERAL_SCALE);
                                }
                            }
                            break;
                        case (AffineTransform.APPLY_TRANSLATE):
                            ret = AffineTransform.TYPE_TRANSLATION;
                            break;
                        case (AffineTransform.APPLY_IDENTITY):
                            break;
                    }
                    this.type = ret;
                };
                /**
                 * Returns the determinant of the matrix representation of the transform.
                 * The determinant is useful both to determine if the transform can
                 * be inverted and to get a single value representing the
                 * combined X and Y scaling of the transform.
                 * <p>
                 * If the determinant is non-zero, then this transform is
                 * invertible and the various methods that depend on the inverse
                 * transform do not need to throw a
                 * {@link NoninvertibleTransformException}.
                 * If the determinant is zero then this transform can not be
                 * inverted since the transform maps all input coordinates onto
                 * a line or a point.
                 * If the determinant is near enough to zero then inverse transform
                 * operations might not carry enough precision to produce meaningful
                 * results.
                 * <p>
                 * If this transform represents a uniform scale, as indicated by
                 * the <code>getType</code> method then the determinant also
                 * represents the square of the uniform scale factor by which all of
                 * the points are expanded from or contracted towards the origin.
                 * If this transform represents a non-uniform scale or more general
                 * transform then the determinant is not likely to represent a
                 * value useful for any purpose other than determining if inverse
                 * transforms are possible.
                 * <p>
                 * Mathematically, the determinant is calculated using the formula:
                 * <pre>
                 * |  m00  m01  m02  |
                 * |  m10  m11  m12  |  =  m00 * m11 - m01 * m10
                 * |   0    0    1   |
                 * </pre>
                 *
                 * @return {number} the determinant of the matrix used to transform the
                 * coordinates.
                 * @see #getType
                 * @see #createInverse
                 * @see #inverseTransform
                 * @see #TYPE_UNIFORM_SCALE
                 * @since 1.2
                 */
                AffineTransform.prototype.getDeterminant = function () {
                    switch ((this.state)) {
                        default:
                            this.stateError();
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            return this.m00 * this.m11 - this.m01 * this.m10;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_SHEAR):
                            return -(this.m01 * this.m10);
                        case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_SCALE):
                            return this.m00 * this.m11;
                        case (AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_IDENTITY):
                            return 1.0;
                    }
                };
                /**
                 * Manually recalculates the state of the transform when the matrix
                 * changes too much to predict the effects on the state.
                 * The following table specifies what the various settings of the
                 * state field say about the values of the corresponding matrix
                 * element fields.
                 * Note that the rules governing the SCALE fields are slightly
                 * different depending on whether the SHEAR flag is also set.
                 * <pre>
                 * SCALE            SHEAR          TRANSLATE
                 * m00/m11          m01/m10          m02/m12
                 *
                 * IDENTITY             1.0              0.0              0.0
                 * TRANSLATE (TR)       1.0              0.0          not both 0.0
                 * SCALE (SC)       not both 1.0         0.0              0.0
                 * TR | SC          not both 1.0         0.0          not both 0.0
                 * SHEAR (SH)           0.0          not both 0.0         0.0
                 * TR | SH              0.0          not both 0.0     not both 0.0
                 * SC | SH          not both 0.0     not both 0.0         0.0
                 * TR | SC | SH     not both 0.0     not both 0.0     not both 0.0
                 * </pre>
                 */
                AffineTransform.prototype.updateState = function () {
                    if (this.m01 === 0.0 && this.m10 === 0.0) {
                        if (this.m00 === 1.0 && this.m11 === 1.0) {
                            if (this.m02 === 0.0 && this.m12 === 0.0) {
                                this.state = AffineTransform.APPLY_IDENTITY;
                                this.type = AffineTransform.TYPE_IDENTITY;
                            }
                            else {
                                this.state = AffineTransform.APPLY_TRANSLATE;
                                this.type = AffineTransform.TYPE_TRANSLATION;
                            }
                        }
                        else {
                            if (this.m02 === 0.0 && this.m12 === 0.0) {
                                this.state = AffineTransform.APPLY_SCALE;
                                this.type = AffineTransform.TYPE_UNKNOWN;
                            }
                            else {
                                this.state = (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE);
                                this.type = AffineTransform.TYPE_UNKNOWN;
                            }
                        }
                    }
                    else {
                        if (this.m00 === 0.0 && this.m11 === 0.0) {
                            if (this.m02 === 0.0 && this.m12 === 0.0) {
                                this.state = AffineTransform.APPLY_SHEAR;
                                this.type = AffineTransform.TYPE_UNKNOWN;
                            }
                            else {
                                this.state = (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE);
                                this.type = AffineTransform.TYPE_UNKNOWN;
                            }
                        }
                        else {
                            if (this.m02 === 0.0 && this.m12 === 0.0) {
                                this.state = (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE);
                                this.type = AffineTransform.TYPE_UNKNOWN;
                            }
                            else {
                                this.state = (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE);
                                this.type = AffineTransform.TYPE_UNKNOWN;
                            }
                        }
                    }
                };
                /*private*/ AffineTransform.prototype.stateError = function () {
                    throw Object.defineProperty(new Error("missing case in transform state switch"), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.VirtualMachineError', 'java.lang.InternalError', 'java.lang.Error', 'java.lang.Object'] });
                };
                /**
                 * Retrieves the 6 specifiable values in the 3x3 affine transformation
                 * matrix and places them into an array of double precisions values.
                 * The values are stored in the array as
                 * {&nbsp;m00&nbsp;m10&nbsp;m01&nbsp;m11&nbsp;m02&nbsp;m12&nbsp;}.
                 * An array of 4 doubles can also be specified, in which case only the
                 * first four elements representing the non-transform
                 * parts of the array are retrieved and the values are stored into
                 * the array as {&nbsp;m00&nbsp;m10&nbsp;m01&nbsp;m11&nbsp;}
                 * @param {Array} flatmatrix the double array used to store the returned
                 * values.
                 * @see #getScaleX
                 * @see #getScaleY
                 * @see #getShearX
                 * @see #getShearY
                 * @see #getTranslateX
                 * @see #getTranslateY
                 * @since 1.2
                 */
                AffineTransform.prototype.getMatrix = function (flatmatrix) {
                    flatmatrix[0] = this.m00;
                    flatmatrix[1] = this.m10;
                    flatmatrix[2] = this.m01;
                    flatmatrix[3] = this.m11;
                    if (flatmatrix.length > 5) {
                        flatmatrix[4] = this.m02;
                        flatmatrix[5] = this.m12;
                    }
                };
                /**
                 * Returns the X coordinate scaling element (m00) of the 3x3
                 * affine transformation matrix.
                 * @return {number} a double value that is the X coordinate of the scaling
                 * element of the affine transformation matrix.
                 * @see #getMatrix
                 * @since 1.2
                 */
                AffineTransform.prototype.getScaleX = function () {
                    return this.m00;
                };
                /**
                 * Returns the Y coordinate scaling element (m11) of the 3x3
                 * affine transformation matrix.
                 * @return {number} a double value that is the Y coordinate of the scaling
                 * element of the affine transformation matrix.
                 * @see #getMatrix
                 * @since 1.2
                 */
                AffineTransform.prototype.getScaleY = function () {
                    return this.m11;
                };
                /**
                 * Returns the X coordinate shearing element (m01) of the 3x3
                 * affine transformation matrix.
                 * @return {number} a double value that is the X coordinate of the shearing
                 * element of the affine transformation matrix.
                 * @see #getMatrix
                 * @since 1.2
                 */
                AffineTransform.prototype.getShearX = function () {
                    return this.m01;
                };
                /**
                 * Returns the Y coordinate shearing element (m10) of the 3x3
                 * affine transformation matrix.
                 * @return {number} a double value that is the Y coordinate of the shearing
                 * element of the affine transformation matrix.
                 * @see #getMatrix
                 * @since 1.2
                 */
                AffineTransform.prototype.getShearY = function () {
                    return this.m10;
                };
                /**
                 * Returns the X coordinate of the translation element (m02) of the
                 * 3x3 affine transformation matrix.
                 * @return {number} a double value that is the X coordinate of the translation
                 * element of the affine transformation matrix.
                 * @see #getMatrix
                 * @since 1.2
                 */
                AffineTransform.prototype.getTranslateX = function () {
                    return this.m02;
                };
                /**
                 * Returns the Y coordinate of the translation element (m12) of the
                 * 3x3 affine transformation matrix.
                 * @return {number} a double value that is the Y coordinate of the translation
                 * element of the affine transformation matrix.
                 * @see #getMatrix
                 * @since 1.2
                 */
                AffineTransform.prototype.getTranslateY = function () {
                    return this.m12;
                };
                /**
                 * Concatenates this transform with a translation transformation.
                 * This is equivalent to calling concatenate(T), where T is an
                 * <code>AffineTransform</code> represented by the following matrix:
                 * <pre>
                 * [   1    0    tx  ]
                 * [   0    1    ty  ]
                 * [   0    0    1   ]
                 * </pre>
                 * @param {number} tx the distance by which coordinates are translated in the
                 * X axis direction
                 * @param {number} ty the distance by which coordinates are translated in the
                 * Y axis direction
                 * @since 1.2
                 */
                AffineTransform.prototype.translate = function (tx, ty) {
                    switch ((this.state)) {
                        default:
                            this.stateError();
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            this.m02 = tx * this.m00 + ty * this.m01 + this.m02;
                            this.m12 = tx * this.m10 + ty * this.m11 + this.m12;
                            if (this.m02 === 0.0 && this.m12 === 0.0) {
                                this.state = AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE;
                                if (this.type !== AffineTransform.TYPE_UNKNOWN) {
                                    this.type -= AffineTransform.TYPE_TRANSLATION;
                                }
                            }
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            this.m02 = tx * this.m00 + ty * this.m01;
                            this.m12 = tx * this.m10 + ty * this.m11;
                            if (this.m02 !== 0.0 || this.m12 !== 0.0) {
                                this.state = AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE;
                                this.type |= AffineTransform.TYPE_TRANSLATION;
                            }
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                            this.m02 = ty * this.m01 + this.m02;
                            this.m12 = tx * this.m10 + this.m12;
                            if (this.m02 === 0.0 && this.m12 === 0.0) {
                                this.state = AffineTransform.APPLY_SHEAR;
                                if (this.type !== AffineTransform.TYPE_UNKNOWN) {
                                    this.type -= AffineTransform.TYPE_TRANSLATION;
                                }
                            }
                            return;
                        case (AffineTransform.APPLY_SHEAR):
                            this.m02 = ty * this.m01;
                            this.m12 = tx * this.m10;
                            if (this.m02 !== 0.0 || this.m12 !== 0.0) {
                                this.state = AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE;
                                this.type |= AffineTransform.TYPE_TRANSLATION;
                            }
                            return;
                        case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            this.m02 = tx * this.m00 + this.m02;
                            this.m12 = ty * this.m11 + this.m12;
                            if (this.m02 === 0.0 && this.m12 === 0.0) {
                                this.state = AffineTransform.APPLY_SCALE;
                                if (this.type !== AffineTransform.TYPE_UNKNOWN) {
                                    this.type -= AffineTransform.TYPE_TRANSLATION;
                                }
                            }
                            return;
                        case (AffineTransform.APPLY_SCALE):
                            this.m02 = tx * this.m00;
                            this.m12 = ty * this.m11;
                            if (this.m02 !== 0.0 || this.m12 !== 0.0) {
                                this.state = AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE;
                                this.type |= AffineTransform.TYPE_TRANSLATION;
                            }
                            return;
                        case (AffineTransform.APPLY_TRANSLATE):
                            this.m02 = tx + this.m02;
                            this.m12 = ty + this.m12;
                            if (this.m02 === 0.0 && this.m12 === 0.0) {
                                this.state = AffineTransform.APPLY_IDENTITY;
                                this.type = AffineTransform.TYPE_IDENTITY;
                            }
                            return;
                        case (AffineTransform.APPLY_IDENTITY):
                            this.m02 = tx;
                            this.m12 = ty;
                            if (tx !== 0.0 || ty !== 0.0) {
                                this.state = AffineTransform.APPLY_TRANSLATE;
                                this.type = AffineTransform.TYPE_TRANSLATION;
                            }
                            return;
                    }
                };
                AffineTransform.rot90conversion_$LI$ = function () { if (AffineTransform.rot90conversion == null)
                    AffineTransform.rot90conversion = [AffineTransform.APPLY_SHEAR, AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE, AffineTransform.APPLY_SHEAR, AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE, AffineTransform.APPLY_SCALE, AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE, AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE, AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE]; return AffineTransform.rot90conversion; };
                ;
                /*private*/ AffineTransform.prototype.rotate90 = function () {
                    var M0 = this.m00;
                    this.m00 = this.m01;
                    this.m01 = -M0;
                    M0 = this.m10;
                    this.m10 = this.m11;
                    this.m11 = -M0;
                    var state = AffineTransform.rot90conversion_$LI$()[this.state];
                    if ((state & (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE)) === AffineTransform.APPLY_SCALE && this.m00 === 1.0 && this.m11 === 1.0) {
                        state -= AffineTransform.APPLY_SCALE;
                    }
                    this.state = state;
                    this.type = AffineTransform.TYPE_UNKNOWN;
                };
                /*private*/ AffineTransform.prototype.rotate180 = function () {
                    this.m00 = -this.m00;
                    this.m11 = -this.m11;
                    var state = this.state;
                    if ((state & (AffineTransform.APPLY_SHEAR)) !== 0) {
                        this.m01 = -this.m01;
                        this.m10 = -this.m10;
                    }
                    else {
                        if (this.m00 === 1.0 && this.m11 === 1.0) {
                            this.state = state & ~AffineTransform.APPLY_SCALE;
                        }
                        else {
                            this.state = state | AffineTransform.APPLY_SCALE;
                        }
                    }
                    this.type = AffineTransform.TYPE_UNKNOWN;
                };
                /*private*/ AffineTransform.prototype.rotate270 = function () {
                    var M0 = this.m00;
                    this.m00 = -this.m01;
                    this.m01 = M0;
                    M0 = this.m10;
                    this.m10 = -this.m11;
                    this.m11 = M0;
                    var state = AffineTransform.rot90conversion_$LI$()[this.state];
                    if ((state & (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE)) === AffineTransform.APPLY_SCALE && this.m00 === 1.0 && this.m11 === 1.0) {
                        state -= AffineTransform.APPLY_SCALE;
                    }
                    this.state = state;
                    this.type = AffineTransform.TYPE_UNKNOWN;
                };
                AffineTransform.prototype.rotate$double = function (theta) {
                    var sin = Math.sin(theta);
                    if (sin === 1.0) {
                        this.rotate90();
                    }
                    else if (sin === -1.0) {
                        this.rotate270();
                    }
                    else {
                        var cos = Math.cos(theta);
                        if (cos === -1.0) {
                            this.rotate180();
                        }
                        else if (cos !== 1.0) {
                            var M0 = void 0;
                            var M1 = void 0;
                            M0 = this.m00;
                            M1 = this.m01;
                            this.m00 = cos * M0 + sin * M1;
                            this.m01 = -sin * M0 + cos * M1;
                            M0 = this.m10;
                            M1 = this.m11;
                            this.m10 = cos * M0 + sin * M1;
                            this.m11 = -sin * M0 + cos * M1;
                            this.updateState();
                        }
                    }
                };
                AffineTransform.prototype.rotate$double$double$double = function (theta, anchorx, anchory) {
                    this.translate(anchorx, anchory);
                    this.rotate$double(theta);
                    this.translate(-anchorx, -anchory);
                };
                AffineTransform.prototype.rotate$double$double = function (vecx, vecy) {
                    if (vecy === 0.0) {
                        if (vecx < 0.0) {
                            this.rotate180();
                        }
                    }
                    else if (vecx === 0.0) {
                        if (vecy > 0.0) {
                            this.rotate90();
                        }
                        else {
                            this.rotate270();
                        }
                    }
                    else {
                        var len = Math.sqrt(vecx * vecx + vecy * vecy);
                        var sin = vecy / len;
                        var cos = vecx / len;
                        var M0 = void 0;
                        var M1 = void 0;
                        M0 = this.m00;
                        M1 = this.m01;
                        this.m00 = cos * M0 + sin * M1;
                        this.m01 = -sin * M0 + cos * M1;
                        M0 = this.m10;
                        M1 = this.m11;
                        this.m10 = cos * M0 + sin * M1;
                        this.m11 = -sin * M0 + cos * M1;
                        this.updateState();
                    }
                };
                AffineTransform.prototype.rotate$double$double$double$double = function (vecx, vecy, anchorx, anchory) {
                    this.translate(anchorx, anchory);
                    this.rotate$double$double(vecx, vecy);
                    this.translate(-anchorx, -anchory);
                };
                /**
                 * Concatenates this transform with a transform that rotates
                 * coordinates around an anchor point according to a rotation
                 * vector.
                 * All coordinates rotate about the specified anchor coordinates
                 * by the same amount.
                 * The amount of rotation is such that coordinates along the former
                 * positive X axis will subsequently align with the vector pointing
                 * from the origin to the specified vector coordinates.
                 * If both <code>vecx</code> and <code>vecy</code> are 0.0,
                 * the transform is not modified in any way.
                 * This method is equivalent to calling:
                 * <pre>
                 * rotate(Math.atan2(vecy, vecx), anchorx, anchory);
                 * </pre>
                 *
                 * @param {number} vecx the X coordinate of the rotation vector
                 * @param {number} vecy the Y coordinate of the rotation vector
                 * @param {number} anchorx the X coordinate of the rotation anchor point
                 * @param {number} anchory the Y coordinate of the rotation anchor point
                 * @since 1.6
                 */
                AffineTransform.prototype.rotate = function (vecx, vecy, anchorx, anchory) {
                    if (((typeof vecx === 'number') || vecx === null) && ((typeof vecy === 'number') || vecy === null) && ((typeof anchorx === 'number') || anchorx === null) && ((typeof anchory === 'number') || anchory === null)) {
                        return this.rotate$double$double$double$double(vecx, vecy, anchorx, anchory);
                    }
                    else if (((typeof vecx === 'number') || vecx === null) && ((typeof vecy === 'number') || vecy === null) && ((typeof anchorx === 'number') || anchorx === null) && anchory === undefined) {
                        return this.rotate$double$double$double(vecx, vecy, anchorx);
                    }
                    else if (((typeof vecx === 'number') || vecx === null) && ((typeof vecy === 'number') || vecy === null) && anchorx === undefined && anchory === undefined) {
                        return this.rotate$double$double(vecx, vecy);
                    }
                    else if (((typeof vecx === 'number') || vecx === null) && vecy === undefined && anchorx === undefined && anchory === undefined) {
                        return this.rotate$double(vecx);
                    }
                    else
                        throw new Error('invalid overload');
                };
                AffineTransform.prototype.quadrantRotate$int = function (numquadrants) {
                    switch ((numquadrants & 3)) {
                        case 0:
                            break;
                        case 1:
                            this.rotate90();
                            break;
                        case 2:
                            this.rotate180();
                            break;
                        case 3:
                            this.rotate270();
                            break;
                    }
                };
                AffineTransform.prototype.quadrantRotate$int$double$double = function (numquadrants, anchorx, anchory) {
                    switch ((numquadrants & 3)) {
                        case 0:
                            return;
                        case 1:
                            this.m02 += anchorx * (this.m00 - this.m01) + anchory * (this.m01 + this.m00);
                            this.m12 += anchorx * (this.m10 - this.m11) + anchory * (this.m11 + this.m10);
                            this.rotate90();
                            break;
                        case 2:
                            this.m02 += anchorx * (this.m00 + this.m00) + anchory * (this.m01 + this.m01);
                            this.m12 += anchorx * (this.m10 + this.m10) + anchory * (this.m11 + this.m11);
                            this.rotate180();
                            break;
                        case 3:
                            this.m02 += anchorx * (this.m00 + this.m01) + anchory * (this.m01 - this.m00);
                            this.m12 += anchorx * (this.m10 + this.m11) + anchory * (this.m11 - this.m10);
                            this.rotate270();
                            break;
                    }
                    if (this.m02 === 0.0 && this.m12 === 0.0) {
                        this.state &= ~AffineTransform.APPLY_TRANSLATE;
                    }
                    else {
                        this.state |= AffineTransform.APPLY_TRANSLATE;
                    }
                };
                /**
                 * Concatenates this transform with a transform that rotates
                 * coordinates by the specified number of quadrants around
                 * the specified anchor point.
                 * This method is equivalent to calling:
                 * <pre>
                 * rotate(numquadrants * Math.PI / 2.0, anchorx, anchory);
                 * </pre>
                 * Rotating by a positive number of quadrants rotates points on
                 * the positive X axis toward the positive Y axis.
                 *
                 * @param {number} numquadrants the number of 90 degree arcs to rotate by
                 * @param {number} anchorx the X coordinate of the rotation anchor point
                 * @param {number} anchory the Y coordinate of the rotation anchor point
                 * @since 1.6
                 */
                AffineTransform.prototype.quadrantRotate = function (numquadrants, anchorx, anchory) {
                    if (((typeof numquadrants === 'number') || numquadrants === null) && ((typeof anchorx === 'number') || anchorx === null) && ((typeof anchory === 'number') || anchory === null)) {
                        return this.quadrantRotate$int$double$double(numquadrants, anchorx, anchory);
                    }
                    else if (((typeof numquadrants === 'number') || numquadrants === null) && anchorx === undefined && anchory === undefined) {
                        return this.quadrantRotate$int(numquadrants);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Concatenates this transform with a scaling transformation.
                 * This is equivalent to calling concatenate(S), where S is an
                 * <code>AffineTransform</code> represented by the following matrix:
                 * <pre>
                 * [   sx   0    0   ]
                 * [   0    sy   0   ]
                 * [   0    0    1   ]
                 * </pre>
                 * @param {number} sx the factor by which coordinates are scaled along the
                 * X axis direction
                 * @param {number} sy the factor by which coordinates are scaled along the
                 * Y axis direction
                 * @since 1.2
                 */
                AffineTransform.prototype.scale = function (sx, sy) {
                    var state = this.state;
                    switch ((state)) {
                        default:
                            this.stateError();
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            this.m00 *= sx;
                            this.m11 *= sy;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_SHEAR):
                            this.m01 *= sy;
                            this.m10 *= sx;
                            if (this.m01 === 0 && this.m10 === 0) {
                                state &= AffineTransform.APPLY_TRANSLATE;
                                if (this.m00 === 1.0 && this.m11 === 1.0) {
                                    this.type = (state === AffineTransform.APPLY_IDENTITY ? AffineTransform.TYPE_IDENTITY : AffineTransform.TYPE_TRANSLATION);
                                }
                                else {
                                    state |= AffineTransform.APPLY_SCALE;
                                    this.type = AffineTransform.TYPE_UNKNOWN;
                                }
                                this.state = state;
                            }
                            return;
                        case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_SCALE):
                            this.m00 *= sx;
                            this.m11 *= sy;
                            if (this.m00 === 1.0 && this.m11 === 1.0) {
                                this.state = (state &= AffineTransform.APPLY_TRANSLATE);
                                this.type = (state === AffineTransform.APPLY_IDENTITY ? AffineTransform.TYPE_IDENTITY : AffineTransform.TYPE_TRANSLATION);
                            }
                            else {
                                this.type = AffineTransform.TYPE_UNKNOWN;
                            }
                            return;
                        case (AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_IDENTITY):
                            this.m00 = sx;
                            this.m11 = sy;
                            if (sx !== 1.0 || sy !== 1.0) {
                                this.state = state | AffineTransform.APPLY_SCALE;
                                this.type = AffineTransform.TYPE_UNKNOWN;
                            }
                            return;
                    }
                };
                /**
                 * Concatenates this transform with a shearing transformation.
                 * This is equivalent to calling concatenate(SH), where SH is an
                 * <code>AffineTransform</code> represented by the following matrix:
                 * <pre>
                 * [   1   shx   0   ]
                 * [  shy   1    0   ]
                 * [   0    0    1   ]
                 * </pre>
                 * @param {number} shx the multiplier by which coordinates are shifted in the
                 * direction of the positive X axis as a factor of their Y coordinate
                 * @param {number} shy the multiplier by which coordinates are shifted in the
                 * direction of the positive Y axis as a factor of their X coordinate
                 * @since 1.2
                 */
                AffineTransform.prototype.shear = function (shx, shy) {
                    var state = this.state;
                    switch ((state)) {
                        default:
                            this.stateError();
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            var M0 = void 0;
                            var M1 = void 0;
                            M0 = this.m00;
                            M1 = this.m01;
                            this.m00 = M0 + M1 * shy;
                            this.m01 = M0 * shx + M1;
                            M0 = this.m10;
                            M1 = this.m11;
                            this.m10 = M0 + M1 * shy;
                            this.m11 = M0 * shx + M1;
                            this.updateState();
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_SHEAR):
                            this.m00 = this.m01 * shy;
                            this.m11 = this.m10 * shx;
                            if (this.m00 !== 0.0 || this.m11 !== 0.0) {
                                this.state = state | AffineTransform.APPLY_SCALE;
                            }
                            this.type = AffineTransform.TYPE_UNKNOWN;
                            return;
                        case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_SCALE):
                            this.m01 = this.m00 * shx;
                            this.m10 = this.m11 * shy;
                            if (this.m01 !== 0.0 || this.m10 !== 0.0) {
                                this.state = state | AffineTransform.APPLY_SHEAR;
                            }
                            this.type = AffineTransform.TYPE_UNKNOWN;
                            return;
                        case (AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_IDENTITY):
                            this.m01 = shx;
                            this.m10 = shy;
                            if (this.m01 !== 0.0 || this.m10 !== 0.0) {
                                this.state = state | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_SHEAR;
                                this.type = AffineTransform.TYPE_UNKNOWN;
                            }
                            return;
                    }
                };
                /**
                 * Resets this transform to the Identity transform.
                 * @since 1.2
                 */
                AffineTransform.prototype.setToIdentity = function () {
                    this.m00 = this.m11 = 1.0;
                    this.m10 = this.m01 = this.m02 = this.m12 = 0.0;
                    this.state = AffineTransform.APPLY_IDENTITY;
                    this.type = AffineTransform.TYPE_IDENTITY;
                };
                /**
                 * Sets this transform to a translation transformation.
                 * The matrix representing this transform becomes:
                 * <pre>
                 * [   1    0    tx  ]
                 * [   0    1    ty  ]
                 * [   0    0    1   ]
                 * </pre>
                 * @param {number} tx the distance by which coordinates are translated in the
                 * X axis direction
                 * @param {number} ty the distance by which coordinates are translated in the
                 * Y axis direction
                 * @since 1.2
                 */
                AffineTransform.prototype.setToTranslation = function (tx, ty) {
                    this.m00 = 1.0;
                    this.m10 = 0.0;
                    this.m01 = 0.0;
                    this.m11 = 1.0;
                    this.m02 = tx;
                    this.m12 = ty;
                    if (tx !== 0.0 || ty !== 0.0) {
                        this.state = AffineTransform.APPLY_TRANSLATE;
                        this.type = AffineTransform.TYPE_TRANSLATION;
                    }
                    else {
                        this.state = AffineTransform.APPLY_IDENTITY;
                        this.type = AffineTransform.TYPE_IDENTITY;
                    }
                };
                AffineTransform.prototype.setToRotation$double = function (theta) {
                    var sin = Math.sin(theta);
                    var cos;
                    if (sin === 1.0 || sin === -1.0) {
                        cos = 0.0;
                        this.state = AffineTransform.APPLY_SHEAR;
                        this.type = AffineTransform.TYPE_QUADRANT_ROTATION;
                    }
                    else {
                        cos = Math.cos(theta);
                        if (cos === -1.0) {
                            sin = 0.0;
                            this.state = AffineTransform.APPLY_SCALE;
                            this.type = AffineTransform.TYPE_QUADRANT_ROTATION;
                        }
                        else if (cos === 1.0) {
                            sin = 0.0;
                            this.state = AffineTransform.APPLY_IDENTITY;
                            this.type = AffineTransform.TYPE_IDENTITY;
                        }
                        else {
                            this.state = AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE;
                            this.type = AffineTransform.TYPE_GENERAL_ROTATION;
                        }
                    }
                    this.m00 = cos;
                    this.m10 = sin;
                    this.m01 = -sin;
                    this.m11 = cos;
                    this.m02 = 0.0;
                    this.m12 = 0.0;
                };
                AffineTransform.prototype.setToRotation$double$double$double = function (theta, anchorx, anchory) {
                    this.setToRotation$double(theta);
                    var sin = this.m10;
                    var oneMinusCos = 1.0 - this.m00;
                    this.m02 = anchorx * oneMinusCos + anchory * sin;
                    this.m12 = anchory * oneMinusCos - anchorx * sin;
                    if (this.m02 !== 0.0 || this.m12 !== 0.0) {
                        this.state |= AffineTransform.APPLY_TRANSLATE;
                        this.type |= AffineTransform.TYPE_TRANSLATION;
                    }
                };
                AffineTransform.prototype.setToRotation$double$double = function (vecx, vecy) {
                    var sin;
                    var cos;
                    if (vecy === 0) {
                        sin = 0.0;
                        if (vecx < 0.0) {
                            cos = -1.0;
                            this.state = AffineTransform.APPLY_SCALE;
                            this.type = AffineTransform.TYPE_QUADRANT_ROTATION;
                        }
                        else {
                            cos = 1.0;
                            this.state = AffineTransform.APPLY_IDENTITY;
                            this.type = AffineTransform.TYPE_IDENTITY;
                        }
                    }
                    else if (vecx === 0) {
                        cos = 0.0;
                        sin = (vecy > 0.0) ? 1.0 : -1.0;
                        this.state = AffineTransform.APPLY_SHEAR;
                        this.type = AffineTransform.TYPE_QUADRANT_ROTATION;
                    }
                    else {
                        var len = Math.sqrt(vecx * vecx + vecy * vecy);
                        cos = vecx / len;
                        sin = vecy / len;
                        this.state = AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE;
                        this.type = AffineTransform.TYPE_GENERAL_ROTATION;
                    }
                    this.m00 = cos;
                    this.m10 = sin;
                    this.m01 = -sin;
                    this.m11 = cos;
                    this.m02 = 0.0;
                    this.m12 = 0.0;
                };
                AffineTransform.prototype.setToRotation$double$double$double$double = function (vecx, vecy, anchorx, anchory) {
                    this.setToRotation$double$double(vecx, vecy);
                    var sin = this.m10;
                    var oneMinusCos = 1.0 - this.m00;
                    this.m02 = anchorx * oneMinusCos + anchory * sin;
                    this.m12 = anchory * oneMinusCos - anchorx * sin;
                    if (this.m02 !== 0.0 || this.m12 !== 0.0) {
                        this.state |= AffineTransform.APPLY_TRANSLATE;
                        this.type |= AffineTransform.TYPE_TRANSLATION;
                    }
                };
                /**
                 * Sets this transform to a rotation transformation that rotates
                 * coordinates around an anchor point according to a rotation
                 * vector.
                 * All coordinates rotate about the specified anchor coordinates
                 * by the same amount.
                 * The amount of rotation is such that coordinates along the former
                 * positive X axis will subsequently align with the vector pointing
                 * from the origin to the specified vector coordinates.
                 * If both <code>vecx</code> and <code>vecy</code> are 0.0,
                 * the transform is set to an identity transform.
                 * This operation is equivalent to calling:
                 * <pre>
                 * setToTranslation(Math.atan2(vecy, vecx), anchorx, anchory);
                 * </pre>
                 *
                 * @param {number} vecx the X coordinate of the rotation vector
                 * @param {number} vecy the Y coordinate of the rotation vector
                 * @param {number} anchorx the X coordinate of the rotation anchor point
                 * @param {number} anchory the Y coordinate of the rotation anchor point
                 * @since 1.6
                 */
                AffineTransform.prototype.setToRotation = function (vecx, vecy, anchorx, anchory) {
                    if (((typeof vecx === 'number') || vecx === null) && ((typeof vecy === 'number') || vecy === null) && ((typeof anchorx === 'number') || anchorx === null) && ((typeof anchory === 'number') || anchory === null)) {
                        return this.setToRotation$double$double$double$double(vecx, vecy, anchorx, anchory);
                    }
                    else if (((typeof vecx === 'number') || vecx === null) && ((typeof vecy === 'number') || vecy === null) && ((typeof anchorx === 'number') || anchorx === null) && anchory === undefined) {
                        return this.setToRotation$double$double$double(vecx, vecy, anchorx);
                    }
                    else if (((typeof vecx === 'number') || vecx === null) && ((typeof vecy === 'number') || vecy === null) && anchorx === undefined && anchory === undefined) {
                        return this.setToRotation$double$double(vecx, vecy);
                    }
                    else if (((typeof vecx === 'number') || vecx === null) && vecy === undefined && anchorx === undefined && anchory === undefined) {
                        return this.setToRotation$double(vecx);
                    }
                    else
                        throw new Error('invalid overload');
                };
                AffineTransform.prototype.setToQuadrantRotation$int = function (numquadrants) {
                    switch ((numquadrants & 3)) {
                        case 0:
                            this.m00 = 1.0;
                            this.m10 = 0.0;
                            this.m01 = 0.0;
                            this.m11 = 1.0;
                            this.m02 = 0.0;
                            this.m12 = 0.0;
                            this.state = AffineTransform.APPLY_IDENTITY;
                            this.type = AffineTransform.TYPE_IDENTITY;
                            break;
                        case 1:
                            this.m00 = 0.0;
                            this.m10 = 1.0;
                            this.m01 = -1.0;
                            this.m11 = 0.0;
                            this.m02 = 0.0;
                            this.m12 = 0.0;
                            this.state = AffineTransform.APPLY_SHEAR;
                            this.type = AffineTransform.TYPE_QUADRANT_ROTATION;
                            break;
                        case 2:
                            this.m00 = -1.0;
                            this.m10 = 0.0;
                            this.m01 = 0.0;
                            this.m11 = -1.0;
                            this.m02 = 0.0;
                            this.m12 = 0.0;
                            this.state = AffineTransform.APPLY_SCALE;
                            this.type = AffineTransform.TYPE_QUADRANT_ROTATION;
                            break;
                        case 3:
                            this.m00 = 0.0;
                            this.m10 = -1.0;
                            this.m01 = 1.0;
                            this.m11 = 0.0;
                            this.m02 = 0.0;
                            this.m12 = 0.0;
                            this.state = AffineTransform.APPLY_SHEAR;
                            this.type = AffineTransform.TYPE_QUADRANT_ROTATION;
                            break;
                    }
                };
                AffineTransform.prototype.setToQuadrantRotation$int$double$double = function (numquadrants, anchorx, anchory) {
                    switch ((numquadrants & 3)) {
                        case 0:
                            this.m00 = 1.0;
                            this.m10 = 0.0;
                            this.m01 = 0.0;
                            this.m11 = 1.0;
                            this.m02 = 0.0;
                            this.m12 = 0.0;
                            this.state = AffineTransform.APPLY_IDENTITY;
                            this.type = AffineTransform.TYPE_IDENTITY;
                            break;
                        case 1:
                            this.m00 = 0.0;
                            this.m10 = 1.0;
                            this.m01 = -1.0;
                            this.m11 = 0.0;
                            this.m02 = anchorx + anchory;
                            this.m12 = anchory - anchorx;
                            if (this.m02 === 0.0 && this.m12 === 0.0) {
                                this.state = AffineTransform.APPLY_SHEAR;
                                this.type = AffineTransform.TYPE_QUADRANT_ROTATION;
                            }
                            else {
                                this.state = AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE;
                                this.type = AffineTransform.TYPE_QUADRANT_ROTATION | AffineTransform.TYPE_TRANSLATION;
                            }
                            break;
                        case 2:
                            this.m00 = -1.0;
                            this.m10 = 0.0;
                            this.m01 = 0.0;
                            this.m11 = -1.0;
                            this.m02 = anchorx + anchorx;
                            this.m12 = anchory + anchory;
                            if (this.m02 === 0.0 && this.m12 === 0.0) {
                                this.state = AffineTransform.APPLY_SCALE;
                                this.type = AffineTransform.TYPE_QUADRANT_ROTATION;
                            }
                            else {
                                this.state = AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE;
                                this.type = AffineTransform.TYPE_QUADRANT_ROTATION | AffineTransform.TYPE_TRANSLATION;
                            }
                            break;
                        case 3:
                            this.m00 = 0.0;
                            this.m10 = -1.0;
                            this.m01 = 1.0;
                            this.m11 = 0.0;
                            this.m02 = anchorx - anchory;
                            this.m12 = anchory + anchorx;
                            if (this.m02 === 0.0 && this.m12 === 0.0) {
                                this.state = AffineTransform.APPLY_SHEAR;
                                this.type = AffineTransform.TYPE_QUADRANT_ROTATION;
                            }
                            else {
                                this.state = AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE;
                                this.type = AffineTransform.TYPE_QUADRANT_ROTATION | AffineTransform.TYPE_TRANSLATION;
                            }
                            break;
                    }
                };
                /**
                 * Sets this transform to a translated rotation transformation
                 * that rotates coordinates by the specified number of quadrants
                 * around the specified anchor point.
                 * This operation is equivalent to calling:
                 * <pre>
                 * setToRotation(numquadrants * Math.PI / 2.0, anchorx, anchory);
                 * </pre>
                 * Rotating by a positive number of quadrants rotates points on
                 * the positive X axis toward the positive Y axis.
                 *
                 * @param {number} numquadrants the number of 90 degree arcs to rotate by
                 * @param {number} anchorx the X coordinate of the rotation anchor point
                 * @param {number} anchory the Y coordinate of the rotation anchor point
                 * @since 1.6
                 */
                AffineTransform.prototype.setToQuadrantRotation = function (numquadrants, anchorx, anchory) {
                    if (((typeof numquadrants === 'number') || numquadrants === null) && ((typeof anchorx === 'number') || anchorx === null) && ((typeof anchory === 'number') || anchory === null)) {
                        return this.setToQuadrantRotation$int$double$double(numquadrants, anchorx, anchory);
                    }
                    else if (((typeof numquadrants === 'number') || numquadrants === null) && anchorx === undefined && anchory === undefined) {
                        return this.setToQuadrantRotation$int(numquadrants);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Sets this transform to a scaling transformation.
                 * The matrix representing this transform becomes:
                 * <pre>
                 * [   sx   0    0   ]
                 * [   0    sy   0   ]
                 * [   0    0    1   ]
                 * </pre>
                 * @param {number} sx the factor by which coordinates are scaled along the
                 * X axis direction
                 * @param {number} sy the factor by which coordinates are scaled along the
                 * Y axis direction
                 * @since 1.2
                 */
                AffineTransform.prototype.setToScale = function (sx, sy) {
                    this.m00 = sx;
                    this.m10 = 0.0;
                    this.m01 = 0.0;
                    this.m11 = sy;
                    this.m02 = 0.0;
                    this.m12 = 0.0;
                    if (sx !== 1.0 || sy !== 1.0) {
                        this.state = AffineTransform.APPLY_SCALE;
                        this.type = AffineTransform.TYPE_UNKNOWN;
                    }
                    else {
                        this.state = AffineTransform.APPLY_IDENTITY;
                        this.type = AffineTransform.TYPE_IDENTITY;
                    }
                };
                /**
                 * Sets this transform to a shearing transformation.
                 * The matrix representing this transform becomes:
                 * <pre>
                 * [   1   shx   0   ]
                 * [  shy   1    0   ]
                 * [   0    0    1   ]
                 * </pre>
                 * @param {number} shx the multiplier by which coordinates are shifted in the
                 * direction of the positive X axis as a factor of their Y coordinate
                 * @param {number} shy the multiplier by which coordinates are shifted in the
                 * direction of the positive Y axis as a factor of their X coordinate
                 * @since 1.2
                 */
                AffineTransform.prototype.setToShear = function (shx, shy) {
                    this.m00 = 1.0;
                    this.m01 = shx;
                    this.m10 = shy;
                    this.m11 = 1.0;
                    this.m02 = 0.0;
                    this.m12 = 0.0;
                    if (shx !== 0.0 || shy !== 0.0) {
                        this.state = (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE);
                        this.type = AffineTransform.TYPE_UNKNOWN;
                    }
                    else {
                        this.state = AffineTransform.APPLY_IDENTITY;
                        this.type = AffineTransform.TYPE_IDENTITY;
                    }
                };
                AffineTransform.prototype.setTransform$java_awt_geom_AffineTransform = function (Tx) {
                    this.m00 = Tx.m00;
                    this.m10 = Tx.m10;
                    this.m01 = Tx.m01;
                    this.m11 = Tx.m11;
                    this.m02 = Tx.m02;
                    this.m12 = Tx.m12;
                    this.state = Tx.state;
                    this.type = Tx.type;
                };
                AffineTransform.prototype.setTransform$double$double$double$double$double$double = function (m00, m10, m01, m11, m02, m12) {
                    this.m00 = m00;
                    this.m10 = m10;
                    this.m01 = m01;
                    this.m11 = m11;
                    this.m02 = m02;
                    this.m12 = m12;
                    this.updateState();
                };
                /**
                 * Sets this transform to the matrix specified by the 6
                 * double precision values.
                 *
                 * @param {number} m00 the X coordinate scaling element of the 3x3 matrix
                 * @param {number} m10 the Y coordinate shearing element of the 3x3 matrix
                 * @param {number} m01 the X coordinate shearing element of the 3x3 matrix
                 * @param {number} m11 the Y coordinate scaling element of the 3x3 matrix
                 * @param {number} m02 the X coordinate translation element of the 3x3 matrix
                 * @param {number} m12 the Y coordinate translation element of the 3x3 matrix
                 * @since 1.2
                 */
                AffineTransform.prototype.setTransform = function (m00, m10, m01, m11, m02, m12) {
                    if (((typeof m00 === 'number') || m00 === null) && ((typeof m10 === 'number') || m10 === null) && ((typeof m01 === 'number') || m01 === null) && ((typeof m11 === 'number') || m11 === null) && ((typeof m02 === 'number') || m02 === null) && ((typeof m12 === 'number') || m12 === null)) {
                        return this.setTransform$double$double$double$double$double$double(m00, m10, m01, m11, m02, m12);
                    }
                    else if (((m00 != null && m00 instanceof java.awt.geom.AffineTransform) || m00 === null) && m10 === undefined && m01 === undefined && m11 === undefined && m02 === undefined && m12 === undefined) {
                        return this.setTransform$java_awt_geom_AffineTransform(m00);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Concatenates an <code>AffineTransform</code> <code>Tx</code> to
                 * this <code>AffineTransform</code> Cx in the most commonly useful
                 * way to provide a new user space
                 * that is mapped to the former user space by <code>Tx</code>.
                 * Cx is updated to perform the combined transformation.
                 * Transforming a point p by the updated transform Cx' is
                 * equivalent to first transforming p by <code>Tx</code> and then
                 * transforming the result by the original transform Cx like this:
                 * Cx'(p) = Cx(Tx(p))
                 * In matrix notation, if this transform Cx is
                 * represented by the matrix [this] and <code>Tx</code> is represented
                 * by the matrix [Tx] then this method does the following:
                 * <pre>
                 * [this] = [this] x [Tx]
                 * </pre>
                 * @param {java.awt.geom.AffineTransform} Tx the <code>AffineTransform</code> object to be
                 * concatenated with this <code>AffineTransform</code> object.
                 * @see #preConcatenate
                 * @since 1.2
                 */
                AffineTransform.prototype.concatenate = function (Tx) {
                    var M0;
                    var M1;
                    var T00;
                    var T01;
                    var T10;
                    var T11;
                    var T02;
                    var T12;
                    var mystate = this.state;
                    var txstate = Tx.state;
                    switch (((txstate << AffineTransform.HI_SHIFT) | mystate)) {
                        case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_IDENTITY):
                        case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_SCALE):
                        case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_SHEAR):
                        case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                        case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            return;
                        case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.HI_SCALE_$LI$() | AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_IDENTITY):
                            this.m01 = Tx.m01;
                            this.m10 = Tx.m10;
                        case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_IDENTITY):
                            this.m00 = Tx.m00;
                            this.m11 = Tx.m11;
                        case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_IDENTITY):
                            this.m02 = Tx.m02;
                            this.m12 = Tx.m12;
                            this.state = txstate;
                            this.type = Tx.type;
                            return;
                        case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_IDENTITY):
                            this.m01 = Tx.m01;
                            this.m10 = Tx.m10;
                        case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_IDENTITY):
                            this.m00 = Tx.m00;
                            this.m11 = Tx.m11;
                            this.state = txstate;
                            this.type = Tx.type;
                            return;
                        case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_IDENTITY):
                            this.m02 = Tx.m02;
                            this.m12 = Tx.m12;
                        case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_IDENTITY):
                            this.m01 = Tx.m01;
                            this.m10 = Tx.m10;
                            this.m00 = this.m11 = 0.0;
                            this.state = txstate;
                            this.type = Tx.type;
                            return;
                        case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                        case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_SHEAR):
                        case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_SCALE):
                        case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_TRANSLATE):
                            this.translate(Tx.m02, Tx.m12);
                            return;
                        case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                        case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_SHEAR):
                        case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_SCALE):
                        case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_TRANSLATE):
                            this.scale(Tx.m00, Tx.m11);
                            return;
                        case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            T01 = Tx.m01;
                            T10 = Tx.m10;
                            M0 = this.m00;
                            this.m00 = this.m01 * T10;
                            this.m01 = M0 * T01;
                            M0 = this.m10;
                            this.m10 = this.m11 * T10;
                            this.m11 = M0 * T01;
                            this.type = AffineTransform.TYPE_UNKNOWN;
                            return;
                        case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_SHEAR):
                            this.m00 = this.m01 * Tx.m10;
                            this.m01 = 0.0;
                            this.m11 = this.m10 * Tx.m01;
                            this.m10 = 0.0;
                            this.state = mystate ^ (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE);
                            this.type = AffineTransform.TYPE_UNKNOWN;
                            return;
                        case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_SCALE):
                            this.m01 = this.m00 * Tx.m01;
                            this.m00 = 0.0;
                            this.m10 = this.m11 * Tx.m10;
                            this.m11 = 0.0;
                            this.state = mystate ^ (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE);
                            this.type = AffineTransform.TYPE_UNKNOWN;
                            return;
                        case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_TRANSLATE):
                            this.m00 = 0.0;
                            this.m01 = Tx.m01;
                            this.m10 = Tx.m10;
                            this.m11 = 0.0;
                            this.state = AffineTransform.APPLY_TRANSLATE | AffineTransform.APPLY_SHEAR;
                            this.type = AffineTransform.TYPE_UNKNOWN;
                            return;
                    }
                    T00 = Tx.m00;
                    T01 = Tx.m01;
                    T02 = Tx.m02;
                    T10 = Tx.m10;
                    T11 = Tx.m11;
                    T12 = Tx.m12;
                    switch ((mystate)) {
                        default:
                            this.stateError();
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            this.state = mystate | txstate;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            M0 = this.m00;
                            M1 = this.m01;
                            this.m00 = T00 * M0 + T10 * M1;
                            this.m01 = T01 * M0 + T11 * M1;
                            this.m02 += T02 * M0 + T12 * M1;
                            M0 = this.m10;
                            M1 = this.m11;
                            this.m10 = T00 * M0 + T10 * M1;
                            this.m11 = T01 * M0 + T11 * M1;
                            this.m12 += T02 * M0 + T12 * M1;
                            this.type = AffineTransform.TYPE_UNKNOWN;
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_SHEAR):
                            M0 = this.m01;
                            this.m00 = T10 * M0;
                            this.m01 = T11 * M0;
                            this.m02 += T12 * M0;
                            M0 = this.m10;
                            this.m10 = T00 * M0;
                            this.m11 = T01 * M0;
                            this.m12 += T02 * M0;
                            break;
                        case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_SCALE):
                            M0 = this.m00;
                            this.m00 = T00 * M0;
                            this.m01 = T01 * M0;
                            this.m02 += T02 * M0;
                            M0 = this.m11;
                            this.m10 = T10 * M0;
                            this.m11 = T11 * M0;
                            this.m12 += T12 * M0;
                            break;
                        case (AffineTransform.APPLY_TRANSLATE):
                            this.m00 = T00;
                            this.m01 = T01;
                            this.m02 += T02;
                            this.m10 = T10;
                            this.m11 = T11;
                            this.m12 += T12;
                            this.state = txstate | AffineTransform.APPLY_TRANSLATE;
                            this.type = AffineTransform.TYPE_UNKNOWN;
                            return;
                    }
                    this.updateState();
                };
                /**
                 * Concatenates an <code>AffineTransform</code> <code>Tx</code> to
                 * this <code>AffineTransform</code> Cx
                 * in a less commonly used way such that <code>Tx</code> modifies the
                 * coordinate transformation relative to the absolute pixel
                 * space rather than relative to the existing user space.
                 * Cx is updated to perform the combined transformation.
                 * Transforming a point p by the updated transform Cx' is
                 * equivalent to first transforming p by the original transform
                 * Cx and then transforming the result by
                 * <code>Tx</code> like this:
                 * Cx'(p) = Tx(Cx(p))
                 * In matrix notation, if this transform Cx
                 * is represented by the matrix [this] and <code>Tx</code> is
                 * represented by the matrix [Tx] then this method does the
                 * following:
                 * <pre>
                 * [this] = [Tx] x [this]
                 * </pre>
                 * @param {java.awt.geom.AffineTransform} Tx the <code>AffineTransform</code> object to be
                 * concatenated with this <code>AffineTransform</code> object.
                 * @see #concatenate
                 * @since 1.2
                 */
                AffineTransform.prototype.preConcatenate = function (Tx) {
                    var M0;
                    var M1;
                    var T00;
                    var T01;
                    var T10;
                    var T11;
                    var T02;
                    var T12;
                    var mystate = this.state;
                    var txstate = Tx.state;
                    switch (((txstate << AffineTransform.HI_SHIFT) | mystate)) {
                        case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_IDENTITY):
                        case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_SCALE):
                        case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_SHEAR):
                        case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                        case (AffineTransform.HI_IDENTITY_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            return;
                        case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_IDENTITY):
                        case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_SCALE):
                        case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_SHEAR):
                        case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            this.m02 = Tx.m02;
                            this.m12 = Tx.m12;
                            this.state = mystate | AffineTransform.APPLY_TRANSLATE;
                            this.type |= AffineTransform.TYPE_TRANSLATION;
                            return;
                        case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_TRANSLATE_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            this.m02 = this.m02 + Tx.m02;
                            this.m12 = this.m12 + Tx.m12;
                            return;
                        case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_IDENTITY):
                            this.state = mystate | AffineTransform.APPLY_SCALE;
                        case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                        case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_SHEAR):
                        case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_SCALE_$LI$() | AffineTransform.APPLY_SCALE):
                            T00 = Tx.m00;
                            T11 = Tx.m11;
                            if ((mystate & AffineTransform.APPLY_SHEAR) !== 0) {
                                this.m01 = this.m01 * T00;
                                this.m10 = this.m10 * T11;
                                if ((mystate & AffineTransform.APPLY_SCALE) !== 0) {
                                    this.m00 = this.m00 * T00;
                                    this.m11 = this.m11 * T11;
                                }
                            }
                            else {
                                this.m00 = this.m00 * T00;
                                this.m11 = this.m11 * T11;
                            }
                            if ((mystate & AffineTransform.APPLY_TRANSLATE) !== 0) {
                                this.m02 = this.m02 * T00;
                                this.m12 = this.m12 * T11;
                            }
                            this.type = AffineTransform.TYPE_UNKNOWN;
                            return;
                        case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_SHEAR):
                            mystate = mystate | AffineTransform.APPLY_SCALE;
                        case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_IDENTITY):
                        case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_SCALE):
                            this.state = mystate ^ AffineTransform.APPLY_SHEAR;
                        case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.HI_SHEAR_$LI$() | AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            T01 = Tx.m01;
                            T10 = Tx.m10;
                            M0 = this.m00;
                            this.m00 = this.m10 * T01;
                            this.m10 = M0 * T10;
                            M0 = this.m01;
                            this.m01 = this.m11 * T01;
                            this.m11 = M0 * T10;
                            M0 = this.m02;
                            this.m02 = this.m12 * T01;
                            this.m12 = M0 * T10;
                            this.type = AffineTransform.TYPE_UNKNOWN;
                            return;
                    }
                    T00 = Tx.m00;
                    T01 = Tx.m01;
                    T02 = Tx.m02;
                    T10 = Tx.m10;
                    T11 = Tx.m11;
                    T12 = Tx.m12;
                    switch ((mystate)) {
                        default:
                            this.stateError();
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            M0 = this.m02;
                            M1 = this.m12;
                            T02 += M0 * T00 + M1 * T01;
                            T12 += M0 * T10 + M1 * T11;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            this.m02 = T02;
                            this.m12 = T12;
                            M0 = this.m00;
                            M1 = this.m10;
                            this.m00 = M0 * T00 + M1 * T01;
                            this.m10 = M0 * T10 + M1 * T11;
                            M0 = this.m01;
                            M1 = this.m11;
                            this.m01 = M0 * T00 + M1 * T01;
                            this.m11 = M0 * T10 + M1 * T11;
                            break;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                            M0 = this.m02;
                            M1 = this.m12;
                            T02 += M0 * T00 + M1 * T01;
                            T12 += M0 * T10 + M1 * T11;
                        case (AffineTransform.APPLY_SHEAR):
                            this.m02 = T02;
                            this.m12 = T12;
                            M0 = this.m10;
                            this.m00 = M0 * T01;
                            this.m10 = M0 * T11;
                            M0 = this.m01;
                            this.m01 = M0 * T00;
                            this.m11 = M0 * T10;
                            break;
                        case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            M0 = this.m02;
                            M1 = this.m12;
                            T02 += M0 * T00 + M1 * T01;
                            T12 += M0 * T10 + M1 * T11;
                        case (AffineTransform.APPLY_SCALE):
                            this.m02 = T02;
                            this.m12 = T12;
                            M0 = this.m00;
                            this.m00 = M0 * T00;
                            this.m10 = M0 * T10;
                            M0 = this.m11;
                            this.m01 = M0 * T01;
                            this.m11 = M0 * T11;
                            break;
                        case (AffineTransform.APPLY_TRANSLATE):
                            M0 = this.m02;
                            M1 = this.m12;
                            T02 += M0 * T00 + M1 * T01;
                            T12 += M0 * T10 + M1 * T11;
                        case (AffineTransform.APPLY_IDENTITY):
                            this.m02 = T02;
                            this.m12 = T12;
                            this.m00 = T00;
                            this.m10 = T10;
                            this.m01 = T01;
                            this.m11 = T11;
                            this.state = mystate | txstate;
                            this.type = AffineTransform.TYPE_UNKNOWN;
                            return;
                    }
                    this.updateState();
                };
                /**
                 * Returns an <code>AffineTransform</code> object representing the
                 * inverse transformation.
                 * The inverse transform Tx' of this transform Tx
                 * maps coordinates transformed by Tx back
                 * to their original coordinates.
                 * In other words, Tx'(Tx(p)) = p = Tx(Tx'(p)).
                 * <p>
                 * If this transform maps all coordinates onto a point or a line
                 * then it will not have an inverse, since coordinates that do
                 * not lie on the destination point or line will not have an inverse
                 * mapping.
                 * The <code>getDeterminant</code> method can be used to determine if this
                 * transform has no inverse, in which case an exception will be
                 * thrown if the <code>createInverse</code> method is called.
                 * @return {java.awt.geom.AffineTransform} a new <code>AffineTransform</code> object representing the
                 * inverse transformation.
                 * @see #getDeterminant
                 * @exception NoninvertibleTransformException
                 * if the matrix cannot be inverted.
                 * @since 1.2
                 */
                AffineTransform.prototype.createInverse = function () {
                    var det;
                    switch ((this.state)) {
                        default:
                            this.stateError();
                            return null;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            det = this.m00 * this.m11 - this.m01 * this.m10;
                            if (Math.abs(det) <= 4.9E-324) {
                                throw Object.defineProperty(new Error("Determinant is " + det), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.awt.geom.NoninvertibleTransformException', 'java.lang.Object', 'java.lang.Exception'] });
                            }
                            return new AffineTransform(this.m11 / det, -this.m10 / det, -this.m01 / det, this.m00 / det, (this.m01 * this.m12 - this.m11 * this.m02) / det, (this.m10 * this.m02 - this.m00 * this.m12) / det, (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE));
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            det = this.m00 * this.m11 - this.m01 * this.m10;
                            if (Math.abs(det) <= 4.9E-324) {
                                throw Object.defineProperty(new Error("Determinant is " + det), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.awt.geom.NoninvertibleTransformException', 'java.lang.Object', 'java.lang.Exception'] });
                            }
                            return new AffineTransform(this.m11 / det, -this.m10 / det, -this.m01 / det, this.m00 / det, 0.0, 0.0, (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE));
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                            if (this.m01 === 0.0 || this.m10 === 0.0) {
                                throw Object.defineProperty(new Error("Determinant is 0"), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.awt.geom.NoninvertibleTransformException', 'java.lang.Object', 'java.lang.Exception'] });
                            }
                            return new AffineTransform(0.0, 1.0 / this.m01, 1.0 / this.m10, 0.0, -this.m12 / this.m10, -this.m02 / this.m01, (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE));
                        case (AffineTransform.APPLY_SHEAR):
                            if (this.m01 === 0.0 || this.m10 === 0.0) {
                                throw Object.defineProperty(new Error("Determinant is 0"), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.awt.geom.NoninvertibleTransformException', 'java.lang.Object', 'java.lang.Exception'] });
                            }
                            return new AffineTransform(0.0, 1.0 / this.m01, 1.0 / this.m10, 0.0, 0.0, 0.0, (AffineTransform.APPLY_SHEAR));
                        case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            if (this.m00 === 0.0 || this.m11 === 0.0) {
                                throw Object.defineProperty(new Error("Determinant is 0"), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.awt.geom.NoninvertibleTransformException', 'java.lang.Object', 'java.lang.Exception'] });
                            }
                            return new AffineTransform(1.0 / this.m00, 0.0, 0.0, 1.0 / this.m11, -this.m02 / this.m00, -this.m12 / this.m11, (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE));
                        case (AffineTransform.APPLY_SCALE):
                            if (this.m00 === 0.0 || this.m11 === 0.0) {
                                throw Object.defineProperty(new Error("Determinant is 0"), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.awt.geom.NoninvertibleTransformException', 'java.lang.Object', 'java.lang.Exception'] });
                            }
                            return new AffineTransform(1.0 / this.m00, 0.0, 0.0, 1.0 / this.m11, 0.0, 0.0, (AffineTransform.APPLY_SCALE));
                        case (AffineTransform.APPLY_TRANSLATE):
                            return new AffineTransform(1.0, 0.0, 0.0, 1.0, -this.m02, -this.m12, (AffineTransform.APPLY_TRANSLATE));
                        case (AffineTransform.APPLY_IDENTITY):
                            return new AffineTransform();
                    }
                };
                /**
                 * Sets this transform to the inverse of itself.
                 * The inverse transform Tx' of this transform Tx
                 * maps coordinates transformed by Tx back
                 * to their original coordinates.
                 * In other words, Tx'(Tx(p)) = p = Tx(Tx'(p)).
                 * <p>
                 * If this transform maps all coordinates onto a point or a line
                 * then it will not have an inverse, since coordinates that do
                 * not lie on the destination point or line will not have an inverse
                 * mapping.
                 * The <code>getDeterminant</code> method can be used to determine if this
                 * transform has no inverse, in which case an exception will be
                 * thrown if the <code>invert</code> method is called.
                 * @see #getDeterminant
                 * @exception NoninvertibleTransformException
                 * if the matrix cannot be inverted.
                 * @since 1.6
                 */
                AffineTransform.prototype.invert = function () {
                    var M00;
                    var M01;
                    var M02;
                    var M10;
                    var M11;
                    var M12;
                    var det;
                    switch ((this.state)) {
                        default:
                            this.stateError();
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            M00 = this.m00;
                            M01 = this.m01;
                            M02 = this.m02;
                            M10 = this.m10;
                            M11 = this.m11;
                            M12 = this.m12;
                            det = M00 * M11 - M01 * M10;
                            if (Math.abs(det) <= 4.9E-324) {
                                throw Object.defineProperty(new Error("Determinant is " + det), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.awt.geom.NoninvertibleTransformException', 'java.lang.Object', 'java.lang.Exception'] });
                            }
                            this.m00 = M11 / det;
                            this.m10 = -M10 / det;
                            this.m01 = -M01 / det;
                            this.m11 = M00 / det;
                            this.m02 = (M01 * M12 - M11 * M02) / det;
                            this.m12 = (M10 * M02 - M00 * M12) / det;
                            break;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            M00 = this.m00;
                            M01 = this.m01;
                            M10 = this.m10;
                            M11 = this.m11;
                            det = M00 * M11 - M01 * M10;
                            if (Math.abs(det) <= 4.9E-324) {
                                throw Object.defineProperty(new Error("Determinant is " + det), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.awt.geom.NoninvertibleTransformException', 'java.lang.Object', 'java.lang.Exception'] });
                            }
                            this.m00 = M11 / det;
                            this.m10 = -M10 / det;
                            this.m01 = -M01 / det;
                            this.m11 = M00 / det;
                            break;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                            M01 = this.m01;
                            M02 = this.m02;
                            M10 = this.m10;
                            M12 = this.m12;
                            if (M01 === 0.0 || M10 === 0.0) {
                                throw Object.defineProperty(new Error("Determinant is 0"), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.awt.geom.NoninvertibleTransformException', 'java.lang.Object', 'java.lang.Exception'] });
                            }
                            this.m10 = 1.0 / M01;
                            this.m01 = 1.0 / M10;
                            this.m02 = -M12 / M10;
                            this.m12 = -M02 / M01;
                            break;
                        case (AffineTransform.APPLY_SHEAR):
                            M01 = this.m01;
                            M10 = this.m10;
                            if (M01 === 0.0 || M10 === 0.0) {
                                throw Object.defineProperty(new Error("Determinant is 0"), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.awt.geom.NoninvertibleTransformException', 'java.lang.Object', 'java.lang.Exception'] });
                            }
                            this.m10 = 1.0 / M01;
                            this.m01 = 1.0 / M10;
                            break;
                        case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            M00 = this.m00;
                            M02 = this.m02;
                            M11 = this.m11;
                            M12 = this.m12;
                            if (M00 === 0.0 || M11 === 0.0) {
                                throw Object.defineProperty(new Error("Determinant is 0"), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.awt.geom.NoninvertibleTransformException', 'java.lang.Object', 'java.lang.Exception'] });
                            }
                            this.m00 = 1.0 / M00;
                            this.m11 = 1.0 / M11;
                            this.m02 = -M02 / M00;
                            this.m12 = -M12 / M11;
                            break;
                        case (AffineTransform.APPLY_SCALE):
                            M00 = this.m00;
                            M11 = this.m11;
                            if (M00 === 0.0 || M11 === 0.0) {
                                throw Object.defineProperty(new Error("Determinant is 0"), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.awt.geom.NoninvertibleTransformException', 'java.lang.Object', 'java.lang.Exception'] });
                            }
                            this.m00 = 1.0 / M00;
                            this.m11 = 1.0 / M11;
                            break;
                        case (AffineTransform.APPLY_TRANSLATE):
                            this.m02 = -this.m02;
                            this.m12 = -this.m12;
                            break;
                        case (AffineTransform.APPLY_IDENTITY):
                            break;
                    }
                };
                AffineTransform.prototype.transform$java_awt_geom_Point2D$java_awt_geom_Point2D = function (ptSrc, ptDst) {
                    if (ptDst == null) {
                        if (ptSrc != null && ptSrc instanceof java.awt.geom.Point2D.Double) {
                            ptDst = new java.awt.geom.Point2D.Double();
                        }
                        else {
                            ptDst = new java.awt.geom.Point2D.Float();
                        }
                    }
                    var x = ptSrc.getX();
                    var y = ptSrc.getY();
                    switch ((this.state)) {
                        default:
                            this.stateError();
                            return null;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            ptDst.setLocation$double$double(x * this.m00 + y * this.m01 + this.m02, x * this.m10 + y * this.m11 + this.m12);
                            return ptDst;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            ptDst.setLocation$double$double(x * this.m00 + y * this.m01, x * this.m10 + y * this.m11);
                            return ptDst;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                            ptDst.setLocation$double$double(y * this.m01 + this.m02, x * this.m10 + this.m12);
                            return ptDst;
                        case (AffineTransform.APPLY_SHEAR):
                            ptDst.setLocation$double$double(y * this.m01, x * this.m10);
                            return ptDst;
                        case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            ptDst.setLocation$double$double(x * this.m00 + this.m02, y * this.m11 + this.m12);
                            return ptDst;
                        case (AffineTransform.APPLY_SCALE):
                            ptDst.setLocation$double$double(x * this.m00, y * this.m11);
                            return ptDst;
                        case (AffineTransform.APPLY_TRANSLATE):
                            ptDst.setLocation$double$double(x + this.m02, y + this.m12);
                            return ptDst;
                        case (AffineTransform.APPLY_IDENTITY):
                            ptDst.setLocation$double$double(x, y);
                            return ptDst;
                    }
                };
                AffineTransform.prototype.transform$java_awt_geom_Point2D_A$int$java_awt_geom_Point2D_A$int$int = function (ptSrc, srcOff, ptDst, dstOff, numPts) {
                    var state = this.state;
                    while ((--numPts >= 0)) {
                        {
                            var src = ptSrc[srcOff++];
                            var x = src.getX();
                            var y = src.getY();
                            var dst = ptDst[dstOff++];
                            if (dst == null) {
                                if (src != null && src instanceof java.awt.geom.Point2D.Double) {
                                    dst = new java.awt.geom.Point2D.Double();
                                }
                                else {
                                    dst = new java.awt.geom.Point2D.Float();
                                }
                                ptDst[dstOff - 1] = dst;
                            }
                            switch ((state)) {
                                default:
                                    this.stateError();
                                    return;
                                case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                                    dst.setLocation$double$double(x * this.m00 + y * this.m01 + this.m02, x * this.m10 + y * this.m11 + this.m12);
                                    break;
                                case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                                    dst.setLocation$double$double(x * this.m00 + y * this.m01, x * this.m10 + y * this.m11);
                                    break;
                                case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                                    dst.setLocation$double$double(y * this.m01 + this.m02, x * this.m10 + this.m12);
                                    break;
                                case (AffineTransform.APPLY_SHEAR):
                                    dst.setLocation$double$double(y * this.m01, x * this.m10);
                                    break;
                                case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                                    dst.setLocation$double$double(x * this.m00 + this.m02, y * this.m11 + this.m12);
                                    break;
                                case (AffineTransform.APPLY_SCALE):
                                    dst.setLocation$double$double(x * this.m00, y * this.m11);
                                    break;
                                case (AffineTransform.APPLY_TRANSLATE):
                                    dst.setLocation$double$double(x + this.m02, y + this.m12);
                                    break;
                                case (AffineTransform.APPLY_IDENTITY):
                                    dst.setLocation$double$double(x, y);
                                    break;
                            }
                        }
                    }
                    ;
                };
                /**
                 * Transforms an array of point objects by this transform.
                 * If any element of the <code>ptDst</code> array is
                 * <code>null</code>, a new <code>Point2D</code> object is allocated
                 * and stored into that element before storing the results of the
                 * transformation.
                 * <p>
                 * Note that this method does not take any precautions to
                 * avoid problems caused by storing results into <code>Point2D</code>
                 * objects that will be used as the source for calculations
                 * further down the source array.
                 * This method does guarantee that if a specified <code>Point2D</code>
                 * object is both the source and destination for the same single point
                 * transform operation then the results will not be stored until
                 * the calculations are complete to avoid storing the results on
                 * top of the operands.
                 * If, however, the destination <code>Point2D</code> object for one
                 * operation is the same object as the source <code>Point2D</code>
                 * object for another operation further down the source array then
                 * the original coordinates in that point are overwritten before
                 * they can be converted.
                 * @param {Array} ptSrc the array containing the source point objects
                 * @param {Array} ptDst the array into which the transform point objects are
                 * returned
                 * @param {number} srcOff the offset to the first point object to be
                 * transformed in the source array
                 * @param {number} dstOff the offset to the location of the first
                 * transformed point object that is stored in the destination array
                 * @param {number} numPts the number of point objects to be transformed
                 * @since 1.2
                 */
                AffineTransform.prototype.transform = function (ptSrc, srcOff, ptDst, dstOff, numPts) {
                    if (((ptSrc != null && ptSrc instanceof Array && (ptSrc.length == 0 || ptSrc[0] == null || (ptSrc[0] != null && ptSrc[0] instanceof java.awt.geom.Point2D))) || ptSrc === null) && ((typeof srcOff === 'number') || srcOff === null) && ((ptDst != null && ptDst instanceof Array && (ptDst.length == 0 || ptDst[0] == null || (ptDst[0] != null && ptDst[0] instanceof java.awt.geom.Point2D))) || ptDst === null) && ((typeof dstOff === 'number') || dstOff === null) && ((typeof numPts === 'number') || numPts === null)) {
                        return this.transform$java_awt_geom_Point2D_A$int$java_awt_geom_Point2D_A$int$int(ptSrc, srcOff, ptDst, dstOff, numPts);
                    }
                    else if (((ptSrc != null && ptSrc instanceof Array && (ptSrc.length == 0 || ptSrc[0] == null || (typeof ptSrc[0] === 'number'))) || ptSrc === null) && ((typeof srcOff === 'number') || srcOff === null) && ((ptDst != null && ptDst instanceof Array && (ptDst.length == 0 || ptDst[0] == null || (typeof ptDst[0] === 'number'))) || ptDst === null) && ((typeof dstOff === 'number') || dstOff === null) && ((typeof numPts === 'number') || numPts === null)) {
                        return this.transform$float_A$int$float_A$int$int(ptSrc, srcOff, ptDst, dstOff, numPts);
                    }
                    else if (((ptSrc != null && ptSrc instanceof Array && (ptSrc.length == 0 || ptSrc[0] == null || (typeof ptSrc[0] === 'number'))) || ptSrc === null) && ((typeof srcOff === 'number') || srcOff === null) && ((ptDst != null && ptDst instanceof Array && (ptDst.length == 0 || ptDst[0] == null || (typeof ptDst[0] === 'number'))) || ptDst === null) && ((typeof dstOff === 'number') || dstOff === null) && ((typeof numPts === 'number') || numPts === null)) {
                        return this.transform$double_A$int$double_A$int$int(ptSrc, srcOff, ptDst, dstOff, numPts);
                    }
                    else if (((ptSrc != null && ptSrc instanceof Array && (ptSrc.length == 0 || ptSrc[0] == null || (typeof ptSrc[0] === 'number'))) || ptSrc === null) && ((typeof srcOff === 'number') || srcOff === null) && ((ptDst != null && ptDst instanceof Array && (ptDst.length == 0 || ptDst[0] == null || (typeof ptDst[0] === 'number'))) || ptDst === null) && ((typeof dstOff === 'number') || dstOff === null) && ((typeof numPts === 'number') || numPts === null)) {
                        return this.transform$float_A$int$double_A$int$int(ptSrc, srcOff, ptDst, dstOff, numPts);
                    }
                    else if (((ptSrc != null && ptSrc instanceof Array && (ptSrc.length == 0 || ptSrc[0] == null || (typeof ptSrc[0] === 'number'))) || ptSrc === null) && ((typeof srcOff === 'number') || srcOff === null) && ((ptDst != null && ptDst instanceof Array && (ptDst.length == 0 || ptDst[0] == null || (typeof ptDst[0] === 'number'))) || ptDst === null) && ((typeof dstOff === 'number') || dstOff === null) && ((typeof numPts === 'number') || numPts === null)) {
                        return this.transform$double_A$int$float_A$int$int(ptSrc, srcOff, ptDst, dstOff, numPts);
                    }
                    else if (((ptSrc != null && ptSrc instanceof java.awt.geom.Point2D) || ptSrc === null) && ((srcOff != null && srcOff instanceof java.awt.geom.Point2D) || srcOff === null) && ptDst === undefined && dstOff === undefined && numPts === undefined) {
                        return this.transform$java_awt_geom_Point2D$java_awt_geom_Point2D(ptSrc, srcOff);
                    }
                    else
                        throw new Error('invalid overload');
                };
                AffineTransform.prototype.transform$float_A$int$float_A$int$int = function (srcPts, srcOff, dstPts, dstOff, numPts) {
                    var M00;
                    var M01;
                    var M02;
                    var M10;
                    var M11;
                    var M12;
                    if (dstPts === srcPts && dstOff > srcOff && dstOff < srcOff + numPts * 2) {
                        java.awt.geom.Helper.arraycopy(srcPts, srcOff, dstPts, dstOff, numPts * 2);
                        srcOff = dstOff;
                    }
                    switch ((this.state)) {
                        default:
                            this.stateError();
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            M00 = this.m00;
                            M01 = this.m01;
                            M02 = this.m02;
                            M10 = this.m10;
                            M11 = this.m11;
                            M12 = this.m12;
                            while ((--numPts >= 0)) {
                                {
                                    var x = srcPts[srcOff++];
                                    var y = srcPts[srcOff++];
                                    dstPts[dstOff++] = (M00 * x + M01 * y + M02);
                                    dstPts[dstOff++] = (M10 * x + M11 * y + M12);
                                }
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            M00 = this.m00;
                            M01 = this.m01;
                            M10 = this.m10;
                            M11 = this.m11;
                            while ((--numPts >= 0)) {
                                {
                                    var x = srcPts[srcOff++];
                                    var y = srcPts[srcOff++];
                                    dstPts[dstOff++] = (M00 * x + M01 * y);
                                    dstPts[dstOff++] = (M10 * x + M11 * y);
                                }
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                            M01 = this.m01;
                            M02 = this.m02;
                            M10 = this.m10;
                            M12 = this.m12;
                            while ((--numPts >= 0)) {
                                {
                                    var x = srcPts[srcOff++];
                                    dstPts[dstOff++] = (M01 * srcPts[srcOff++] + M02);
                                    dstPts[dstOff++] = (M10 * x + M12);
                                }
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SHEAR):
                            M01 = this.m01;
                            M10 = this.m10;
                            while ((--numPts >= 0)) {
                                {
                                    var x = srcPts[srcOff++];
                                    dstPts[dstOff++] = (M01 * srcPts[srcOff++]);
                                    dstPts[dstOff++] = (M10 * x);
                                }
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            M00 = this.m00;
                            M02 = this.m02;
                            M11 = this.m11;
                            M12 = this.m12;
                            while ((--numPts >= 0)) {
                                {
                                    dstPts[dstOff++] = (M00 * srcPts[srcOff++] + M02);
                                    dstPts[dstOff++] = (M11 * srcPts[srcOff++] + M12);
                                }
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SCALE):
                            M00 = this.m00;
                            M11 = this.m11;
                            while ((--numPts >= 0)) {
                                {
                                    dstPts[dstOff++] = (M00 * srcPts[srcOff++]);
                                    dstPts[dstOff++] = (M11 * srcPts[srcOff++]);
                                }
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_TRANSLATE):
                            M02 = this.m02;
                            M12 = this.m12;
                            while ((--numPts >= 0)) {
                                {
                                    dstPts[dstOff++] = (srcPts[srcOff++] + M02);
                                    dstPts[dstOff++] = (srcPts[srcOff++] + M12);
                                }
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_IDENTITY):
                            if (srcPts !== dstPts || srcOff !== dstOff) {
                                java.awt.geom.Helper.arraycopy(srcPts, srcOff, dstPts, dstOff, numPts * 2);
                            }
                            return;
                    }
                };
                AffineTransform.prototype.transform$double_A$int$double_A$int$int = function (srcPts, srcOff, dstPts, dstOff, numPts) {
                    var M00;
                    var M01;
                    var M02;
                    var M10;
                    var M11;
                    var M12;
                    if (dstPts === srcPts && dstOff > srcOff && dstOff < srcOff + numPts * 2) {
                        java.awt.geom.Helper.arraycopy(srcPts, srcOff, dstPts, dstOff, numPts * 2);
                        srcOff = dstOff;
                    }
                    switch ((this.state)) {
                        default:
                            this.stateError();
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            M00 = this.m00;
                            M01 = this.m01;
                            M02 = this.m02;
                            M10 = this.m10;
                            M11 = this.m11;
                            M12 = this.m12;
                            while ((--numPts >= 0)) {
                                {
                                    var x = srcPts[srcOff++];
                                    var y = srcPts[srcOff++];
                                    dstPts[dstOff++] = M00 * x + M01 * y + M02;
                                    dstPts[dstOff++] = M10 * x + M11 * y + M12;
                                }
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            M00 = this.m00;
                            M01 = this.m01;
                            M10 = this.m10;
                            M11 = this.m11;
                            while ((--numPts >= 0)) {
                                {
                                    var x = srcPts[srcOff++];
                                    var y = srcPts[srcOff++];
                                    dstPts[dstOff++] = M00 * x + M01 * y;
                                    dstPts[dstOff++] = M10 * x + M11 * y;
                                }
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                            M01 = this.m01;
                            M02 = this.m02;
                            M10 = this.m10;
                            M12 = this.m12;
                            while ((--numPts >= 0)) {
                                {
                                    var x = srcPts[srcOff++];
                                    dstPts[dstOff++] = M01 * srcPts[srcOff++] + M02;
                                    dstPts[dstOff++] = M10 * x + M12;
                                }
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SHEAR):
                            M01 = this.m01;
                            M10 = this.m10;
                            while ((--numPts >= 0)) {
                                {
                                    var x = srcPts[srcOff++];
                                    dstPts[dstOff++] = M01 * srcPts[srcOff++];
                                    dstPts[dstOff++] = M10 * x;
                                }
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            M00 = this.m00;
                            M02 = this.m02;
                            M11 = this.m11;
                            M12 = this.m12;
                            while ((--numPts >= 0)) {
                                {
                                    dstPts[dstOff++] = M00 * srcPts[srcOff++] + M02;
                                    dstPts[dstOff++] = M11 * srcPts[srcOff++] + M12;
                                }
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SCALE):
                            M00 = this.m00;
                            M11 = this.m11;
                            while ((--numPts >= 0)) {
                                {
                                    dstPts[dstOff++] = M00 * srcPts[srcOff++];
                                    dstPts[dstOff++] = M11 * srcPts[srcOff++];
                                }
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_TRANSLATE):
                            M02 = this.m02;
                            M12 = this.m12;
                            while ((--numPts >= 0)) {
                                {
                                    dstPts[dstOff++] = srcPts[srcOff++] + M02;
                                    dstPts[dstOff++] = srcPts[srcOff++] + M12;
                                }
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_IDENTITY):
                            if (srcPts !== dstPts || srcOff !== dstOff) {
                                java.awt.geom.Helper.arraycopy(srcPts, srcOff, dstPts, dstOff, numPts * 2);
                            }
                            return;
                    }
                };
                AffineTransform.prototype.transform$float_A$int$double_A$int$int = function (srcPts, srcOff, dstPts, dstOff, numPts) {
                    var M00;
                    var M01;
                    var M02;
                    var M10;
                    var M11;
                    var M12;
                    switch ((this.state)) {
                        default:
                            this.stateError();
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            M00 = this.m00;
                            M01 = this.m01;
                            M02 = this.m02;
                            M10 = this.m10;
                            M11 = this.m11;
                            M12 = this.m12;
                            while ((--numPts >= 0)) {
                                {
                                    var x = srcPts[srcOff++];
                                    var y = srcPts[srcOff++];
                                    dstPts[dstOff++] = M00 * x + M01 * y + M02;
                                    dstPts[dstOff++] = M10 * x + M11 * y + M12;
                                }
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            M00 = this.m00;
                            M01 = this.m01;
                            M10 = this.m10;
                            M11 = this.m11;
                            while ((--numPts >= 0)) {
                                {
                                    var x = srcPts[srcOff++];
                                    var y = srcPts[srcOff++];
                                    dstPts[dstOff++] = M00 * x + M01 * y;
                                    dstPts[dstOff++] = M10 * x + M11 * y;
                                }
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                            M01 = this.m01;
                            M02 = this.m02;
                            M10 = this.m10;
                            M12 = this.m12;
                            while ((--numPts >= 0)) {
                                {
                                    var x = srcPts[srcOff++];
                                    dstPts[dstOff++] = M01 * srcPts[srcOff++] + M02;
                                    dstPts[dstOff++] = M10 * x + M12;
                                }
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SHEAR):
                            M01 = this.m01;
                            M10 = this.m10;
                            while ((--numPts >= 0)) {
                                {
                                    var x = srcPts[srcOff++];
                                    dstPts[dstOff++] = M01 * srcPts[srcOff++];
                                    dstPts[dstOff++] = M10 * x;
                                }
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            M00 = this.m00;
                            M02 = this.m02;
                            M11 = this.m11;
                            M12 = this.m12;
                            while ((--numPts >= 0)) {
                                {
                                    dstPts[dstOff++] = M00 * srcPts[srcOff++] + M02;
                                    dstPts[dstOff++] = M11 * srcPts[srcOff++] + M12;
                                }
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SCALE):
                            M00 = this.m00;
                            M11 = this.m11;
                            while ((--numPts >= 0)) {
                                {
                                    dstPts[dstOff++] = M00 * srcPts[srcOff++];
                                    dstPts[dstOff++] = M11 * srcPts[srcOff++];
                                }
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_TRANSLATE):
                            M02 = this.m02;
                            M12 = this.m12;
                            while ((--numPts >= 0)) {
                                {
                                    dstPts[dstOff++] = srcPts[srcOff++] + M02;
                                    dstPts[dstOff++] = srcPts[srcOff++] + M12;
                                }
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_IDENTITY):
                            while ((--numPts >= 0)) {
                                {
                                    dstPts[dstOff++] = srcPts[srcOff++];
                                    dstPts[dstOff++] = srcPts[srcOff++];
                                }
                            }
                            ;
                            return;
                    }
                };
                AffineTransform.prototype.transform$double_A$int$float_A$int$int = function (srcPts, srcOff, dstPts, dstOff, numPts) {
                    var M00;
                    var M01;
                    var M02;
                    var M10;
                    var M11;
                    var M12;
                    switch ((this.state)) {
                        default:
                            this.stateError();
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            M00 = this.m00;
                            M01 = this.m01;
                            M02 = this.m02;
                            M10 = this.m10;
                            M11 = this.m11;
                            M12 = this.m12;
                            while ((--numPts >= 0)) {
                                {
                                    var x = srcPts[srcOff++];
                                    var y = srcPts[srcOff++];
                                    dstPts[dstOff++] = (M00 * x + M01 * y + M02);
                                    dstPts[dstOff++] = (M10 * x + M11 * y + M12);
                                }
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            M00 = this.m00;
                            M01 = this.m01;
                            M10 = this.m10;
                            M11 = this.m11;
                            while ((--numPts >= 0)) {
                                {
                                    var x = srcPts[srcOff++];
                                    var y = srcPts[srcOff++];
                                    dstPts[dstOff++] = (M00 * x + M01 * y);
                                    dstPts[dstOff++] = (M10 * x + M11 * y);
                                }
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                            M01 = this.m01;
                            M02 = this.m02;
                            M10 = this.m10;
                            M12 = this.m12;
                            while ((--numPts >= 0)) {
                                {
                                    var x = srcPts[srcOff++];
                                    dstPts[dstOff++] = (M01 * srcPts[srcOff++] + M02);
                                    dstPts[dstOff++] = (M10 * x + M12);
                                }
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SHEAR):
                            M01 = this.m01;
                            M10 = this.m10;
                            while ((--numPts >= 0)) {
                                {
                                    var x = srcPts[srcOff++];
                                    dstPts[dstOff++] = (M01 * srcPts[srcOff++]);
                                    dstPts[dstOff++] = (M10 * x);
                                }
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            M00 = this.m00;
                            M02 = this.m02;
                            M11 = this.m11;
                            M12 = this.m12;
                            while ((--numPts >= 0)) {
                                {
                                    dstPts[dstOff++] = (M00 * srcPts[srcOff++] + M02);
                                    dstPts[dstOff++] = (M11 * srcPts[srcOff++] + M12);
                                }
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SCALE):
                            M00 = this.m00;
                            M11 = this.m11;
                            while ((--numPts >= 0)) {
                                {
                                    dstPts[dstOff++] = (M00 * srcPts[srcOff++]);
                                    dstPts[dstOff++] = (M11 * srcPts[srcOff++]);
                                }
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_TRANSLATE):
                            M02 = this.m02;
                            M12 = this.m12;
                            while ((--numPts >= 0)) {
                                {
                                    dstPts[dstOff++] = (srcPts[srcOff++] + M02);
                                    dstPts[dstOff++] = (srcPts[srcOff++] + M12);
                                }
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_IDENTITY):
                            while ((--numPts >= 0)) {
                                {
                                    dstPts[dstOff++] = (srcPts[srcOff++]);
                                    dstPts[dstOff++] = (srcPts[srcOff++]);
                                }
                            }
                            ;
                            return;
                    }
                };
                AffineTransform.prototype.inverseTransform$java_awt_geom_Point2D$java_awt_geom_Point2D = function (ptSrc, ptDst) {
                    if (ptDst == null) {
                        if (ptSrc != null && ptSrc instanceof java.awt.geom.Point2D.Double) {
                            ptDst = new java.awt.geom.Point2D.Double();
                        }
                        else {
                            ptDst = new java.awt.geom.Point2D.Float();
                        }
                    }
                    var x = ptSrc.getX();
                    var y = ptSrc.getY();
                    switch ((this.state)) {
                        default:
                            this.stateError();
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            x -= this.m02;
                            y -= this.m12;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            var det = this.m00 * this.m11 - this.m01 * this.m10;
                            if (Math.abs(det) <= 4.9E-324) {
                                throw Object.defineProperty(new Error("Determinant is " + det), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.awt.geom.NoninvertibleTransformException', 'java.lang.Object', 'java.lang.Exception'] });
                            }
                            ptDst.setLocation$double$double((x * this.m11 - y * this.m01) / det, (y * this.m00 - x * this.m10) / det);
                            return ptDst;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                            x -= this.m02;
                            y -= this.m12;
                        case (AffineTransform.APPLY_SHEAR):
                            if (this.m01 === 0.0 || this.m10 === 0.0) {
                                throw Object.defineProperty(new Error("Determinant is 0"), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.awt.geom.NoninvertibleTransformException', 'java.lang.Object', 'java.lang.Exception'] });
                            }
                            ptDst.setLocation$double$double(y / this.m10, x / this.m01);
                            return ptDst;
                        case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            x -= this.m02;
                            y -= this.m12;
                        case (AffineTransform.APPLY_SCALE):
                            if (this.m00 === 0.0 || this.m11 === 0.0) {
                                throw Object.defineProperty(new Error("Determinant is 0"), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.awt.geom.NoninvertibleTransformException', 'java.lang.Object', 'java.lang.Exception'] });
                            }
                            ptDst.setLocation$double$double(x / this.m00, y / this.m11);
                            return ptDst;
                        case (AffineTransform.APPLY_TRANSLATE):
                            ptDst.setLocation$double$double(x - this.m02, y - this.m12);
                            return ptDst;
                        case (AffineTransform.APPLY_IDENTITY):
                            ptDst.setLocation$double$double(x, y);
                            return ptDst;
                    }
                };
                AffineTransform.prototype.inverseTransform$double_A$int$double_A$int$int = function (srcPts, srcOff, dstPts, dstOff, numPts) {
                    var M00;
                    var M01;
                    var M02;
                    var M10;
                    var M11;
                    var M12;
                    var det;
                    if (dstPts === srcPts && dstOff > srcOff && dstOff < srcOff + numPts * 2) {
                        java.awt.geom.Helper.arraycopy(srcPts, srcOff, dstPts, dstOff, numPts * 2);
                        srcOff = dstOff;
                    }
                    switch ((this.state)) {
                        default:
                            this.stateError();
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            M00 = this.m00;
                            M01 = this.m01;
                            M02 = this.m02;
                            M10 = this.m10;
                            M11 = this.m11;
                            M12 = this.m12;
                            det = M00 * M11 - M01 * M10;
                            if (Math.abs(det) <= 4.9E-324) {
                                throw Object.defineProperty(new Error("Determinant is " + det), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.awt.geom.NoninvertibleTransformException', 'java.lang.Object', 'java.lang.Exception'] });
                            }
                            while ((--numPts >= 0)) {
                                {
                                    var x = srcPts[srcOff++] - M02;
                                    var y = srcPts[srcOff++] - M12;
                                    dstPts[dstOff++] = (x * M11 - y * M01) / det;
                                    dstPts[dstOff++] = (y * M00 - x * M10) / det;
                                }
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            M00 = this.m00;
                            M01 = this.m01;
                            M10 = this.m10;
                            M11 = this.m11;
                            det = M00 * M11 - M01 * M10;
                            if (Math.abs(det) <= 4.9E-324) {
                                throw Object.defineProperty(new Error("Determinant is " + det), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.awt.geom.NoninvertibleTransformException', 'java.lang.Object', 'java.lang.Exception'] });
                            }
                            while ((--numPts >= 0)) {
                                {
                                    var x = srcPts[srcOff++];
                                    var y = srcPts[srcOff++];
                                    dstPts[dstOff++] = (x * M11 - y * M01) / det;
                                    dstPts[dstOff++] = (y * M00 - x * M10) / det;
                                }
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                            M01 = this.m01;
                            M02 = this.m02;
                            M10 = this.m10;
                            M12 = this.m12;
                            if (M01 === 0.0 || M10 === 0.0) {
                                throw Object.defineProperty(new Error("Determinant is 0"), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.awt.geom.NoninvertibleTransformException', 'java.lang.Object', 'java.lang.Exception'] });
                            }
                            while ((--numPts >= 0)) {
                                {
                                    var x = srcPts[srcOff++] - M02;
                                    dstPts[dstOff++] = (srcPts[srcOff++] - M12) / M10;
                                    dstPts[dstOff++] = x / M01;
                                }
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SHEAR):
                            M01 = this.m01;
                            M10 = this.m10;
                            if (M01 === 0.0 || M10 === 0.0) {
                                throw Object.defineProperty(new Error("Determinant is 0"), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.awt.geom.NoninvertibleTransformException', 'java.lang.Object', 'java.lang.Exception'] });
                            }
                            while ((--numPts >= 0)) {
                                {
                                    var x = srcPts[srcOff++];
                                    dstPts[dstOff++] = srcPts[srcOff++] / M10;
                                    dstPts[dstOff++] = x / M01;
                                }
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                            M00 = this.m00;
                            M02 = this.m02;
                            M11 = this.m11;
                            M12 = this.m12;
                            if (M00 === 0.0 || M11 === 0.0) {
                                throw Object.defineProperty(new Error("Determinant is 0"), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.awt.geom.NoninvertibleTransformException', 'java.lang.Object', 'java.lang.Exception'] });
                            }
                            while ((--numPts >= 0)) {
                                {
                                    dstPts[dstOff++] = (srcPts[srcOff++] - M02) / M00;
                                    dstPts[dstOff++] = (srcPts[srcOff++] - M12) / M11;
                                }
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SCALE):
                            M00 = this.m00;
                            M11 = this.m11;
                            if (M00 === 0.0 || M11 === 0.0) {
                                throw Object.defineProperty(new Error("Determinant is 0"), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.awt.geom.NoninvertibleTransformException', 'java.lang.Object', 'java.lang.Exception'] });
                            }
                            while ((--numPts >= 0)) {
                                {
                                    dstPts[dstOff++] = srcPts[srcOff++] / M00;
                                    dstPts[dstOff++] = srcPts[srcOff++] / M11;
                                }
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_TRANSLATE):
                            M02 = this.m02;
                            M12 = this.m12;
                            while ((--numPts >= 0)) {
                                {
                                    dstPts[dstOff++] = srcPts[srcOff++] - M02;
                                    dstPts[dstOff++] = srcPts[srcOff++] - M12;
                                }
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_IDENTITY):
                            if (srcPts !== dstPts || srcOff !== dstOff) {
                                java.awt.geom.Helper.arraycopy(srcPts, srcOff, dstPts, dstOff, numPts * 2);
                            }
                            return;
                    }
                };
                /**
                 * Inverse transforms an array of double precision coordinates by
                 * this transform.
                 * The two coordinate array sections can be exactly the same or
                 * can be overlapping sections of the same array without affecting the
                 * validity of the results.
                 * This method ensures that no source coordinates are
                 * overwritten by a previous operation before they can be transformed.
                 * The coordinates are stored in the arrays starting at the specified
                 * offset in the order <code>[x0, y0, x1, y1, ..., xn, yn]</code>.
                 * @param {Array} srcPts the array containing the source point coordinates.
                 * Each point is stored as a pair of x,&nbsp;y coordinates.
                 * @param {Array} dstPts the array into which the transformed point
                 * coordinates are returned.  Each point is stored as a pair of
                 * x,&nbsp;y coordinates.
                 * @param {number} srcOff the offset to the first point to be transformed
                 * in the source array
                 * @param {number} dstOff the offset to the location of the first
                 * transformed point that is stored in the destination array
                 * @param {number} numPts the number of point objects to be transformed
                 * @exception NoninvertibleTransformException  if the matrix cannot be
                 * inverted.
                 * @since 1.2
                 */
                AffineTransform.prototype.inverseTransform = function (srcPts, srcOff, dstPts, dstOff, numPts) {
                    if (((srcPts != null && srcPts instanceof Array && (srcPts.length == 0 || srcPts[0] == null || (typeof srcPts[0] === 'number'))) || srcPts === null) && ((typeof srcOff === 'number') || srcOff === null) && ((dstPts != null && dstPts instanceof Array && (dstPts.length == 0 || dstPts[0] == null || (typeof dstPts[0] === 'number'))) || dstPts === null) && ((typeof dstOff === 'number') || dstOff === null) && ((typeof numPts === 'number') || numPts === null)) {
                        return this.inverseTransform$double_A$int$double_A$int$int(srcPts, srcOff, dstPts, dstOff, numPts);
                    }
                    else if (((srcPts != null && srcPts instanceof java.awt.geom.Point2D) || srcPts === null) && ((srcOff != null && srcOff instanceof java.awt.geom.Point2D) || srcOff === null) && dstPts === undefined && dstOff === undefined && numPts === undefined) {
                        return this.inverseTransform$java_awt_geom_Point2D$java_awt_geom_Point2D(srcPts, srcOff);
                    }
                    else
                        throw new Error('invalid overload');
                };
                AffineTransform.prototype.deltaTransform$java_awt_geom_Point2D$java_awt_geom_Point2D = function (ptSrc, ptDst) {
                    if (ptDst == null) {
                        if (ptSrc != null && ptSrc instanceof java.awt.geom.Point2D.Double) {
                            ptDst = new java.awt.geom.Point2D.Double();
                        }
                        else {
                            ptDst = new java.awt.geom.Point2D.Float();
                        }
                    }
                    var x = ptSrc.getX();
                    var y = ptSrc.getY();
                    switch ((this.state)) {
                        default:
                            this.stateError();
                            return null;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            ptDst.setLocation$double$double(x * this.m00 + y * this.m01, x * this.m10 + y * this.m11);
                            return ptDst;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_SHEAR):
                            ptDst.setLocation$double$double(y * this.m01, x * this.m10);
                            return ptDst;
                        case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_SCALE):
                            ptDst.setLocation$double$double(x * this.m00, y * this.m11);
                            return ptDst;
                        case (AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_IDENTITY):
                            ptDst.setLocation$double$double(x, y);
                            return ptDst;
                    }
                };
                AffineTransform.prototype.deltaTransform$double_A$int$double_A$int$int = function (srcPts, srcOff, dstPts, dstOff, numPts) {
                    var M00;
                    var M01;
                    var M10;
                    var M11;
                    if (dstPts === srcPts && dstOff > srcOff && dstOff < srcOff + numPts * 2) {
                        java.awt.geom.Helper.arraycopy(srcPts, srcOff, dstPts, dstOff, numPts * 2);
                        srcOff = dstOff;
                    }
                    switch ((this.state)) {
                        default:
                            this.stateError();
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_SCALE):
                            M00 = this.m00;
                            M01 = this.m01;
                            M10 = this.m10;
                            M11 = this.m11;
                            while ((--numPts >= 0)) {
                                {
                                    var x = srcPts[srcOff++];
                                    var y = srcPts[srcOff++];
                                    dstPts[dstOff++] = x * M00 + y * M01;
                                    dstPts[dstOff++] = x * M10 + y * M11;
                                }
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SHEAR | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_SHEAR):
                            M01 = this.m01;
                            M10 = this.m10;
                            while ((--numPts >= 0)) {
                                {
                                    var x = srcPts[srcOff++];
                                    dstPts[dstOff++] = srcPts[srcOff++] * M01;
                                    dstPts[dstOff++] = x * M10;
                                }
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_SCALE | AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_SCALE):
                            M00 = this.m00;
                            M11 = this.m11;
                            while ((--numPts >= 0)) {
                                {
                                    dstPts[dstOff++] = srcPts[srcOff++] * M00;
                                    dstPts[dstOff++] = srcPts[srcOff++] * M11;
                                }
                            }
                            ;
                            return;
                        case (AffineTransform.APPLY_TRANSLATE):
                        case (AffineTransform.APPLY_IDENTITY):
                            if (srcPts !== dstPts || srcOff !== dstOff) {
                                java.awt.geom.Helper.arraycopy(srcPts, srcOff, dstPts, dstOff, numPts * 2);
                            }
                            return;
                    }
                };
                /**
                 * Transforms an array of relative distance vectors by this
                 * transform.
                 * A relative distance vector is transformed without applying the
                 * translation components of the affine transformation matrix
                 * using the following equations:
                 * <pre>
                 * [  x' ]   [  m00  m01 (m02) ] [  x  ]   [ m00x + m01y ]
                 * [  y' ] = [  m10  m11 (m12) ] [  y  ] = [ m10x + m11y ]
                 * [ (1) ]   [  (0)  (0) ( 1 ) ] [ (1) ]   [     (1)     ]
                 * </pre>
                 * The two coordinate array sections can be exactly the same or
                 * can be overlapping sections of the same array without affecting the
                 * validity of the results.
                 * This method ensures that no source coordinates are
                 * overwritten by a previous operation before they can be transformed.
                 * The coordinates are stored in the arrays starting at the indicated
                 * offset in the order <code>[x0, y0, x1, y1, ..., xn, yn]</code>.
                 * @param {Array} srcPts the array containing the source distance vectors.
                 * Each vector is stored as a pair of relative x,&nbsp;y coordinates.
                 * @param {Array} dstPts the array into which the transformed distance vectors
                 * are returned.  Each vector is stored as a pair of relative
                 * x,&nbsp;y coordinates.
                 * @param {number} srcOff the offset to the first vector to be transformed
                 * in the source array
                 * @param {number} dstOff the offset to the location of the first
                 * transformed vector that is stored in the destination array
                 * @param {number} numPts the number of vector coordinate pairs to be
                 * transformed
                 * @since 1.2
                 */
                AffineTransform.prototype.deltaTransform = function (srcPts, srcOff, dstPts, dstOff, numPts) {
                    if (((srcPts != null && srcPts instanceof Array && (srcPts.length == 0 || srcPts[0] == null || (typeof srcPts[0] === 'number'))) || srcPts === null) && ((typeof srcOff === 'number') || srcOff === null) && ((dstPts != null && dstPts instanceof Array && (dstPts.length == 0 || dstPts[0] == null || (typeof dstPts[0] === 'number'))) || dstPts === null) && ((typeof dstOff === 'number') || dstOff === null) && ((typeof numPts === 'number') || numPts === null)) {
                        return this.deltaTransform$double_A$int$double_A$int$int(srcPts, srcOff, dstPts, dstOff, numPts);
                    }
                    else if (((srcPts != null && srcPts instanceof java.awt.geom.Point2D) || srcPts === null) && ((srcOff != null && srcOff instanceof java.awt.geom.Point2D) || srcOff === null) && dstPts === undefined && dstOff === undefined && numPts === undefined) {
                        return this.deltaTransform$java_awt_geom_Point2D$java_awt_geom_Point2D(srcPts, srcOff);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns a new {@link Shape} object defined by the geometry of the
                 * specified <code>Shape</code> after it has been transformed by
                 * this transform.
                 * @param {*} pSrc the specified <code>Shape</code> object to be
                 * transformed by this transform.
                 * @return {*} a new <code>Shape</code> object that defines the geometry
                 * of the transformed <code>Shape</code>, or null if {@code pSrc} is null.
                 * @since 1.2
                 */
                AffineTransform.prototype.createTransformedShape = function (pSrc) {
                    if (pSrc == null) {
                        return null;
                    }
                    return new java.awt.geom.Path2D.Double(pSrc, this);
                };
                /*private*/ AffineTransform._matround = function (matval) {
                    return /* rint */ (function (d) { if (d === Number.NaN) {
                        return d;
                    }
                    else if (Number.POSITIVE_INFINITY === d || Number.NEGATIVE_INFINITY === d) {
                        return d;
                    }
                    else if (d == 0) {
                        return d;
                    }
                    else {
                        return Math.round(d);
                    } })(matval * 1.0E15) / 1.0E15;
                };
                /**
                 * Returns a <code>String</code> that represents the value of this
                 * {@link Object}.
                 * @return {string} a <code>String</code> representing the value of this
                 * <code>Object</code>.
                 * @since 1.2
                 */
                AffineTransform.prototype.toString = function () {
                    return ("AffineTransform[[" + AffineTransform._matround(this.m00) + ", " + AffineTransform._matround(this.m01) + ", " + AffineTransform._matround(this.m02) + "], [" + AffineTransform._matround(this.m10) + ", " + AffineTransform._matround(this.m11) + ", " + AffineTransform._matround(this.m12) + "]]");
                };
                /**
                 * Returns <code>true</code> if this <code>AffineTransform</code> is
                 * an identity transform.
                 * @return {boolean} <code>true</code> if this <code>AffineTransform</code> is
                 * an identity transform; <code>false</code> otherwise.
                 * @since 1.2
                 */
                AffineTransform.prototype.isIdentity = function () {
                    return (this.state === AffineTransform.APPLY_IDENTITY || (this.getType() === AffineTransform.TYPE_IDENTITY));
                };
                /**
                 * Returns a copy of this <code>AffineTransform</code> object.
                 * @return {*} an <code>Object</code> that is a copy of this
                 * <code>AffineTransform</code> object.
                 * @since 1.2
                 */
                AffineTransform.prototype.clone = function () {
                    try {
                        return /* clone */ /* clone */ (function (o) { var clone = Object.create(o); for (var p in o) {
                            if (o.hasOwnProperty(p))
                                clone[p] = o[p];
                        } return clone; })(this);
                    }
                    catch (e) {
                        throw Object.defineProperty(new Error(e.message), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.VirtualMachineError', 'java.lang.InternalError', 'java.lang.Error', 'java.lang.Object'] });
                    }
                    ;
                };
                /**
                 * Returns <code>true</code> if this <code>AffineTransform</code>
                 * represents the same affine coordinate transform as the specified
                 * argument.
                 * @param {*} obj the <code>Object</code> to test for equality with this
                 * <code>AffineTransform</code>
                 * @return {boolean} <code>true</code> if <code>obj</code> equals this
                 * <code>AffineTransform</code> object; <code>false</code> otherwise.
                 * @since 1.2
                 */
                AffineTransform.prototype.equals = function (obj) {
                    if (!(obj != null && obj instanceof java.awt.geom.AffineTransform)) {
                        return false;
                    }
                    var a = obj;
                    return ((this.m00 === a.m00) && (this.m01 === a.m01) && (this.m02 === a.m02) && (this.m10 === a.m10) && (this.m11 === a.m11) && (this.m12 === a.m12));
                };
                AffineTransform.TYPE_UNKNOWN = -1;
                /**
                 * This constant indicates that the transform defined by this object
                 * is an identity transform.
                 * An identity transform is one in which the output coordinates are
                 * always the same as the input coordinates.
                 * If this transform is anything other than the identity transform,
                 * the type will either be the constant GENERAL_TRANSFORM or a
                 * combination of the appropriate flag bits for the various coordinate
                 * conversions that this transform performs.
                 * @see #TYPE_TRANSLATION
                 * @see #TYPE_UNIFORM_SCALE
                 * @see #TYPE_GENERAL_SCALE
                 * @see #TYPE_FLIP
                 * @see #TYPE_QUADRANT_ROTATION
                 * @see #TYPE_GENERAL_ROTATION
                 * @see #TYPE_GENERAL_TRANSFORM
                 * @see #getType
                 * @since 1.2
                 */
                AffineTransform.TYPE_IDENTITY = 0;
                /**
                 * This flag bit indicates that the transform defined by this object
                 * performs a translation in addition to the conversions indicated
                 * by other flag bits.
                 * A translation moves the coordinates by a constant amount in x
                 * and y without changing the length or angle of vectors.
                 * @see #TYPE_IDENTITY
                 * @see #TYPE_UNIFORM_SCALE
                 * @see #TYPE_GENERAL_SCALE
                 * @see #TYPE_FLIP
                 * @see #TYPE_QUADRANT_ROTATION
                 * @see #TYPE_GENERAL_ROTATION
                 * @see #TYPE_GENERAL_TRANSFORM
                 * @see #getType
                 * @since 1.2
                 */
                AffineTransform.TYPE_TRANSLATION = 1;
                /**
                 * This flag bit indicates that the transform defined by this object
                 * performs a uniform scale in addition to the conversions indicated
                 * by other flag bits.
                 * A uniform scale multiplies the length of vectors by the same amount
                 * in both the x and y directions without changing the angle between
                 * vectors.
                 * This flag bit is mutually exclusive with the TYPE_GENERAL_SCALE flag.
                 * @see #TYPE_IDENTITY
                 * @see #TYPE_TRANSLATION
                 * @see #TYPE_GENERAL_SCALE
                 * @see #TYPE_FLIP
                 * @see #TYPE_QUADRANT_ROTATION
                 * @see #TYPE_GENERAL_ROTATION
                 * @see #TYPE_GENERAL_TRANSFORM
                 * @see #getType
                 * @since 1.2
                 */
                AffineTransform.TYPE_UNIFORM_SCALE = 2;
                /**
                 * This flag bit indicates that the transform defined by this object
                 * performs a general scale in addition to the conversions indicated
                 * by other flag bits.
                 * A general scale multiplies the length of vectors by different
                 * amounts in the x and y directions without changing the angle
                 * between perpendicular vectors.
                 * This flag bit is mutually exclusive with the TYPE_UNIFORM_SCALE flag.
                 * @see #TYPE_IDENTITY
                 * @see #TYPE_TRANSLATION
                 * @see #TYPE_UNIFORM_SCALE
                 * @see #TYPE_FLIP
                 * @see #TYPE_QUADRANT_ROTATION
                 * @see #TYPE_GENERAL_ROTATION
                 * @see #TYPE_GENERAL_TRANSFORM
                 * @see #getType
                 * @since 1.2
                 */
                AffineTransform.TYPE_GENERAL_SCALE = 4;
                /**
                 * This flag bit indicates that the transform defined by this object
                 * performs a mirror image flip about some axis which changes the
                 * normally right handed coordinate system into a left handed
                 * system in addition to the conversions indicated by other flag bits.
                 * A right handed coordinate system is one where the positive X
                 * axis rotates counterclockwise to overlay the positive Y axis
                 * similar to the direction that the fingers on your right hand
                 * curl when you stare end on at your thumb.
                 * A left handed coordinate system is one where the positive X
                 * axis rotates clockwise to overlay the positive Y axis similar
                 * to the direction that the fingers on your left hand curl.
                 * There is no mathematical way to determine the angle of the
                 * original flipping or mirroring transformation since all angles
                 * of flip are identical given an appropriate adjusting rotation.
                 * @see #TYPE_IDENTITY
                 * @see #TYPE_TRANSLATION
                 * @see #TYPE_UNIFORM_SCALE
                 * @see #TYPE_GENERAL_SCALE
                 * @see #TYPE_QUADRANT_ROTATION
                 * @see #TYPE_GENERAL_ROTATION
                 * @see #TYPE_GENERAL_TRANSFORM
                 * @see #getType
                 * @since 1.2
                 */
                AffineTransform.TYPE_FLIP = 64;
                /**
                 * This flag bit indicates that the transform defined by this object
                 * performs a quadrant rotation by some multiple of 90 degrees in
                 * addition to the conversions indicated by other flag bits.
                 * A rotation changes the angles of vectors by the same amount
                 * regardless of the original direction of the vector and without
                 * changing the length of the vector.
                 * This flag bit is mutually exclusive with the TYPE_GENERAL_ROTATION flag.
                 * @see #TYPE_IDENTITY
                 * @see #TYPE_TRANSLATION
                 * @see #TYPE_UNIFORM_SCALE
                 * @see #TYPE_GENERAL_SCALE
                 * @see #TYPE_FLIP
                 * @see #TYPE_GENERAL_ROTATION
                 * @see #TYPE_GENERAL_TRANSFORM
                 * @see #getType
                 * @since 1.2
                 */
                AffineTransform.TYPE_QUADRANT_ROTATION = 8;
                /**
                 * This flag bit indicates that the transform defined by this object
                 * performs a rotation by an arbitrary angle in addition to the
                 * conversions indicated by other flag bits.
                 * A rotation changes the angles of vectors by the same amount
                 * regardless of the original direction of the vector and without
                 * changing the length of the vector.
                 * This flag bit is mutually exclusive with the
                 * TYPE_QUADRANT_ROTATION flag.
                 * @see #TYPE_IDENTITY
                 * @see #TYPE_TRANSLATION
                 * @see #TYPE_UNIFORM_SCALE
                 * @see #TYPE_GENERAL_SCALE
                 * @see #TYPE_FLIP
                 * @see #TYPE_QUADRANT_ROTATION
                 * @see #TYPE_GENERAL_TRANSFORM
                 * @see #getType
                 * @since 1.2
                 */
                AffineTransform.TYPE_GENERAL_ROTATION = 16;
                /**
                 * This constant indicates that the transform defined by this object
                 * performs an arbitrary conversion of the input coordinates.
                 * If this transform can be classified by any of the above constants,
                 * the type will either be the constant TYPE_IDENTITY or a
                 * combination of the appropriate flag bits for the various coordinate
                 * conversions that this transform performs.
                 * @see #TYPE_IDENTITY
                 * @see #TYPE_TRANSLATION
                 * @see #TYPE_UNIFORM_SCALE
                 * @see #TYPE_GENERAL_SCALE
                 * @see #TYPE_FLIP
                 * @see #TYPE_QUADRANT_ROTATION
                 * @see #TYPE_GENERAL_ROTATION
                 * @see #getType
                 * @since 1.2
                 */
                AffineTransform.TYPE_GENERAL_TRANSFORM = 32;
                /**
                 * This constant is used for the internal state variable to indicate
                 * that no calculations need to be performed and that the source
                 * coordinates only need to be copied to their destinations to
                 * complete the transformation equation of this transform.
                 * @see #APPLY_TRANSLATE
                 * @see #APPLY_SCALE
                 * @see #APPLY_SHEAR
                 * @see #state
                 */
                AffineTransform.APPLY_IDENTITY = 0;
                /**
                 * This constant is used for the internal state variable to indicate
                 * that the translation components of the matrix (m02 and m12) need
                 * to be added to complete the transformation equation of this transform.
                 * @see #APPLY_IDENTITY
                 * @see #APPLY_SCALE
                 * @see #APPLY_SHEAR
                 * @see #state
                 */
                AffineTransform.APPLY_TRANSLATE = 1;
                /**
                 * This constant is used for the internal state variable to indicate
                 * that the scaling components of the matrix (m00 and m11) need
                 * to be factored in to complete the transformation equation of
                 * this transform.  If the APPLY_SHEAR bit is also set then it
                 * indicates that the scaling components are not both 0.0.  If the
                 * APPLY_SHEAR bit is not also set then it indicates that the
                 * scaling components are not both 1.0.  If neither the APPLY_SHEAR
                 * nor the APPLY_SCALE bits are set then the scaling components
                 * are both 1.0, which means that the x and y components contribute
                 * to the transformed coordinate, but they are not multiplied by
                 * any scaling factor.
                 * @see #APPLY_IDENTITY
                 * @see #APPLY_TRANSLATE
                 * @see #APPLY_SHEAR
                 * @see #state
                 */
                AffineTransform.APPLY_SCALE = 2;
                /**
                 * This constant is used for the internal state variable to indicate
                 * that the shearing components of the matrix (m01 and m10) need
                 * to be factored in to complete the transformation equation of this
                 * transform.  The presence of this bit in the state variable changes
                 * the interpretation of the APPLY_SCALE bit as indicated in its
                 * documentation.
                 * @see #APPLY_IDENTITY
                 * @see #APPLY_TRANSLATE
                 * @see #APPLY_SCALE
                 * @see #state
                 */
                AffineTransform.APPLY_SHEAR = 4;
                AffineTransform.HI_SHIFT = 3;
                AffineTransform.serialVersionUID = 1330973210523860834;
                return AffineTransform;
            }());
            geom.AffineTransform = AffineTransform;
            AffineTransform["__class"] = "java.awt.geom.AffineTransform";
            AffineTransform["__interfaces"] = ["java.lang.Cloneable", "java.io.Serializable"];
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * A utility class to iterate over the path segments of a quadratic curve
             * segment through the PathIterator interface.
             *
             * @author Jim Graham
             * @class
             */
            var QuadIterator = /** @class */ (function () {
                function QuadIterator(q, at) {
                    if (this.quad === undefined)
                        this.quad = null;
                    if (this.affine === undefined)
                        this.affine = null;
                    if (this.index === undefined)
                        this.index = 0;
                    this.quad = q;
                    this.affine = at;
                }
                /**
                 * Return the winding rule for determining the insideness of the path.
                 *
                 * @see #WIND_EVEN_ODD
                 * @see #WIND_NON_ZERO
                 * @return {number}
                 */
                QuadIterator.prototype.getWindingRule = function () {
                    return java.awt.geom.PathIterator.WIND_NON_ZERO;
                };
                /**
                 * Tests if there are more points to read.
                 *
                 * @return {boolean} true if there are more points to read
                 */
                QuadIterator.prototype.isDone = function () {
                    return (this.index > 1);
                };
                /**
                 * Moves the iterator to the next segment of the path forwards along the
                 * primary direction of traversal as long as there are more points in that
                 * direction.
                 */
                QuadIterator.prototype.next = function () {
                    this.index++;
                };
                QuadIterator.prototype.currentSegment$float_A = function (coords) {
                    if (this.isDone()) {
                        throw Object.defineProperty(new Error("quad iterator iterator out of bounds"), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.Object', 'java.lang.RuntimeException', 'java.util.NoSuchElementException', 'java.lang.Exception'] });
                    }
                    var type;
                    if (this.index === 0) {
                        coords[0] = this.quad.getX1();
                        coords[1] = this.quad.getY1();
                        type = java.awt.geom.PathIterator.SEG_MOVETO;
                    }
                    else {
                        coords[0] = this.quad.getCtrlX();
                        coords[1] = this.quad.getCtrlY();
                        coords[2] = this.quad.getX2();
                        coords[3] = this.quad.getY2();
                        type = java.awt.geom.PathIterator.SEG_QUADTO;
                    }
                    if (this.affine != null) {
                        this.affine.transform$float_A$int$float_A$int$int(coords, 0, coords, 0, this.index === 0 ? 1 : 2);
                    }
                    return type;
                };
                /**
                 * Returns the coordinates and type of the current path segment in the
                 * iteration. The return value is the path segment type: SEG_MOVETO,
                 * SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE. A float array of
                 * length 6 must be passed in and may be used to store the coordinates of
                 * the point(s). Each point is stored as a pair of float x,y coordinates.
                 * SEG_MOVETO and SEG_LINETO types will return one point, SEG_QUADTO will
                 * return two points, SEG_CUBICTO will return 3 points and SEG_CLOSE will
                 * not return any points.
                 *
                 * @see #SEG_MOVETO
                 * @see #SEG_LINETO
                 * @see #SEG_QUADTO
                 * @see #SEG_CUBICTO
                 * @see #SEG_CLOSE
                 * @param {Array} coords
                 * @return {number}
                 */
                QuadIterator.prototype.currentSegment = function (coords) {
                    if (((coords != null && coords instanceof Array && (coords.length == 0 || coords[0] == null || (typeof coords[0] === 'number'))) || coords === null)) {
                        return this.currentSegment$float_A(coords);
                    }
                    else if (((coords != null && coords instanceof Array && (coords.length == 0 || coords[0] == null || (typeof coords[0] === 'number'))) || coords === null)) {
                        return this.currentSegment$double_A(coords);
                    }
                    else
                        throw new Error('invalid overload');
                };
                QuadIterator.prototype.currentSegment$double_A = function (coords) {
                    if (this.isDone()) {
                        throw Object.defineProperty(new Error("quad iterator iterator out of bounds"), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.Object', 'java.lang.RuntimeException', 'java.util.NoSuchElementException', 'java.lang.Exception'] });
                    }
                    var type;
                    if (this.index === 0) {
                        coords[0] = this.quad.getX1();
                        coords[1] = this.quad.getY1();
                        type = java.awt.geom.PathIterator.SEG_MOVETO;
                    }
                    else {
                        coords[0] = this.quad.getCtrlX();
                        coords[1] = this.quad.getCtrlY();
                        coords[2] = this.quad.getX2();
                        coords[3] = this.quad.getY2();
                        type = java.awt.geom.PathIterator.SEG_QUADTO;
                    }
                    if (this.affine != null) {
                        this.affine.transform$double_A$int$double_A$int$int(coords, 0, coords, 0, this.index === 0 ? 1 : 2);
                    }
                    return type;
                };
                return QuadIterator;
            }());
            geom.QuadIterator = QuadIterator;
            QuadIterator["__class"] = "java.awt.geom.QuadIterator";
            QuadIterator["__interfaces"] = ["java.awt.geom.PathIterator"];
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * <code>RectangularShape</code> is the base class for a number of {@link Shape}
             * objects whose geometry is defined by a rectangular frame. This class does not
             * directly specify any specific geometry by itself, but merely provides
             * manipulation methods inherited by a whole category of <code>Shape</code>
             * objects. The manipulation methods provided by this class can be used to query
             * and modify the rectangular frame, which provides a reference for the
             * subclasses to define their geometry.
             *
             * @author Jim Graham
             * @since 1.2
             * @class
             */
            var RectangularShape = /** @class */ (function () {
                function RectangularShape() {
                }
                /**
                 * Returns the smallest X coordinate of the framing rectangle of the
                 * <code>Shape</code> in <code>double</code> precision.
                 *
                 * @return {number} the smallest X coordinate of the framing rectangle of the
                 * <code>Shape</code>.
                 * @since 1.2
                 */
                RectangularShape.prototype.getMinX = function () {
                    return this.getX();
                };
                /**
                 * Returns the smallest Y coordinate of the framing rectangle of the
                 * <code>Shape</code> in <code>double</code> precision.
                 *
                 * @return {number} the smallest Y coordinate of the framing rectangle of the
                 * <code>Shape</code>.
                 * @since 1.2
                 */
                RectangularShape.prototype.getMinY = function () {
                    return this.getY();
                };
                /**
                 * Returns the largest X coordinate of the framing rectangle of the
                 * <code>Shape</code> in <code>double</code> precision.
                 *
                 * @return {number} the largest X coordinate of the framing rectangle of the
                 * <code>Shape</code>.
                 * @since 1.2
                 */
                RectangularShape.prototype.getMaxX = function () {
                    return this.getX() + this.getWidth();
                };
                /**
                 * Returns the largest Y coordinate of the framing rectangle of the
                 * <code>Shape</code> in <code>double</code> precision.
                 *
                 * @return {number} the largest Y coordinate of the framing rectangle of the
                 * <code>Shape</code>.
                 * @since 1.2
                 */
                RectangularShape.prototype.getMaxY = function () {
                    return this.getY() + this.getHeight();
                };
                /**
                 * Returns the X coordinate of the center of the framing rectangle of the
                 * <code>Shape</code> in <code>double</code> precision.
                 *
                 * @return {number} the X coordinate of the center of the framing rectangle of the
                 * <code>Shape</code>.
                 * @since 1.2
                 */
                RectangularShape.prototype.getCenterX = function () {
                    return this.getX() + this.getWidth() / 2.0;
                };
                /**
                 * Returns the Y coordinate of the center of the framing rectangle of the
                 * <code>Shape</code> in <code>double</code> precision.
                 *
                 * @return {number} the Y coordinate of the center of the framing rectangle of the
                 * <code>Shape</code>.
                 * @since 1.2
                 */
                RectangularShape.prototype.getCenterY = function () {
                    return this.getY() + this.getHeight() / 2.0;
                };
                /**
                 * Returns the framing {@link Rectangle2D} that defines the overall shape of
                 * this object.
                 *
                 * @return {java.awt.geom.Rectangle2D} a <code>Rectangle2D</code>, specified in <code>double</code>
                 * coordinates.
                 * @see #setFrame(double, double, double, double)
                 * @see #setFrame(Point2D, Dimension2D)
                 * @see #setFrame(Rectangle2D)
                 * @since 1.2
                 */
                RectangularShape.prototype.getFrame = function () {
                    return new java.awt.geom.Rectangle2D.Double(this.getX(), this.getY(), this.getWidth(), this.getHeight());
                };
                RectangularShape.prototype.setFrame$double$double$double$double = function (x, y, w, h) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
                /**
                 * Sets the location and size of the framing rectangle of this
                 * <code>Shape</code> to the specified rectangular values.
                 *
                 * @param {number} x
                 * the X coordinate of the upper-left corner of the specified
                 * rectangular shape
                 * @param {number} y
                 * the Y coordinate of the upper-left corner of the specified
                 * rectangular shape
                 * @param {number} w
                 * the width of the specified rectangular shape
                 * @param {number} h
                 * the height of the specified rectangular shape
                 * @see #getFrame
                 * @since 1.2
                 */
                RectangularShape.prototype.setFrame = function (x, y, w, h) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        return this.setFrame$double$double$double$double(x, y, w, h);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && ((y != null && y instanceof java.awt.geom.Dimension2D) || y === null) && w === undefined && h === undefined) {
                        return this.setFrame$java_awt_geom_Point2D$java_awt_geom_Dimension2D(x, y);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.setFrame$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                RectangularShape.prototype.setFrame$java_awt_geom_Point2D$java_awt_geom_Dimension2D = function (loc, size) {
                    this.setFrame$double$double$double$double(loc.getX(), loc.getY(), size.getWidth(), size.getHeight());
                };
                RectangularShape.prototype.setFrame$java_awt_geom_Rectangle2D = function (r) {
                    this.setFrame$double$double$double$double(r.getX(), r.getY(), r.getWidth(), r.getHeight());
                };
                RectangularShape.prototype.setFrameFromDiagonal$double$double$double$double = function (x1, y1, x2, y2) {
                    if (x2 < x1) {
                        var t = x1;
                        x1 = x2;
                        x2 = t;
                    }
                    if (y2 < y1) {
                        var t = y1;
                        y1 = y2;
                        y2 = t;
                    }
                    this.setFrame$double$double$double$double(x1, y1, x2 - x1, y2 - y1);
                };
                /**
                 * Sets the diagonal of the framing rectangle of this <code>Shape</code>
                 * based on the two specified coordinates. The framing rectangle is used by
                 * the subclasses of <code>RectangularShape</code> to define their geometry.
                 *
                 * @param {number} x1
                 * the X coordinate of the start point of the specified diagonal
                 * @param {number} y1
                 * the Y coordinate of the start point of the specified diagonal
                 * @param {number} x2
                 * the X coordinate of the end point of the specified diagonal
                 * @param {number} y2
                 * the Y coordinate of the end point of the specified diagonal
                 * @since 1.2
                 */
                RectangularShape.prototype.setFrameFromDiagonal = function (x1, y1, x2, y2) {
                    if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                        return this.setFrameFromDiagonal$double$double$double$double(x1, y1, x2, y2);
                    }
                    else if (((x1 != null && x1 instanceof java.awt.geom.Point2D) || x1 === null) && ((y1 != null && y1 instanceof java.awt.geom.Point2D) || y1 === null) && x2 === undefined && y2 === undefined) {
                        return this.setFrameFromDiagonal$java_awt_geom_Point2D$java_awt_geom_Point2D(x1, y1);
                    }
                    else
                        throw new Error('invalid overload');
                };
                RectangularShape.prototype.setFrameFromDiagonal$java_awt_geom_Point2D$java_awt_geom_Point2D = function (p1, p2) {
                    this.setFrameFromDiagonal$double$double$double$double(p1.getX(), p1.getY(), p2.getX(), p2.getY());
                };
                RectangularShape.prototype.setFrameFromCenter$double$double$double$double = function (centerX, centerY, cornerX, cornerY) {
                    var halfW = Math.abs(cornerX - centerX);
                    var halfH = Math.abs(cornerY - centerY);
                    this.setFrame$double$double$double$double(centerX - halfW, centerY - halfH, halfW * 2.0, halfH * 2.0);
                };
                /**
                 * Sets the framing rectangle of this <code>Shape</code> based on the
                 * specified center point coordinates and corner point coordinates. The
                 * framing rectangle is used by the subclasses of
                 * <code>RectangularShape</code> to define their geometry.
                 *
                 * @param {number} centerX
                 * the X coordinate of the specified center point
                 * @param {number} centerY
                 * the Y coordinate of the specified center point
                 * @param {number} cornerX
                 * the X coordinate of the specified corner point
                 * @param {number} cornerY
                 * the Y coordinate of the specified corner point
                 * @since 1.2
                 */
                RectangularShape.prototype.setFrameFromCenter = function (centerX, centerY, cornerX, cornerY) {
                    if (((typeof centerX === 'number') || centerX === null) && ((typeof centerY === 'number') || centerY === null) && ((typeof cornerX === 'number') || cornerX === null) && ((typeof cornerY === 'number') || cornerY === null)) {
                        return this.setFrameFromCenter$double$double$double$double(centerX, centerY, cornerX, cornerY);
                    }
                    else if (((centerX != null && centerX instanceof java.awt.geom.Point2D) || centerX === null) && ((centerY != null && centerY instanceof java.awt.geom.Point2D) || centerY === null) && cornerX === undefined && cornerY === undefined) {
                        return this.setFrameFromCenter$java_awt_geom_Point2D$java_awt_geom_Point2D(centerX, centerY);
                    }
                    else
                        throw new Error('invalid overload');
                };
                RectangularShape.prototype.setFrameFromCenter$java_awt_geom_Point2D$java_awt_geom_Point2D = function (center, corner) {
                    this.setFrameFromCenter$double$double$double$double(center.getX(), center.getY(), corner.getX(), corner.getY());
                };
                RectangularShape.prototype.contains$java_awt_geom_Point2D = function (p) {
                    return this['contains$double$double'](p.getX(), p.getY());
                };
                RectangularShape.prototype.intersects$java_awt_geom_Rectangle2D = function (r) {
                    return this['intersects$double$double$double$double'](r.getX(), r.getY(), r.getWidth(), r.getHeight());
                };
                RectangularShape.prototype.contains$java_awt_geom_Rectangle2D = function (r) {
                    return this['contains$double$double$double$double'](r.getX(), r.getY(), r.getWidth(), r.getHeight());
                };
                RectangularShape.prototype.getPathIterator$java_awt_geom_AffineTransform$double = function (at, flatness) {
                    return new java.awt.geom.FlatteningPathIterator(this['getPathIterator$java_awt_geom_AffineTransform'](at), flatness);
                };
                /**
                 * Returns an iterator object that iterates along the <code>Shape</code>
                 * object's boundary and provides access to a flattened view of the outline
                 * of the <code>Shape</code> object's geometry.
                 * <p>
                 * Only SEG_MOVETO, SEG_LINETO, and SEG_CLOSE point types will be returned
                 * by the iterator.
                 * <p>
                 * The amount of subdivision of the curved segments is controlled by the
                 * <code>flatness</code> parameter, which specifies the maximum distance
                 * that any point on the unflattened transformed curve can deviate from the
                 * returned flattened path segments. An optional {@link AffineTransform} can
                 * be specified so that the coordinates returned in the iteration are
                 * transformed accordingly.
                 *
                 * @param {java.awt.geom.AffineTransform} at
                 * an optional <code>AffineTransform</code> to be applied to the
                 * coordinates as they are returned in the iteration, or
                 * <code>null</code> if untransformed coordinates are desired.
                 * @param {number} flatness
                 * the maximum distance that the line segments used to
                 * approximate the curved segments are allowed to deviate from
                 * any point on the original curve
                 * @return {*} a <code>PathIterator</code> object that provides access to the
                 * <code>Shape</code> object's flattened geometry.
                 * @since 1.2
                 */
                RectangularShape.prototype.getPathIterator = function (at, flatness) {
                    if (((at != null && at instanceof java.awt.geom.AffineTransform) || at === null) && ((typeof flatness === 'number') || flatness === null)) {
                        return this.getPathIterator$java_awt_geom_AffineTransform$double(at, flatness);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Creates a new object of the same class and with the same contents as this
                 * object.
                 *
                 * @return {*} a clone of this instance.
                 * @exception OutOfMemoryError
                 * if there is not enough memory.
                 * @see java.lang.Cloneable
                 * @since 1.2
                 */
                RectangularShape.prototype.clone = function () {
                    try {
                        return /* clone */ /* clone */ (function (o) { var clone = Object.create(o); for (var p in o) {
                            if (o.hasOwnProperty(p))
                                clone[p] = o[p];
                        } return clone; })(this);
                    }
                    catch (e) {
                        throw Object.defineProperty(new Error(e.message), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.VirtualMachineError', 'java.lang.InternalError', 'java.lang.Error', 'java.lang.Object'] });
                    }
                    ;
                };
                return RectangularShape;
            }());
            geom.RectangularShape = RectangularShape;
            RectangularShape["__class"] = "java.awt.geom.RectangularShape";
            RectangularShape["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable"];
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * The <code>CubicCurve2D</code> class defines a cubic parametric curve segment
             * in {@code (x,y)} coordinate space.
             * <p>
             * This class is only the abstract superclass for all objects which store a 2D
             * cubic curve segment. The actual storage representation of the coordinates is
             * left to the subclass.
             *
             * @author Jim Graham
             * @since 1.2
             * @class
             */
            var CubicCurve2D = /** @class */ (function () {
                function CubicCurve2D() {
                }
                CubicCurve2D.prototype.setCurve$double$double$double$double$double$double$double$double = function (x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
                /**
                 * Sets the location of the end points and control points of this curve to
                 * the specified double coordinates.
                 *
                 * @param {number} x1
                 * the X coordinate used to set the start point of this
                 * {@code CubicCurve2D}
                 * @param {number} y1
                 * the Y coordinate used to set the start point of this
                 * {@code CubicCurve2D}
                 * @param {number} ctrlx1
                 * the X coordinate used to set the first control point of this
                 * {@code CubicCurve2D}
                 * @param {number} ctrly1
                 * the Y coordinate used to set the first control point of this
                 * {@code CubicCurve2D}
                 * @param {number} ctrlx2
                 * the X coordinate used to set the second control point of this
                 * {@code CubicCurve2D}
                 * @param {number} ctrly2
                 * the Y coordinate used to set the second control point of this
                 * {@code CubicCurve2D}
                 * @param {number} x2
                 * the X coordinate used to set the end point of this
                 * {@code CubicCurve2D}
                 * @param {number} y2
                 * the Y coordinate used to set the end point of this
                 * {@code CubicCurve2D}
                 * @since 1.2
                 */
                CubicCurve2D.prototype.setCurve = function (x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2) {
                    if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx1 === 'number') || ctrlx1 === null) && ((typeof ctrly1 === 'number') || ctrly1 === null) && ((typeof ctrlx2 === 'number') || ctrlx2 === null) && ((typeof ctrly2 === 'number') || ctrly2 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                        return this.setCurve$double$double$double$double$double$double$double$double(x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2);
                    }
                    else if (((x1 != null && x1 instanceof java.awt.geom.Point2D) || x1 === null) && ((y1 != null && y1 instanceof java.awt.geom.Point2D) || y1 === null) && ((ctrlx1 != null && ctrlx1 instanceof java.awt.geom.Point2D) || ctrlx1 === null) && ((ctrly1 != null && ctrly1 instanceof java.awt.geom.Point2D) || ctrly1 === null) && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                        return this.setCurve$java_awt_geom_Point2D$java_awt_geom_Point2D$java_awt_geom_Point2D$java_awt_geom_Point2D(x1, y1, ctrlx1, ctrly1);
                    }
                    else if (((x1 != null && x1 instanceof Array && (x1.length == 0 || x1[0] == null || (typeof x1[0] === 'number'))) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx1 === undefined && ctrly1 === undefined && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                        return this.setCurve$double_A$int(x1, y1);
                    }
                    else if (((x1 != null && x1 instanceof Array && (x1.length == 0 || x1[0] == null || (x1[0] != null && x1[0] instanceof java.awt.geom.Point2D))) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx1 === undefined && ctrly1 === undefined && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                        return this.setCurve$java_awt_geom_Point2D_A$int(x1, y1);
                    }
                    else if (((x1 != null && x1 instanceof java.awt.geom.CubicCurve2D) || x1 === null) && y1 === undefined && ctrlx1 === undefined && ctrly1 === undefined && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                        return this.setCurve$java_awt_geom_CubicCurve2D(x1);
                    }
                    else
                        throw new Error('invalid overload');
                };
                CubicCurve2D.prototype.setCurve$double_A$int = function (coords, offset) {
                    this.setCurve$double$double$double$double$double$double$double$double(coords[offset + 0], coords[offset + 1], coords[offset + 2], coords[offset + 3], coords[offset + 4], coords[offset + 5], coords[offset + 6], coords[offset + 7]);
                };
                CubicCurve2D.prototype.setCurve$java_awt_geom_Point2D$java_awt_geom_Point2D$java_awt_geom_Point2D$java_awt_geom_Point2D = function (p1, cp1, cp2, p2) {
                    this.setCurve$double$double$double$double$double$double$double$double(p1.getX(), p1.getY(), cp1.getX(), cp1.getY(), cp2.getX(), cp2.getY(), p2.getX(), p2.getY());
                };
                CubicCurve2D.prototype.setCurve$java_awt_geom_Point2D_A$int = function (pts, offset) {
                    this.setCurve$double$double$double$double$double$double$double$double(pts[offset + 0].getX(), pts[offset + 0].getY(), pts[offset + 1].getX(), pts[offset + 1].getY(), pts[offset + 2].getX(), pts[offset + 2].getY(), pts[offset + 3].getX(), pts[offset + 3].getY());
                };
                CubicCurve2D.prototype.setCurve$java_awt_geom_CubicCurve2D = function (c) {
                    this.setCurve$double$double$double$double$double$double$double$double(c.getX1(), c.getY1(), c.getCtrlX1(), c.getCtrlY1(), c.getCtrlX2(), c.getCtrlY2(), c.getX2(), c.getY2());
                };
                CubicCurve2D.getFlatnessSq$double$double$double$double$double$double$double$double = function (x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2) {
                    return Math.max(java.awt.geom.Line2D.ptSegDistSq(x1, y1, x2, y2, ctrlx1, ctrly1), java.awt.geom.Line2D.ptSegDistSq(x1, y1, x2, y2, ctrlx2, ctrly2));
                };
                /**
                 * Returns the square of the flatness of the cubic curve specified by the
                 * indicated control points. The flatness is the maximum distance of a
                 * control point from the line connecting the end points.
                 *
                 * @param {number} x1
                 * the X coordinate that specifies the start point of a
                 * {@code CubicCurve2D}
                 * @param {number} y1
                 * the Y coordinate that specifies the start point of a
                 * {@code CubicCurve2D}
                 * @param {number} ctrlx1
                 * the X coordinate that specifies the first control point of a
                 * {@code CubicCurve2D}
                 * @param {number} ctrly1
                 * the Y coordinate that specifies the first control point of a
                 * {@code CubicCurve2D}
                 * @param {number} ctrlx2
                 * the X coordinate that specifies the second control point of a
                 * {@code CubicCurve2D}
                 * @param {number} ctrly2
                 * the Y coordinate that specifies the second control point of a
                 * {@code CubicCurve2D}
                 * @param {number} x2
                 * the X coordinate that specifies the end point of a
                 * {@code CubicCurve2D}
                 * @param {number} y2
                 * the Y coordinate that specifies the end point of a
                 * {@code CubicCurve2D}
                 * @return {number} the square of the flatness of the {@code CubicCurve2D}
                 * represented by the specified coordinates.
                 * @since 1.2
                 */
                CubicCurve2D.getFlatnessSq = function (x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2) {
                    if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx1 === 'number') || ctrlx1 === null) && ((typeof ctrly1 === 'number') || ctrly1 === null) && ((typeof ctrlx2 === 'number') || ctrlx2 === null) && ((typeof ctrly2 === 'number') || ctrly2 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                        return java.awt.geom.CubicCurve2D.getFlatnessSq$double$double$double$double$double$double$double$double(x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2);
                    }
                    else if (((x1 != null && x1 instanceof Array && (x1.length == 0 || x1[0] == null || (typeof x1[0] === 'number'))) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx1 === undefined && ctrly1 === undefined && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                        return java.awt.geom.CubicCurve2D.getFlatnessSq$double_A$int(x1, y1);
                    }
                    else
                        throw new Error('invalid overload');
                };
                CubicCurve2D.getFlatness$double$double$double$double$double$double$double$double = function (x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2) {
                    return Math.sqrt(CubicCurve2D.getFlatnessSq$double$double$double$double$double$double$double$double(x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2));
                };
                /**
                 * Returns the flatness of the cubic curve specified by the indicated
                 * control points. The flatness is the maximum distance of a control point
                 * from the line connecting the end points.
                 *
                 * @param {number} x1
                 * the X coordinate that specifies the start point of a
                 * {@code CubicCurve2D}
                 * @param {number} y1
                 * the Y coordinate that specifies the start point of a
                 * {@code CubicCurve2D}
                 * @param {number} ctrlx1
                 * the X coordinate that specifies the first control point of a
                 * {@code CubicCurve2D}
                 * @param {number} ctrly1
                 * the Y coordinate that specifies the first control point of a
                 * {@code CubicCurve2D}
                 * @param {number} ctrlx2
                 * the X coordinate that specifies the second control point of a
                 * {@code CubicCurve2D}
                 * @param {number} ctrly2
                 * the Y coordinate that specifies the second control point of a
                 * {@code CubicCurve2D}
                 * @param {number} x2
                 * the X coordinate that specifies the end point of a
                 * {@code CubicCurve2D}
                 * @param {number} y2
                 * the Y coordinate that specifies the end point of a
                 * {@code CubicCurve2D}
                 * @return {number} the flatness of the {@code CubicCurve2D} represented by the
                 * specified coordinates.
                 * @since 1.2
                 */
                CubicCurve2D.getFlatness = function (x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2) {
                    if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx1 === 'number') || ctrlx1 === null) && ((typeof ctrly1 === 'number') || ctrly1 === null) && ((typeof ctrlx2 === 'number') || ctrlx2 === null) && ((typeof ctrly2 === 'number') || ctrly2 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                        return java.awt.geom.CubicCurve2D.getFlatness$double$double$double$double$double$double$double$double(x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2);
                    }
                    else if (((x1 != null && x1 instanceof Array && (x1.length == 0 || x1[0] == null || (typeof x1[0] === 'number'))) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx1 === undefined && ctrly1 === undefined && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                        return java.awt.geom.CubicCurve2D.getFlatness$double_A$int(x1, y1);
                    }
                    else
                        throw new Error('invalid overload');
                };
                CubicCurve2D.getFlatnessSq$double_A$int = function (coords, offset) {
                    return CubicCurve2D.getFlatnessSq$double$double$double$double$double$double$double$double(coords[offset + 0], coords[offset + 1], coords[offset + 2], coords[offset + 3], coords[offset + 4], coords[offset + 5], coords[offset + 6], coords[offset + 7]);
                };
                CubicCurve2D.getFlatness$double_A$int = function (coords, offset) {
                    return CubicCurve2D.getFlatness$double$double$double$double$double$double$double$double(coords[offset + 0], coords[offset + 1], coords[offset + 2], coords[offset + 3], coords[offset + 4], coords[offset + 5], coords[offset + 6], coords[offset + 7]);
                };
                /**
                 * Returns the square of the flatness of this curve. The flatness is the
                 * maximum distance of a control point from the line connecting the end
                 * points.
                 *
                 * @return {number} the square of the flatness of this curve.
                 * @since 1.2
                 */
                CubicCurve2D.prototype.getFlatnessSq = function () {
                    return CubicCurve2D.getFlatnessSq$double$double$double$double$double$double$double$double(this.getX1(), this.getY1(), this.getCtrlX1(), this.getCtrlY1(), this.getCtrlX2(), this.getCtrlY2(), this.getX2(), this.getY2());
                };
                /**
                 * Returns the flatness of this curve. The flatness is the maximum distance
                 * of a control point from the line connecting the end points.
                 *
                 * @return {number} the flatness of this curve.
                 * @since 1.2
                 */
                CubicCurve2D.prototype.getFlatness = function () {
                    return CubicCurve2D.getFlatness$double$double$double$double$double$double$double$double(this.getX1(), this.getY1(), this.getCtrlX1(), this.getCtrlY1(), this.getCtrlX2(), this.getCtrlY2(), this.getX2(), this.getY2());
                };
                /**
                 * Subdivides this cubic curve and stores the resulting two subdivided
                 * curves into the left and right curve parameters. Either or both of the
                 * left and right objects may be the same as this object or null.
                 *
                 * @param {java.awt.geom.CubicCurve2D} left
                 * the cubic curve object for storing for the left or first half
                 * of the subdivided curve
                 * @param {java.awt.geom.CubicCurve2D} right
                 * the cubic curve object for storing for the right or second
                 * half of the subdivided curve
                 * @since 1.2
                 */
                CubicCurve2D.prototype.subdivide = function (left, right) {
                    CubicCurve2D.subdivide$java_awt_geom_CubicCurve2D$java_awt_geom_CubicCurve2D$java_awt_geom_CubicCurve2D(this, left, right);
                };
                CubicCurve2D.subdivide$java_awt_geom_CubicCurve2D$java_awt_geom_CubicCurve2D$java_awt_geom_CubicCurve2D = function (src, left, right) {
                    var x1 = src.getX1();
                    var y1 = src.getY1();
                    var ctrlx1 = src.getCtrlX1();
                    var ctrly1 = src.getCtrlY1();
                    var ctrlx2 = src.getCtrlX2();
                    var ctrly2 = src.getCtrlY2();
                    var x2 = src.getX2();
                    var y2 = src.getY2();
                    var centerx = (ctrlx1 + ctrlx2) / 2.0;
                    var centery = (ctrly1 + ctrly2) / 2.0;
                    ctrlx1 = (x1 + ctrlx1) / 2.0;
                    ctrly1 = (y1 + ctrly1) / 2.0;
                    ctrlx2 = (x2 + ctrlx2) / 2.0;
                    ctrly2 = (y2 + ctrly2) / 2.0;
                    var ctrlx12 = (ctrlx1 + centerx) / 2.0;
                    var ctrly12 = (ctrly1 + centery) / 2.0;
                    var ctrlx21 = (ctrlx2 + centerx) / 2.0;
                    var ctrly21 = (ctrly2 + centery) / 2.0;
                    centerx = (ctrlx12 + ctrlx21) / 2.0;
                    centery = (ctrly12 + ctrly21) / 2.0;
                    if (left != null) {
                        left.setCurve$double$double$double$double$double$double$double$double(x1, y1, ctrlx1, ctrly1, ctrlx12, ctrly12, centerx, centery);
                    }
                    if (right != null) {
                        right.setCurve$double$double$double$double$double$double$double$double(centerx, centery, ctrlx21, ctrly21, ctrlx2, ctrly2, x2, y2);
                    }
                };
                CubicCurve2D.subdivide$double_A$int$double_A$int$double_A$int = function (src, srcoff, left, leftoff, right, rightoff) {
                    var x1 = src[srcoff + 0];
                    var y1 = src[srcoff + 1];
                    var ctrlx1 = src[srcoff + 2];
                    var ctrly1 = src[srcoff + 3];
                    var ctrlx2 = src[srcoff + 4];
                    var ctrly2 = src[srcoff + 5];
                    var x2 = src[srcoff + 6];
                    var y2 = src[srcoff + 7];
                    if (left != null) {
                        left[leftoff + 0] = x1;
                        left[leftoff + 1] = y1;
                    }
                    if (right != null) {
                        right[rightoff + 6] = x2;
                        right[rightoff + 7] = y2;
                    }
                    x1 = (x1 + ctrlx1) / 2.0;
                    y1 = (y1 + ctrly1) / 2.0;
                    x2 = (x2 + ctrlx2) / 2.0;
                    y2 = (y2 + ctrly2) / 2.0;
                    var centerx = (ctrlx1 + ctrlx2) / 2.0;
                    var centery = (ctrly1 + ctrly2) / 2.0;
                    ctrlx1 = (x1 + centerx) / 2.0;
                    ctrly1 = (y1 + centery) / 2.0;
                    ctrlx2 = (x2 + centerx) / 2.0;
                    ctrly2 = (y2 + centery) / 2.0;
                    centerx = (ctrlx1 + ctrlx2) / 2.0;
                    centery = (ctrly1 + ctrly2) / 2.0;
                    if (left != null) {
                        left[leftoff + 2] = x1;
                        left[leftoff + 3] = y1;
                        left[leftoff + 4] = ctrlx1;
                        left[leftoff + 5] = ctrly1;
                        left[leftoff + 6] = centerx;
                        left[leftoff + 7] = centery;
                    }
                    if (right != null) {
                        right[rightoff + 0] = centerx;
                        right[rightoff + 1] = centery;
                        right[rightoff + 2] = ctrlx2;
                        right[rightoff + 3] = ctrly2;
                        right[rightoff + 4] = x2;
                        right[rightoff + 5] = y2;
                    }
                };
                /**
                 * Subdivides the cubic curve specified by the coordinates stored in the
                 * <code>src</code> array at indices <code>srcoff</code> through (
                 * <code>srcoff</code>&nbsp;+&nbsp;7) and stores the resulting two
                 * subdivided curves into the two result arrays at the corresponding
                 * indices. Either or both of the <code>left</code> and <code>right</code>
                 * arrays may be <code>null</code> or a reference to the same array as the
                 * <code>src</code> array. Note that the last point in the first subdivided
                 * curve is the same as the first point in the second subdivided curve.
                 * Thus, it is possible to pass the same array for <code>left</code> and
                 * <code>right</code> and to use offsets, such as <code>rightoff</code>
                 * equals (<code>leftoff</code> + 6), in order to avoid allocating extra
                 * storage for this common point.
                 *
                 * @param {Array} src
                 * the array holding the coordinates for the source curve
                 * @param {number} srcoff
                 * the offset into the array of the beginning of the the 6 source
                 * coordinates
                 * @param {Array} left
                 * the array for storing the coordinates for the first half of
                 * the subdivided curve
                 * @param {number} leftoff
                 * the offset into the array of the beginning of the the 6 left
                 * coordinates
                 * @param {Array} right
                 * the array for storing the coordinates for the second half of
                 * the subdivided curve
                 * @param {number} rightoff
                 * the offset into the array of the beginning of the the 6 right
                 * coordinates
                 * @since 1.2
                 */
                CubicCurve2D.subdivide = function (src, srcoff, left, leftoff, right, rightoff) {
                    if (((src != null && src instanceof Array && (src.length == 0 || src[0] == null || (typeof src[0] === 'number'))) || src === null) && ((typeof srcoff === 'number') || srcoff === null) && ((left != null && left instanceof Array && (left.length == 0 || left[0] == null || (typeof left[0] === 'number'))) || left === null) && ((typeof leftoff === 'number') || leftoff === null) && ((right != null && right instanceof Array && (right.length == 0 || right[0] == null || (typeof right[0] === 'number'))) || right === null) && ((typeof rightoff === 'number') || rightoff === null)) {
                        return java.awt.geom.CubicCurve2D.subdivide$double_A$int$double_A$int$double_A$int(src, srcoff, left, leftoff, right, rightoff);
                    }
                    else if (((src != null && src instanceof java.awt.geom.CubicCurve2D) || src === null) && ((srcoff != null && srcoff instanceof java.awt.geom.CubicCurve2D) || srcoff === null) && ((left != null && left instanceof java.awt.geom.CubicCurve2D) || left === null) && leftoff === undefined && right === undefined && rightoff === undefined) {
                        return java.awt.geom.CubicCurve2D.subdivide$java_awt_geom_CubicCurve2D$java_awt_geom_CubicCurve2D$java_awt_geom_CubicCurve2D(src, srcoff, left);
                    }
                    else
                        throw new Error('invalid overload');
                };
                CubicCurve2D.solveCubic$double_A = function (eqn) {
                    return CubicCurve2D.solveCubic$double_A$double_A(eqn, eqn);
                };
                CubicCurve2D.solveCubic$double_A$double_A = function (eqn, res) {
                    var d = eqn[3];
                    if (d === 0) {
                        return java.awt.geom.QuadCurve2D.solveQuadratic$double_A$double_A(eqn, res);
                    }
                    var A = eqn[2] / d;
                    var B = eqn[1] / d;
                    var C = eqn[0] / d;
                    var sq_A = A * A;
                    var p = 1.0 / 3 * (-1.0 / 3 * sq_A + B);
                    var q = 1.0 / 2 * (2.0 / 27 * A * sq_A - 1.0 / 3 * A * B + C);
                    var cb_p = p * p * p;
                    var D = q * q + cb_p;
                    var sub = 1.0 / 3 * A;
                    var num;
                    if (D < 0) {
                        var phi = 1.0 / 3 * Math.acos(-q / Math.sqrt(-cb_p));
                        var t = 2 * Math.sqrt(-p);
                        if (res === eqn) {
                            eqn = /* copyOf */ eqn.slice(0, 4);
                        }
                        res[0] = (t * Math.cos(phi));
                        res[1] = (-t * Math.cos(phi + Math.PI / 3));
                        res[2] = (-t * Math.cos(phi - Math.PI / 3));
                        num = 3;
                        for (var i = 0; i < num; ++i) {
                            {
                                res[i] -= sub;
                            }
                            ;
                        }
                    }
                    else {
                        var sqrt_D = Math.sqrt(D);
                        var u = Math.pow(sqrt_D - q, 1 / 3);
                        var v = -Math.pow(sqrt_D + q, 1 / 3);
                        var uv = u + v;
                        num = 1;
                        var err = 1200000000 * /* ulp */ (function (x) { var buffer = new ArrayBuffer(8); var dataView = new DataView(buffer); dataView.setFloat64(0, x); var first = dataView.getUint32(0); var second = dataView.getUint32(4); var rawExponent = first & 0x7ff00000; if (rawExponent == 0x7ff00000) {
                            dataView.setUint32(0, first & 0x7fffffff);
                        }
                        else if (rawExponent == 0) {
                            dataView.setUint32(4, 1);
                            dataView.setUint32(0, 0);
                        }
                        else if (rawExponent >= (52 << 20) + 0x00100000) {
                            dataView.setUint32(0, rawExponent - (52 << 20));
                            dataView.setUint32(4, 0);
                        }
                        else if (rawExponent >= (33 << 20)) {
                            dataView.setUint32(0, 1 << ((rawExponent - (33 << 20)) >>> 20));
                            dataView.setUint32(4, 0);
                        }
                        else {
                            dataView.setUint32(4, 1 << ((rawExponent - 0x00100000) >>> 20));
                            dataView.setUint32(0, 0);
                        } return dataView.getFloat64(0); })(Math.abs(uv) + Math.abs(sub));
                        if (CubicCurve2D.iszero(D, err) || CubicCurve2D.within(u, v, err)) {
                            if (res === eqn) {
                                eqn = /* copyOf */ eqn.slice(0, 4);
                            }
                            res[1] = -(uv / 2) - sub;
                            num = 2;
                        }
                        res[0] = uv - sub;
                    }
                    if (num > 1) {
                        num = CubicCurve2D.fixRoots(eqn, res, num);
                    }
                    if (num > 2 && (res[2] === res[1] || res[2] === res[0])) {
                        num--;
                    }
                    if (num > 1 && res[1] === res[0]) {
                        res[1] = res[--num];
                    }
                    return num;
                };
                /**
                 * Solve the cubic whose coefficients are in the <code>eqn</code> array and
                 * place the non-complex roots into the <code>res</code> array, returning
                 * the number of roots. The cubic solved is represented by the equation: eqn
                 * = {c, b, a, d} dx^3 + ax^2 + bx + c = 0 A return value of -1 is used to
                 * distinguish a constant equation, which may be always 0 or never 0, from
                 * an equation which has no zeroes.
                 *
                 * @param {Array} eqn
                 * the specified array of coefficients to use to solve the cubic
                 * equation
                 * @param {Array} res
                 * the array that contains the non-complex roots resulting from
                 * the solution of the cubic equation
                 * @return {number} the number of roots, or -1 if the equation is a constant
                 * @since 1.3
                 */
                CubicCurve2D.solveCubic = function (eqn, res) {
                    if (((eqn != null && eqn instanceof Array && (eqn.length == 0 || eqn[0] == null || (typeof eqn[0] === 'number'))) || eqn === null) && ((res != null && res instanceof Array && (res.length == 0 || res[0] == null || (typeof res[0] === 'number'))) || res === null)) {
                        return java.awt.geom.CubicCurve2D.solveCubic$double_A$double_A(eqn, res);
                    }
                    else if (((eqn != null && eqn instanceof Array && (eqn.length == 0 || eqn[0] == null || (typeof eqn[0] === 'number'))) || eqn === null) && res === undefined) {
                        return java.awt.geom.CubicCurve2D.solveCubic$double_A(eqn);
                    }
                    else
                        throw new Error('invalid overload');
                };
                CubicCurve2D.fixRoots = function (eqn, res, num) {
                    var intervals = [eqn[1], 2 * eqn[2], 3 * eqn[3]];
                    var critCount = java.awt.geom.QuadCurve2D.solveQuadratic$double_A$double_A(intervals, intervals);
                    if (critCount === 2 && intervals[0] === intervals[1]) {
                        critCount--;
                    }
                    if (critCount === 2 && intervals[0] > intervals[1]) {
                        var tmp = intervals[0];
                        intervals[0] = intervals[1];
                        intervals[1] = tmp;
                    }
                    if (num === 3) {
                        var xe = CubicCurve2D.getRootUpperBound(eqn);
                        var x0 = -xe;
                        /* sort */ (function (arr, start, end, f) { return (function (arr1, arr2) { return arr1.splice.apply(arr1, [start, arr2.length].concat(arr2)); })(res, res.slice(start, end).sort(f)); })(res, 0, num);
                        if (critCount === 2) {
                            res[0] = CubicCurve2D.refineRootWithHint(eqn, x0, intervals[0], res[0]);
                            res[1] = CubicCurve2D.refineRootWithHint(eqn, intervals[0], intervals[1], res[1]);
                            res[2] = CubicCurve2D.refineRootWithHint(eqn, intervals[1], xe, res[2]);
                            return 3;
                        }
                        else if (critCount === 1) {
                            var fxe = eqn[3];
                            var fx0 = -fxe;
                            var x1 = intervals[0];
                            var fx1 = CubicCurve2D.solveEqn(eqn, 3, x1);
                            if (CubicCurve2D.oppositeSigns(fx0, fx1)) {
                                res[0] = CubicCurve2D.bisectRootWithHint(eqn, x0, x1, res[0]);
                            }
                            else if (CubicCurve2D.oppositeSigns(fx1, fxe)) {
                                res[0] = CubicCurve2D.bisectRootWithHint(eqn, x1, xe, res[2]);
                            }
                            else {
                                res[0] = x1;
                            }
                        }
                        else if (critCount === 0) {
                            res[0] = CubicCurve2D.bisectRootWithHint(eqn, x0, xe, res[1]);
                        }
                    }
                    else if (num === 2 && critCount === 2) {
                        var goodRoot = res[0];
                        var badRoot = res[1];
                        var x1 = intervals[0];
                        var x2 = intervals[1];
                        var x = Math.abs(x1 - goodRoot) > Math.abs(x2 - goodRoot) ? x1 : x2;
                        var fx = CubicCurve2D.solveEqn(eqn, 3, x);
                        if (CubicCurve2D.iszero(fx, 10000000 * /* ulp */ (function (x) { var buffer = new ArrayBuffer(8); var dataView = new DataView(buffer); dataView.setFloat64(0, x); var first = dataView.getUint32(0); var second = dataView.getUint32(4); var rawExponent = first & 0x7ff00000; if (rawExponent == 0x7ff00000) {
                            dataView.setUint32(0, first & 0x7fffffff);
                        }
                        else if (rawExponent == 0) {
                            dataView.setUint32(4, 1);
                            dataView.setUint32(0, 0);
                        }
                        else if (rawExponent >= (52 << 20) + 0x00100000) {
                            dataView.setUint32(0, rawExponent - (52 << 20));
                            dataView.setUint32(4, 0);
                        }
                        else if (rawExponent >= (33 << 20)) {
                            dataView.setUint32(0, 1 << ((rawExponent - (33 << 20)) >>> 20));
                            dataView.setUint32(4, 0);
                        }
                        else {
                            dataView.setUint32(4, 1 << ((rawExponent - 0x00100000) >>> 20));
                            dataView.setUint32(0, 0);
                        } return dataView.getFloat64(0); })(x))) {
                            var badRootVal = CubicCurve2D.solveEqn(eqn, 3, badRoot);
                            res[1] = Math.abs(badRootVal) < Math.abs(fx) ? badRoot : x;
                            return 2;
                        }
                    }
                    return 1;
                };
                CubicCurve2D.refineRootWithHint = function (eqn, min, max, t) {
                    if (!CubicCurve2D.inInterval(t, min, max)) {
                        return t;
                    }
                    var deriv = [eqn[1], 2 * eqn[2], 3 * eqn[3]];
                    var origt = t;
                    for (var i = 0; i < 3; i++) {
                        {
                            var slope = CubicCurve2D.solveEqn(deriv, 2, t);
                            var y = CubicCurve2D.solveEqn(eqn, 3, t);
                            var delta = -(y / slope);
                            var newt = t + delta;
                            if (slope === 0 || y === 0 || t === newt) {
                                break;
                            }
                            t = newt;
                        }
                        ;
                    }
                    if (CubicCurve2D.within(t, origt, 1000 * /* ulp */ (function (x) { var buffer = new ArrayBuffer(8); var dataView = new DataView(buffer); dataView.setFloat64(0, x); var first = dataView.getUint32(0); var second = dataView.getUint32(4); var rawExponent = first & 0x7ff00000; if (rawExponent == 0x7ff00000) {
                        dataView.setUint32(0, first & 0x7fffffff);
                    }
                    else if (rawExponent == 0) {
                        dataView.setUint32(4, 1);
                        dataView.setUint32(0, 0);
                    }
                    else if (rawExponent >= (52 << 20) + 0x00100000) {
                        dataView.setUint32(0, rawExponent - (52 << 20));
                        dataView.setUint32(4, 0);
                    }
                    else if (rawExponent >= (33 << 20)) {
                        dataView.setUint32(0, 1 << ((rawExponent - (33 << 20)) >>> 20));
                        dataView.setUint32(4, 0);
                    }
                    else {
                        dataView.setUint32(4, 1 << ((rawExponent - 0x00100000) >>> 20));
                        dataView.setUint32(0, 0);
                    } return dataView.getFloat64(0); })(origt)) && CubicCurve2D.inInterval(t, min, max)) {
                        return t;
                    }
                    return origt;
                };
                CubicCurve2D.bisectRootWithHint = function (eqn, x0, xe, hint) {
                    var delta1 = Math.min(Math.abs(hint - x0) / 64, 0.0625);
                    var delta2 = Math.min(Math.abs(hint - xe) / 64, 0.0625);
                    var x02 = hint - delta1;
                    var xe2 = hint + delta2;
                    var fx02 = CubicCurve2D.solveEqn(eqn, 3, x02);
                    var fxe2 = CubicCurve2D.solveEqn(eqn, 3, xe2);
                    while ((CubicCurve2D.oppositeSigns(fx02, fxe2))) {
                        {
                            if (x02 >= xe2) {
                                return x02;
                            }
                            x0 = x02;
                            xe = xe2;
                            delta1 /= 64;
                            delta2 /= 64;
                            x02 = hint - delta1;
                            xe2 = hint + delta2;
                            fx02 = CubicCurve2D.solveEqn(eqn, 3, x02);
                            fxe2 = CubicCurve2D.solveEqn(eqn, 3, xe2);
                        }
                    }
                    ;
                    if (fx02 === 0) {
                        return x02;
                    }
                    if (fxe2 === 0) {
                        return xe2;
                    }
                    return CubicCurve2D.bisectRoot(eqn, x0, xe);
                };
                CubicCurve2D.bisectRoot = function (eqn, x0, xe) {
                    var fx0 = CubicCurve2D.solveEqn(eqn, 3, x0);
                    var m = x0 + (xe - x0) / 2;
                    while ((m !== x0 && m !== xe)) {
                        {
                            var fm = CubicCurve2D.solveEqn(eqn, 3, m);
                            if (fm === 0) {
                                return m;
                            }
                            if (CubicCurve2D.oppositeSigns(fx0, fm)) {
                                xe = m;
                            }
                            else {
                                fx0 = fm;
                                x0 = m;
                            }
                            m = x0 + (xe - x0) / 2;
                        }
                    }
                    ;
                    return m;
                };
                CubicCurve2D.inInterval = function (t, min, max) {
                    return min <= t && t <= max;
                };
                CubicCurve2D.within = function (x, y, err) {
                    var d = y - x;
                    return (d <= err && d >= -err);
                };
                CubicCurve2D.iszero = function (x, err) {
                    return CubicCurve2D.within(x, 0, err);
                };
                CubicCurve2D.oppositeSigns = function (x1, x2) {
                    return (x1 < 0 && x2 > 0) || (x1 > 0 && x2 < 0);
                };
                CubicCurve2D.solveEqn = function (eqn, order, t) {
                    var v = eqn[order];
                    while ((--order >= 0)) {
                        {
                            v = v * t + eqn[order];
                        }
                    }
                    ;
                    return v;
                };
                CubicCurve2D.getRootUpperBound = function (eqn) {
                    var d = eqn[3];
                    var a = eqn[2];
                    var b = eqn[1];
                    var c = eqn[0];
                    var M = 1 + Math.max(Math.max(Math.abs(a), Math.abs(b)), Math.abs(c)) / Math.abs(d);
                    M += /* ulp */ (function (x) { var buffer = new ArrayBuffer(8); var dataView = new DataView(buffer); dataView.setFloat64(0, x); var first = dataView.getUint32(0); var second = dataView.getUint32(4); var rawExponent = first & 0x7ff00000; if (rawExponent == 0x7ff00000) {
                        dataView.setUint32(0, first & 0x7fffffff);
                    }
                    else if (rawExponent == 0) {
                        dataView.setUint32(4, 1);
                        dataView.setUint32(0, 0);
                    }
                    else if (rawExponent >= (52 << 20) + 0x00100000) {
                        dataView.setUint32(0, rawExponent - (52 << 20));
                        dataView.setUint32(4, 0);
                    }
                    else if (rawExponent >= (33 << 20)) {
                        dataView.setUint32(0, 1 << ((rawExponent - (33 << 20)) >>> 20));
                        dataView.setUint32(4, 0);
                    }
                    else {
                        dataView.setUint32(4, 1 << ((rawExponent - 0x00100000) >>> 20));
                        dataView.setUint32(0, 0);
                    } return dataView.getFloat64(0); })(M) + 1;
                    return M;
                };
                CubicCurve2D.prototype.contains$double$double = function (x, y) {
                    if (!(x * 0.0 + y * 0.0 === 0.0)) {
                        return false;
                    }
                    var x1 = this.getX1();
                    var y1 = this.getY1();
                    var x2 = this.getX2();
                    var y2 = this.getY2();
                    var crossings = (sun.awt.geom.Curve.pointCrossingsForLine(x, y, x1, y1, x2, y2) + sun.awt.geom.Curve.pointCrossingsForCubic(x, y, x1, y1, this.getCtrlX1(), this.getCtrlY1(), this.getCtrlX2(), this.getCtrlY2(), x2, y2, 0));
                    return ((crossings & 1) === 1);
                };
                CubicCurve2D.prototype.contains$java_awt_geom_Point2D = function (p) {
                    return this.contains$double$double(p.getX(), p.getY());
                };
                CubicCurve2D.prototype.intersects$double$double$double$double = function (x, y, w, h) {
                    if (w <= 0 || h <= 0) {
                        return false;
                    }
                    var numCrossings = this.rectCrossings(x, y, w, h);
                    return numCrossings !== 0;
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 * @param {number} x
                 * @param {number} y
                 * @param {number} w
                 * @param {number} h
                 * @return {boolean}
                 */
                CubicCurve2D.prototype.intersects = function (x, y, w, h) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        return this.intersects$double$double$double$double(x, y, w, h);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.intersects$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                CubicCurve2D.prototype.intersects$java_awt_geom_Rectangle2D = function (r) {
                    return this.intersects$double$double$double$double(r.getX(), r.getY(), r.getWidth(), r.getHeight());
                };
                CubicCurve2D.prototype.contains$double$double$double$double = function (x, y, w, h) {
                    if (w <= 0 || h <= 0) {
                        return false;
                    }
                    var numCrossings = this.rectCrossings(x, y, w, h);
                    return !(numCrossings === 0 || numCrossings === sun.awt.geom.Curve.RECT_INTERSECTS);
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 * @param {number} x
                 * @param {number} y
                 * @param {number} w
                 * @param {number} h
                 * @return {boolean}
                 */
                CubicCurve2D.prototype.contains = function (x, y, w, h) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        return this.contains$double$double$double$double(x, y, w, h);
                    }
                    else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && w === undefined && h === undefined) {
                        return this.contains$double$double(x, y);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.contains$java_awt_geom_Point2D(x);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.contains$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                CubicCurve2D.prototype.rectCrossings = function (x, y, w, h) {
                    var crossings = 0;
                    if (!(this.getX1() === this.getX2() && this.getY1() === this.getY2())) {
                        crossings = sun.awt.geom.Curve.rectCrossingsForLine(crossings, x, y, x + w, y + h, this.getX1(), this.getY1(), this.getX2(), this.getY2());
                        if (crossings === sun.awt.geom.Curve.RECT_INTERSECTS) {
                            return crossings;
                        }
                    }
                    return sun.awt.geom.Curve.rectCrossingsForCubic(crossings, x, y, x + w, y + h, this.getX2(), this.getY2(), this.getCtrlX2(), this.getCtrlY2(), this.getCtrlX1(), this.getCtrlY1(), this.getX1(), this.getY1(), 0);
                };
                CubicCurve2D.prototype.contains$java_awt_geom_Rectangle2D = function (r) {
                    return this.contains$double$double$double$double(r.getX(), r.getY(), r.getWidth(), r.getHeight());
                };
                CubicCurve2D.prototype.getPathIterator$java_awt_geom_AffineTransform = function (at) {
                    return new java.awt.geom.CubicIterator(this, at);
                };
                CubicCurve2D.prototype.getPathIterator$java_awt_geom_AffineTransform$double = function (at, flatness) {
                    return new java.awt.geom.FlatteningPathIterator(this.getPathIterator$java_awt_geom_AffineTransform(at), flatness);
                };
                /**
                 * Return an iteration object that defines the boundary of the flattened
                 * shape. The iterator for this class is not multi-threaded safe, which
                 * means that this <code>CubicCurve2D</code> class does not guarantee that
                 * modifications to the geometry of this <code>CubicCurve2D</code> object do
                 * not affect any iterations of that geometry that are already in process.
                 *
                 * @param {java.awt.geom.AffineTransform} at
                 * an optional <code>AffineTransform</code> to be applied to the
                 * coordinates as they are returned in the iteration, or
                 * <code>null</code> if untransformed coordinates are desired
                 * @param {number} flatness
                 * the maximum amount that the control points for a given curve
                 * can vary from colinear before a subdivided curve is replaced
                 * by a straight line connecting the end points
                 * @return {*} the <code>PathIterator</code> object that returns the geometry of
                 * the outline of this <code>CubicCurve2D</code>, one segment at a
                 * time.
                 * @since 1.2
                 */
                CubicCurve2D.prototype.getPathIterator = function (at, flatness) {
                    if (((at != null && at instanceof java.awt.geom.AffineTransform) || at === null) && ((typeof flatness === 'number') || flatness === null)) {
                        return this.getPathIterator$java_awt_geom_AffineTransform$double(at, flatness);
                    }
                    else if (((at != null && at instanceof java.awt.geom.AffineTransform) || at === null) && flatness === undefined) {
                        return this.getPathIterator$java_awt_geom_AffineTransform(at);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Creates a new object of the same class as this object.
                 *
                 * @return {*} a clone of this instance.
                 * @exception OutOfMemoryError
                 * if there is not enough memory.
                 * @see java.lang.Cloneable
                 * @since 1.2
                 */
                CubicCurve2D.prototype.clone = function () {
                    try {
                        return /* clone */ /* clone */ (function (o) { var clone = Object.create(o); for (var p in o) {
                            if (o.hasOwnProperty(p))
                                clone[p] = o[p];
                        } return clone; })(this);
                    }
                    catch (e) {
                        throw Object.defineProperty(new Error(e.message), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.VirtualMachineError', 'java.lang.InternalError', 'java.lang.Error', 'java.lang.Object'] });
                    }
                    ;
                };
                return CubicCurve2D;
            }());
            geom.CubicCurve2D = CubicCurve2D;
            CubicCurve2D["__class"] = "java.awt.geom.CubicCurve2D";
            CubicCurve2D["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable"];
            (function (CubicCurve2D) {
                /**
                 * Constructs and initializes a {@code CubicCurve2D} from the specified
                 * {@code float} coordinates.
                 *
                 * @param {number} x1
                 * the X coordinate for the start point of the resulting
                 * {@code CubicCurve2D}
                 * @param {number} y1
                 * the Y coordinate for the start point of the resulting
                 * {@code CubicCurve2D}
                 * @param {number} ctrlx1
                 * the X coordinate for the first control point of the
                 * resulting {@code CubicCurve2D}
                 * @param {number} ctrly1
                 * the Y coordinate for the first control point of the
                 * resulting {@code CubicCurve2D}
                 * @param {number} ctrlx2
                 * the X coordinate for the second control point of the
                 * resulting {@code CubicCurve2D}
                 * @param {number} ctrly2
                 * the Y coordinate for the second control point of the
                 * resulting {@code CubicCurve2D}
                 * @param {number} x2
                 * the X coordinate for the end point of the resulting
                 * {@code CubicCurve2D}
                 * @param {number} y2
                 * the Y coordinate for the end point of the resulting
                 * {@code CubicCurve2D}
                 * @since 1.2
                 * @class
                 * @extends java.awt.geom.CubicCurve2D
                 */
                var Float = /** @class */ (function (_super) {
                    __extends(Float, _super);
                    function Float(x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2) {
                        var _this = this;
                        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx1 === 'number') || ctrlx1 === null) && ((typeof ctrly1 === 'number') || ctrly1 === null) && ((typeof ctrlx2 === 'number') || ctrlx2 === null) && ((typeof ctrly2 === 'number') || ctrly2 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                            var __args = arguments;
                            _this = _super.call(this) || this;
                            if (_this.x1 === undefined)
                                _this.x1 = 0;
                            if (_this.y1 === undefined)
                                _this.y1 = 0;
                            if (_this.ctrlx1 === undefined)
                                _this.ctrlx1 = 0;
                            if (_this.ctrly1 === undefined)
                                _this.ctrly1 = 0;
                            if (_this.ctrlx2 === undefined)
                                _this.ctrlx2 = 0;
                            if (_this.ctrly2 === undefined)
                                _this.ctrly2 = 0;
                            if (_this.x2 === undefined)
                                _this.x2 = 0;
                            if (_this.y2 === undefined)
                                _this.y2 = 0;
                            if (_this.x1 === undefined)
                                _this.x1 = 0;
                            if (_this.y1 === undefined)
                                _this.y1 = 0;
                            if (_this.ctrlx1 === undefined)
                                _this.ctrlx1 = 0;
                            if (_this.ctrly1 === undefined)
                                _this.ctrly1 = 0;
                            if (_this.ctrlx2 === undefined)
                                _this.ctrlx2 = 0;
                            if (_this.ctrly2 === undefined)
                                _this.ctrly2 = 0;
                            if (_this.x2 === undefined)
                                _this.x2 = 0;
                            if (_this.y2 === undefined)
                                _this.y2 = 0;
                            (function () {
                                _this.setCurve$float$float$float$float$float$float$float$float(x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2);
                            })();
                        }
                        else if (x1 === undefined && y1 === undefined && ctrlx1 === undefined && ctrly1 === undefined && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                            var __args = arguments;
                            _this = _super.call(this) || this;
                            if (_this.x1 === undefined)
                                _this.x1 = 0;
                            if (_this.y1 === undefined)
                                _this.y1 = 0;
                            if (_this.ctrlx1 === undefined)
                                _this.ctrlx1 = 0;
                            if (_this.ctrly1 === undefined)
                                _this.ctrly1 = 0;
                            if (_this.ctrlx2 === undefined)
                                _this.ctrlx2 = 0;
                            if (_this.ctrly2 === undefined)
                                _this.ctrly2 = 0;
                            if (_this.x2 === undefined)
                                _this.x2 = 0;
                            if (_this.y2 === undefined)
                                _this.y2 = 0;
                            if (_this.x1 === undefined)
                                _this.x1 = 0;
                            if (_this.y1 === undefined)
                                _this.y1 = 0;
                            if (_this.ctrlx1 === undefined)
                                _this.ctrlx1 = 0;
                            if (_this.ctrly1 === undefined)
                                _this.ctrly1 = 0;
                            if (_this.ctrlx2 === undefined)
                                _this.ctrlx2 = 0;
                            if (_this.ctrly2 === undefined)
                                _this.ctrly2 = 0;
                            if (_this.x2 === undefined)
                                _this.x2 = 0;
                            if (_this.y2 === undefined)
                                _this.y2 = 0;
                        }
                        else
                            throw new Error('invalid overload');
                        return _this;
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Float.prototype.getX1 = function () {
                        return this.x1;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Float.prototype.getY1 = function () {
                        return this.y1;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {java.awt.geom.Point2D}
                     */
                    Float.prototype.getP1 = function () {
                        return new java.awt.geom.Point2D.Float(this.x1, this.y1);
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Float.prototype.getCtrlX1 = function () {
                        return this.ctrlx1;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Float.prototype.getCtrlY1 = function () {
                        return this.ctrly1;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {java.awt.geom.Point2D}
                     */
                    Float.prototype.getCtrlP1 = function () {
                        return new java.awt.geom.Point2D.Float(this.ctrlx1, this.ctrly1);
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Float.prototype.getCtrlX2 = function () {
                        return this.ctrlx2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Float.prototype.getCtrlY2 = function () {
                        return this.ctrly2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {java.awt.geom.Point2D}
                     */
                    Float.prototype.getCtrlP2 = function () {
                        return new java.awt.geom.Point2D.Float(this.ctrlx2, this.ctrly2);
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Float.prototype.getX2 = function () {
                        return this.x2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Float.prototype.getY2 = function () {
                        return this.y2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {java.awt.geom.Point2D}
                     */
                    Float.prototype.getP2 = function () {
                        return new java.awt.geom.Point2D.Float(this.x2, this.y2);
                    };
                    Float.prototype.setCurve$double$double$double$double$double$double$double$double = function (x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2) {
                        this.x1 = x1;
                        this.y1 = y1;
                        this.ctrlx1 = ctrlx1;
                        this.ctrly1 = ctrly1;
                        this.ctrlx2 = ctrlx2;
                        this.ctrly2 = ctrly2;
                        this.x2 = x2;
                        this.y2 = y2;
                    };
                    Float.prototype.setCurve$float$float$float$float$float$float$float$float = function (x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2) {
                        this.x1 = x1;
                        this.y1 = y1;
                        this.ctrlx1 = ctrlx1;
                        this.ctrly1 = ctrly1;
                        this.ctrlx2 = ctrlx2;
                        this.ctrly2 = ctrly2;
                        this.x2 = x2;
                        this.y2 = y2;
                    };
                    /**
                     * Sets the location of the end points and control points of this curve
                     * to the specified {@code float} coordinates.
                     *
                     * @param {number} x1
                     * the X coordinate used to set the start point of this
                     * {@code CubicCurve2D}
                     * @param {number} y1
                     * the Y coordinate used to set the start point of this
                     * {@code CubicCurve2D}
                     * @param {number} ctrlx1
                     * the X coordinate used to set the first control point of
                     * this {@code CubicCurve2D}
                     * @param {number} ctrly1
                     * the Y coordinate used to set the first control point of
                     * this {@code CubicCurve2D}
                     * @param {number} ctrlx2
                     * the X coordinate used to set the second control point of
                     * this {@code CubicCurve2D}
                     * @param {number} ctrly2
                     * the Y coordinate used to set the second control point of
                     * this {@code CubicCurve2D}
                     * @param {number} x2
                     * the X coordinate used to set the end point of this
                     * {@code CubicCurve2D}
                     * @param {number} y2
                     * the Y coordinate used to set the end point of this
                     * {@code CubicCurve2D}
                     * @since 1.2
                     */
                    Float.prototype.setCurve = function (x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2) {
                        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx1 === 'number') || ctrlx1 === null) && ((typeof ctrly1 === 'number') || ctrly1 === null) && ((typeof ctrlx2 === 'number') || ctrlx2 === null) && ((typeof ctrly2 === 'number') || ctrly2 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                            return this.setCurve$float$float$float$float$float$float$float$float(x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2);
                        }
                        else if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx1 === 'number') || ctrlx1 === null) && ((typeof ctrly1 === 'number') || ctrly1 === null) && ((typeof ctrlx2 === 'number') || ctrlx2 === null) && ((typeof ctrly2 === 'number') || ctrly2 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                            return this.setCurve$double$double$double$double$double$double$double$double(x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2);
                        }
                        else if (((x1 != null && x1 instanceof java.awt.geom.Point2D) || x1 === null) && ((y1 != null && y1 instanceof java.awt.geom.Point2D) || y1 === null) && ((ctrlx1 != null && ctrlx1 instanceof java.awt.geom.Point2D) || ctrlx1 === null) && ((ctrly1 != null && ctrly1 instanceof java.awt.geom.Point2D) || ctrly1 === null) && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                            return this.setCurve$java_awt_geom_Point2D$java_awt_geom_Point2D$java_awt_geom_Point2D$java_awt_geom_Point2D(x1, y1, ctrlx1, ctrly1);
                        }
                        else if (((x1 != null && x1 instanceof Array && (x1.length == 0 || x1[0] == null || (typeof x1[0] === 'number'))) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx1 === undefined && ctrly1 === undefined && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                            return this.setCurve$double_A$int(x1, y1);
                        }
                        else if (((x1 != null && x1 instanceof Array && (x1.length == 0 || x1[0] == null || (x1[0] != null && x1[0] instanceof java.awt.geom.Point2D))) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx1 === undefined && ctrly1 === undefined && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                            return this.setCurve$java_awt_geom_Point2D_A$int(x1, y1);
                        }
                        else if (((x1 != null && x1 instanceof java.awt.geom.CubicCurve2D) || x1 === null) && y1 === undefined && ctrlx1 === undefined && ctrly1 === undefined && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                            return this.setCurve$java_awt_geom_CubicCurve2D(x1);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {java.awt.geom.Rectangle2D}
                     */
                    Float.prototype.getBounds2D = function () {
                        var left = Math.min(Math.min(this.x1, this.x2), Math.min(this.ctrlx1, this.ctrlx2));
                        var top = Math.min(Math.min(this.y1, this.y2), Math.min(this.ctrly1, this.ctrly2));
                        var right = Math.max(Math.max(this.x1, this.x2), Math.max(this.ctrlx1, this.ctrlx2));
                        var bottom = Math.max(Math.max(this.y1, this.y2), Math.max(this.ctrly1, this.ctrly2));
                        return new java.awt.geom.Rectangle2D.Float(left, top, right - left, bottom - top);
                    };
                    Float.serialVersionUID = -1272015596714244385;
                    return Float;
                }(java.awt.geom.CubicCurve2D));
                CubicCurve2D.Float = Float;
                Float["__class"] = "java.awt.geom.CubicCurve2D.Float";
                Float["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"];
                /**
                 * Constructs and initializes a {@code CubicCurve2D} from the specified
                 * {@code double} coordinates.
                 *
                 * @param {number} x1
                 * the X coordinate for the start point of the resulting
                 * {@code CubicCurve2D}
                 * @param {number} y1
                 * the Y coordinate for the start point of the resulting
                 * {@code CubicCurve2D}
                 * @param {number} ctrlx1
                 * the X coordinate for the first control point of the
                 * resulting {@code CubicCurve2D}
                 * @param {number} ctrly1
                 * the Y coordinate for the first control point of the
                 * resulting {@code CubicCurve2D}
                 * @param {number} ctrlx2
                 * the X coordinate for the second control point of the
                 * resulting {@code CubicCurve2D}
                 * @param {number} ctrly2
                 * the Y coordinate for the second control point of the
                 * resulting {@code CubicCurve2D}
                 * @param {number} x2
                 * the X coordinate for the end point of the resulting
                 * {@code CubicCurve2D}
                 * @param {number} y2
                 * the Y coordinate for the end point of the resulting
                 * {@code CubicCurve2D}
                 * @since 1.2
                 * @class
                 * @extends java.awt.geom.CubicCurve2D
                 */
                var Double = /** @class */ (function (_super) {
                    __extends(Double, _super);
                    function Double(x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2) {
                        var _this = this;
                        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx1 === 'number') || ctrlx1 === null) && ((typeof ctrly1 === 'number') || ctrly1 === null) && ((typeof ctrlx2 === 'number') || ctrlx2 === null) && ((typeof ctrly2 === 'number') || ctrly2 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                            var __args = arguments;
                            _this = _super.call(this) || this;
                            if (_this.x1 === undefined)
                                _this.x1 = 0;
                            if (_this.y1 === undefined)
                                _this.y1 = 0;
                            if (_this.ctrlx1 === undefined)
                                _this.ctrlx1 = 0;
                            if (_this.ctrly1 === undefined)
                                _this.ctrly1 = 0;
                            if (_this.ctrlx2 === undefined)
                                _this.ctrlx2 = 0;
                            if (_this.ctrly2 === undefined)
                                _this.ctrly2 = 0;
                            if (_this.x2 === undefined)
                                _this.x2 = 0;
                            if (_this.y2 === undefined)
                                _this.y2 = 0;
                            if (_this.x1 === undefined)
                                _this.x1 = 0;
                            if (_this.y1 === undefined)
                                _this.y1 = 0;
                            if (_this.ctrlx1 === undefined)
                                _this.ctrlx1 = 0;
                            if (_this.ctrly1 === undefined)
                                _this.ctrly1 = 0;
                            if (_this.ctrlx2 === undefined)
                                _this.ctrlx2 = 0;
                            if (_this.ctrly2 === undefined)
                                _this.ctrly2 = 0;
                            if (_this.x2 === undefined)
                                _this.x2 = 0;
                            if (_this.y2 === undefined)
                                _this.y2 = 0;
                            (function () {
                                _this.setCurve$double$double$double$double$double$double$double$double(x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2);
                            })();
                        }
                        else if (x1 === undefined && y1 === undefined && ctrlx1 === undefined && ctrly1 === undefined && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                            var __args = arguments;
                            _this = _super.call(this) || this;
                            if (_this.x1 === undefined)
                                _this.x1 = 0;
                            if (_this.y1 === undefined)
                                _this.y1 = 0;
                            if (_this.ctrlx1 === undefined)
                                _this.ctrlx1 = 0;
                            if (_this.ctrly1 === undefined)
                                _this.ctrly1 = 0;
                            if (_this.ctrlx2 === undefined)
                                _this.ctrlx2 = 0;
                            if (_this.ctrly2 === undefined)
                                _this.ctrly2 = 0;
                            if (_this.x2 === undefined)
                                _this.x2 = 0;
                            if (_this.y2 === undefined)
                                _this.y2 = 0;
                            if (_this.x1 === undefined)
                                _this.x1 = 0;
                            if (_this.y1 === undefined)
                                _this.y1 = 0;
                            if (_this.ctrlx1 === undefined)
                                _this.ctrlx1 = 0;
                            if (_this.ctrly1 === undefined)
                                _this.ctrly1 = 0;
                            if (_this.ctrlx2 === undefined)
                                _this.ctrlx2 = 0;
                            if (_this.ctrly2 === undefined)
                                _this.ctrly2 = 0;
                            if (_this.x2 === undefined)
                                _this.x2 = 0;
                            if (_this.y2 === undefined)
                                _this.y2 = 0;
                        }
                        else
                            throw new Error('invalid overload');
                        return _this;
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Double.prototype.getX1 = function () {
                        return this.x1;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Double.prototype.getY1 = function () {
                        return this.y1;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {java.awt.geom.Point2D}
                     */
                    Double.prototype.getP1 = function () {
                        return new java.awt.geom.Point2D.Double(this.x1, this.y1);
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Double.prototype.getCtrlX1 = function () {
                        return this.ctrlx1;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Double.prototype.getCtrlY1 = function () {
                        return this.ctrly1;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {java.awt.geom.Point2D}
                     */
                    Double.prototype.getCtrlP1 = function () {
                        return new java.awt.geom.Point2D.Double(this.ctrlx1, this.ctrly1);
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Double.prototype.getCtrlX2 = function () {
                        return this.ctrlx2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Double.prototype.getCtrlY2 = function () {
                        return this.ctrly2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {java.awt.geom.Point2D}
                     */
                    Double.prototype.getCtrlP2 = function () {
                        return new java.awt.geom.Point2D.Double(this.ctrlx2, this.ctrly2);
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Double.prototype.getX2 = function () {
                        return this.x2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Double.prototype.getY2 = function () {
                        return this.y2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {java.awt.geom.Point2D}
                     */
                    Double.prototype.getP2 = function () {
                        return new java.awt.geom.Point2D.Double(this.x2, this.y2);
                    };
                    Double.prototype.setCurve$double$double$double$double$double$double$double$double = function (x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2) {
                        this.x1 = x1;
                        this.y1 = y1;
                        this.ctrlx1 = ctrlx1;
                        this.ctrly1 = ctrly1;
                        this.ctrlx2 = ctrlx2;
                        this.ctrly2 = ctrly2;
                        this.x2 = x2;
                        this.y2 = y2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @param {number} x1
                     * @param {number} y1
                     * @param {number} ctrlx1
                     * @param {number} ctrly1
                     * @param {number} ctrlx2
                     * @param {number} ctrly2
                     * @param {number} x2
                     * @param {number} y2
                     */
                    Double.prototype.setCurve = function (x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2) {
                        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx1 === 'number') || ctrlx1 === null) && ((typeof ctrly1 === 'number') || ctrly1 === null) && ((typeof ctrlx2 === 'number') || ctrlx2 === null) && ((typeof ctrly2 === 'number') || ctrly2 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                            return this.setCurve$double$double$double$double$double$double$double$double(x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2);
                        }
                        else if (((x1 != null && x1 instanceof java.awt.geom.Point2D) || x1 === null) && ((y1 != null && y1 instanceof java.awt.geom.Point2D) || y1 === null) && ((ctrlx1 != null && ctrlx1 instanceof java.awt.geom.Point2D) || ctrlx1 === null) && ((ctrly1 != null && ctrly1 instanceof java.awt.geom.Point2D) || ctrly1 === null) && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                            return this.setCurve$java_awt_geom_Point2D$java_awt_geom_Point2D$java_awt_geom_Point2D$java_awt_geom_Point2D(x1, y1, ctrlx1, ctrly1);
                        }
                        else if (((x1 != null && x1 instanceof Array && (x1.length == 0 || x1[0] == null || (typeof x1[0] === 'number'))) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx1 === undefined && ctrly1 === undefined && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                            return this.setCurve$double_A$int(x1, y1);
                        }
                        else if (((x1 != null && x1 instanceof Array && (x1.length == 0 || x1[0] == null || (x1[0] != null && x1[0] instanceof java.awt.geom.Point2D))) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx1 === undefined && ctrly1 === undefined && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                            return this.setCurve$java_awt_geom_Point2D_A$int(x1, y1);
                        }
                        else if (((x1 != null && x1 instanceof java.awt.geom.CubicCurve2D) || x1 === null) && y1 === undefined && ctrlx1 === undefined && ctrly1 === undefined && ctrlx2 === undefined && ctrly2 === undefined && x2 === undefined && y2 === undefined) {
                            return this.setCurve$java_awt_geom_CubicCurve2D(x1);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {java.awt.geom.Rectangle2D}
                     */
                    Double.prototype.getBounds2D = function () {
                        var left = Math.min(Math.min(this.x1, this.x2), Math.min(this.ctrlx1, this.ctrlx2));
                        var top = Math.min(Math.min(this.y1, this.y2), Math.min(this.ctrly1, this.ctrly2));
                        var right = Math.max(Math.max(this.x1, this.x2), Math.max(this.ctrlx1, this.ctrlx2));
                        var bottom = Math.max(Math.max(this.y1, this.y2), Math.max(this.ctrly1, this.ctrly2));
                        return new java.awt.geom.Rectangle2D.Double(left, top, right - left, bottom - top);
                    };
                    Double.serialVersionUID = -4202960122839707295;
                    return Double;
                }(java.awt.geom.CubicCurve2D));
                CubicCurve2D.Double = Double;
                Double["__class"] = "java.awt.geom.CubicCurve2D.Double";
                Double["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"];
            })(CubicCurve2D = geom.CubicCurve2D || (geom.CubicCurve2D = {}));
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * Constructs an instance of <code>NoninvertibleTransformException</code>
             * with the specified detail message.
             *
             * @param {string} s
             * the detail message
             * @since 1.2
             * @class
             * @extends Error
             */
            var NoninvertibleTransformException = /** @class */ (function (_super) {
                __extends(NoninvertibleTransformException, _super);
                function NoninvertibleTransformException(s) {
                    var _this = _super.call(this, s) || this;
                    _this.message = s;
                    Object.setPrototypeOf(_this, NoninvertibleTransformException.prototype);
                    return _this;
                }
                return NoninvertibleTransformException;
            }(Error));
            geom.NoninvertibleTransformException = NoninvertibleTransformException;
            NoninvertibleTransformException["__class"] = "java.awt.geom.NoninvertibleTransformException";
            NoninvertibleTransformException["__interfaces"] = ["java.io.Serializable"];
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * The <code>Area</code> class creates an area geometry from the specified
             * {@link Shape} object. The geometry is explicitly closed, if the
             * <code>Shape</code> is not already closed. The fill rule (even-odd or
             * winding) specified by the geometry of the <code>Shape</code> is used to
             * determine the resulting enclosed area.
             *
             * @param {*} s
             * the <code>Shape</code> from which the area is constructed
             * @throws NullPointerException
             * if <code>s</code> is null
             * @since 1.2
             * @class
             */
            var Area = /** @class */ (function () {
                function Area(s) {
                    var _this = this;
                    if (((s != null && (s["__interfaces"] != null && s["__interfaces"].indexOf("java.awt.Shape") >= 0 || s.constructor != null && s.constructor["__interfaces"] != null && s.constructor["__interfaces"].indexOf("java.awt.Shape") >= 0)) || s === null)) {
                        var __args = arguments;
                        if (this.curves === undefined)
                            this.curves = null;
                        if (this.cachedBounds === undefined)
                            this.cachedBounds = null;
                        if (this.curves === undefined)
                            this.curves = null;
                        if (this.cachedBounds === undefined)
                            this.cachedBounds = null;
                        (function () {
                            if (s != null && s instanceof java.awt.geom.Area) {
                                _this.curves = s.curves;
                            }
                            else {
                                _this.curves = Area.pathToCurves(s['getPathIterator$java_awt_geom_AffineTransform'](null));
                            }
                        })();
                    }
                    else if (s === undefined) {
                        var __args = arguments;
                        if (this.curves === undefined)
                            this.curves = null;
                        if (this.cachedBounds === undefined)
                            this.cachedBounds = null;
                        if (this.curves === undefined)
                            this.curves = null;
                        if (this.cachedBounds === undefined)
                            this.cachedBounds = null;
                        (function () {
                            _this.curves = Area.EmptyCurves_$LI$();
                        })();
                    }
                    else
                        throw new Error('invalid overload');
                }
                Area.EmptyCurves_$LI$ = function () { if (Area.EmptyCurves == null)
                    Area.EmptyCurves = ([]); return Area.EmptyCurves; };
                ;
                /*private*/ Area.pathToCurves = function (pi) {
                    var curves = ([]);
                    var windingRule = pi.getWindingRule();
                    var coords = (function (s) { var a = []; while (s-- > 0)
                        a.push(0); return a; })(23);
                    var movx = 0;
                    var movy = 0;
                    var curx = 0;
                    var cury = 0;
                    var newx;
                    var newy;
                    while ((!pi.isDone())) {
                        {
                            switch ((pi['currentSegment$double_A'](coords))) {
                                case java.awt.geom.PathIterator.SEG_MOVETO:
                                    sun.awt.geom.Curve.insertLine(curves, curx, cury, movx, movy);
                                    curx = movx = coords[0];
                                    cury = movy = coords[1];
                                    sun.awt.geom.Curve.insertMove(curves, movx, movy);
                                    break;
                                case java.awt.geom.PathIterator.SEG_LINETO:
                                    newx = coords[0];
                                    newy = coords[1];
                                    sun.awt.geom.Curve.insertLine(curves, curx, cury, newx, newy);
                                    curx = newx;
                                    cury = newy;
                                    break;
                                case java.awt.geom.PathIterator.SEG_QUADTO:
                                    newx = coords[2];
                                    newy = coords[3];
                                    sun.awt.geom.Curve.insertQuad(curves, curx, cury, coords);
                                    curx = newx;
                                    cury = newy;
                                    break;
                                case java.awt.geom.PathIterator.SEG_CUBICTO:
                                    newx = coords[4];
                                    newy = coords[5];
                                    sun.awt.geom.Curve.insertCubic(curves, curx, cury, coords);
                                    curx = newx;
                                    cury = newy;
                                    break;
                                case java.awt.geom.PathIterator.SEG_CLOSE:
                                    sun.awt.geom.Curve.insertLine(curves, curx, cury, movx, movy);
                                    curx = movx;
                                    cury = movy;
                                    break;
                            }
                            pi.next();
                        }
                    }
                    ;
                    sun.awt.geom.Curve.insertLine(curves, curx, cury, movx, movy);
                    var operator;
                    if (windingRule === java.awt.geom.PathIterator.WIND_EVEN_ODD) {
                        operator = new sun.awt.geom.AreaOp.EOWindOp();
                    }
                    else {
                        operator = new sun.awt.geom.AreaOp.NZWindOp();
                    }
                    return operator.calculate(curves, Area.EmptyCurves_$LI$());
                };
                /**
                 * Adds the shape of the specified <code>Area</code> to the shape of this
                 * <code>Area</code>. The resulting shape of this <code>Area</code> will
                 * include the union of both shapes, or all areas that were contained in
                 * either this or the specified <code>Area</code>.
                 *
                 * <pre>
                 * // Example:
                 * Area a1 = new Area([triangle 0,0 =&gt; 8,0 =&gt; 0,8]);
                 * Area a2 = new Area([triangle 0,0 =&gt; 8,0 =&gt; 8,8]);
                 * a1.add(a2);
                 *
                 * a1(before)     +         a2         =     a1(after)
                 *
                 * ################     ################     ################
                 * ##############         ##############     ################
                 * ############             ############     ################
                 * ##########                 ##########     ################
                 * ########                     ########     ################
                 * ######                         ######     ######    ######
                 * ####                             ####     ####        ####
                 * ##                                 ##     ##            ##
                 * </pre>
                 *
                 * @param {java.awt.geom.Area} rhs
                 * the <code>Area</code> to be added to the current shape
                 * @throws NullPointerException
                 * if <code>rhs</code> is null
                 * @since 1.2
                 */
                Area.prototype.add = function (rhs) {
                    this.curves = new sun.awt.geom.AreaOp.AddOp().calculate(this.curves, rhs.curves);
                    this.invalidateBounds();
                };
                /**
                 * Subtracts the shape of the specified <code>Area</code> from the shape of
                 * this <code>Area</code>. The resulting shape of this <code>Area</code>
                 * will include areas that were contained only in this <code>Area</code> and
                 * not in the specified <code>Area</code>.
                 *
                 * <pre>
                 * // Example:
                 * Area a1 = new Area([triangle 0,0 =&gt; 8,0 =&gt; 0,8]);
                 * Area a2 = new Area([triangle 0,0 =&gt; 8,0 =&gt; 8,8]);
                 * a1.subtract(a2);
                 *
                 * a1(before)     -         a2         =     a1(after)
                 *
                 * ################     ################
                 * ##############         ##############     ##
                 * ############             ############     ####
                 * ##########                 ##########     ######
                 * ########                     ########     ########
                 * ######                         ######     ######
                 * ####                             ####     ####
                 * ##                                 ##     ##
                 * </pre>
                 *
                 * @param {java.awt.geom.Area} rhs
                 * the <code>Area</code> to be subtracted from the current shape
                 * @throws NullPointerException
                 * if <code>rhs</code> is null
                 * @since 1.2
                 */
                Area.prototype.subtract = function (rhs) {
                    this.curves = new sun.awt.geom.AreaOp.SubOp().calculate(this.curves, rhs.curves);
                    this.invalidateBounds();
                };
                /**
                 * Sets the shape of this <code>Area</code> to the intersection of its
                 * current shape and the shape of the specified <code>Area</code>. The
                 * resulting shape of this <code>Area</code> will include only areas that
                 * were contained in both this <code>Area</code> and also in the specified
                 * <code>Area</code>.
                 *
                 * <pre>
                 * // Example:
                 * Area a1 = new Area([triangle 0,0 =&gt; 8,0 =&gt; 0,8]);
                 * Area a2 = new Area([triangle 0,0 =&gt; 8,0 =&gt; 8,8]);
                 * a1.intersect(a2);
                 *
                 * a1(before)   intersect     a2         =     a1(after)
                 *
                 * ################     ################     ################
                 * ##############         ##############       ############
                 * ############             ############         ########
                 * ##########                 ##########           ####
                 * ########                     ########
                 * ######                         ######
                 * ####                             ####
                 * ##                                 ##
                 * </pre>
                 *
                 * @param {java.awt.geom.Area} rhs
                 * the <code>Area</code> to be intersected with this
                 * <code>Area</code>
                 * @throws NullPointerException
                 * if <code>rhs</code> is null
                 * @since 1.2
                 */
                Area.prototype.intersect = function (rhs) {
                    this.curves = new sun.awt.geom.AreaOp.IntOp().calculate(this.curves, rhs.curves);
                    this.invalidateBounds();
                };
                /**
                 * Sets the shape of this <code>Area</code> to be the combined area of its
                 * current shape and the shape of the specified <code>Area</code>, minus
                 * their intersection. The resulting shape of this <code>Area</code> will
                 * include only areas that were contained in either this <code>Area</code>
                 * or in the specified <code>Area</code>, but not in both.
                 *
                 * <pre>
                 * // Example:
                 * Area a1 = new Area([triangle 0,0 =&gt; 8,0 =&gt; 0,8]);
                 * Area a2 = new Area([triangle 0,0 =&gt; 8,0 =&gt; 8,8]);
                 * a1.exclusiveOr(a2);
                 *
                 * a1(before)    xor        a2         =     a1(after)
                 *
                 * ################     ################
                 * ##############         ##############     ##            ##
                 * ############             ############     ####        ####
                 * ##########                 ##########     ######    ######
                 * ########                     ########     ################
                 * ######                         ######     ######    ######
                 * ####                             ####     ####        ####
                 * ##                                 ##     ##            ##
                 * </pre>
                 *
                 * @param {java.awt.geom.Area} rhs
                 * the <code>Area</code> to be exclusive ORed with this
                 * <code>Area</code>.
                 * @throws NullPointerException
                 * if <code>rhs</code> is null
                 * @since 1.2
                 */
                Area.prototype.exclusiveOr = function (rhs) {
                    this.curves = new sun.awt.geom.AreaOp.XorOp().calculate(this.curves, rhs.curves);
                    this.invalidateBounds();
                };
                /**
                 * Removes all of the geometry from this <code>Area</code> and restores it
                 * to an empty area.
                 *
                 * @since 1.2
                 */
                Area.prototype.reset = function () {
                    this.curves = ([]);
                    this.invalidateBounds();
                };
                /**
                 * Tests whether this <code>Area</code> object encloses any area.
                 *
                 * @return {boolean} <code>true</code> if this <code>Area</code> object represents an
                 * empty area; <code>false</code> otherwise.
                 * @since 1.2
                 */
                Area.prototype.isEmpty = function () {
                    return ( /* size */this.curves.length === 0);
                };
                /**
                 * Tests whether this <code>Area</code> consists entirely of straight edged
                 * polygonal geometry.
                 *
                 * @return {boolean} <code>true</code> if the geometry of this <code>Area</code>
                 * consists entirely of line segments; <code>false</code> otherwise.
                 * @since 1.2
                 */
                Area.prototype.isPolygonal = function () {
                    var enum_ = (function (a) { var i = 0; return { nextElement: function () { return i < a.length ? a[i++] : null; }, hasMoreElements: function () { return i < a.length; } }; })(this.curves);
                    while ((enum_.hasMoreElements())) {
                        {
                            if (enum_.nextElement().getOrder() > 1) {
                                return false;
                            }
                        }
                    }
                    ;
                    return true;
                };
                /**
                 * Tests whether this <code>Area</code> is rectangular in shape.
                 *
                 * @return {boolean} <code>true</code> if the geometry of this <code>Area</code> is
                 * rectangular in shape; <code>false</code> otherwise.
                 * @since 1.2
                 */
                Area.prototype.isRectangular = function () {
                    var size = this.curves.length;
                    if (size === 0) {
                        return true;
                    }
                    if (size > 3) {
                        return false;
                    }
                    var c1 = this.curves[1];
                    var c2 = this.curves[2];
                    if (c1.getOrder() !== 1 || c2.getOrder() !== 1) {
                        return false;
                    }
                    if (c1.getXTop() !== c1.getXBot() || c2.getXTop() !== c2.getXBot()) {
                        return false;
                    }
                    if (c1.getYTop() !== c2.getYTop() || c1.getYBot() !== c2.getYBot()) {
                        return false;
                    }
                    return true;
                };
                /**
                 * Tests whether this <code>Area</code> is comprised of a single closed
                 * subpath. This method returns <code>true</code> if the path contains 0 or
                 * 1 subpaths, or <code>false</code> if the path contains more than 1
                 * subpath. The subpaths are counted by the number of
                 * {@link PathIterator#SEG_MOVETO} segments that appear in the
                 * path.
                 *
                 * @return {boolean} <code>true</code> if the <code>Area</code> is comprised of a
                 * single basic geometry; <code>false</code> otherwise.
                 * @since 1.2
                 */
                Area.prototype.isSingular = function () {
                    if ( /* size */this.curves.length < 3) {
                        return true;
                    }
                    var enum_ = (function (a) { var i = 0; return { nextElement: function () { return i < a.length ? a[i++] : null; }, hasMoreElements: function () { return i < a.length; } }; })(this.curves);
                    enum_.nextElement();
                    while ((enum_.hasMoreElements())) {
                        {
                            if (enum_.nextElement().getOrder() === 0) {
                                return false;
                            }
                        }
                    }
                    ;
                    return true;
                };
                /*private*/ Area.prototype.invalidateBounds = function () {
                    this.cachedBounds = null;
                };
                /*private*/ Area.prototype.getCachedBounds = function () {
                    if (this.cachedBounds != null) {
                        return this.cachedBounds;
                    }
                    var r = new java.awt.geom.Rectangle2D.Double();
                    if ( /* size */this.curves.length > 0) {
                        var c = this.curves[0];
                        r.setRect$double$double$double$double(c.getX0(), c.getY0(), 0, 0);
                        for (var i = 1; i < /* size */ this.curves.length; i++) {
                            {
                                this.curves[i].enlarge(r);
                            }
                            ;
                        }
                    }
                    return (this.cachedBounds = r);
                };
                /**
                 * Returns a high precision bounding {@link Rectangle2D} that completely
                 * encloses this <code>Area</code>.
                 * <p>
                 * The Area class will attempt to return the tightest bounding box possible
                 * for the Shape. The bounding box will not be padded to include the control
                 * points of curves in the outline of the Shape, but should tightly fit the
                 * actual geometry of the outline itself.
                 *
                 * @return {java.awt.geom.Rectangle2D} the bounding <code>Rectangle2D</code> for the <code>Area</code>.
                 * @since 1.2
                 */
                Area.prototype.getBounds2D = function () {
                    return this.getCachedBounds().getBounds2D();
                };
                /**
                 * Returns an exact copy of this <code>Area</code> object.
                 *
                 * @return {*} Created clone object
                 * @since 1.2
                 */
                Area.prototype.clone = function () {
                    return new Area(this);
                };
                /**
                 * Tests whether the geometries of the two <code>Area</code> objects are
                 * equal. This method will return false if the argument is null.
                 *
                 * @param {java.awt.geom.Area} other
                 * the <code>Area</code> to be compared to this <code>Area</code>
                 * @return {boolean} <code>true</code> if the two geometries are equal;
                 * <code>false</code> otherwise.
                 * @since 1.2
                 */
                Area.prototype.equals = function (other) {
                    if (other === this) {
                        return true;
                    }
                    if (other == null) {
                        return false;
                    }
                    var c = new sun.awt.geom.AreaOp.XorOp().calculate(this.curves, other.curves);
                    return /* isEmpty */ (c.length == 0);
                };
                /**
                 * Transforms the geometry of this <code>Area</code> using the specified
                 * {@link AffineTransform}. The geometry is transformed in place, which
                 * permanently changes the enclosed area defined by this object.
                 *
                 * @param {java.awt.geom.AffineTransform} t
                 * the transformation used to transform the area
                 * @throws NullPointerException
                 * if <code>t</code> is null
                 * @since 1.2
                 */
                Area.prototype.transform = function (t) {
                    if (t == null) {
                        throw Object.defineProperty(new Error("transform must not be null"), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.Object', 'java.lang.RuntimeException', 'java.lang.NullPointerException', 'java.lang.Exception'] });
                    }
                    this.curves = Area.pathToCurves(this.getPathIterator$java_awt_geom_AffineTransform(t));
                    this.invalidateBounds();
                };
                /**
                 * Creates a new <code>Area</code> object that contains the same geometry as
                 * this <code>Area</code> transformed by the specified
                 * <code>AffineTransform</code>. This <code>Area</code> object is unchanged.
                 *
                 * @param {java.awt.geom.AffineTransform} t
                 * the specified <code>AffineTransform</code> used to transform
                 * the new <code>Area</code>
                 * @throws NullPointerException
                 * if <code>t</code> is null
                 * @return {java.awt.geom.Area} a new <code>Area</code> object representing the transformed
                 * geometry.
                 * @since 1.2
                 */
                Area.prototype.createTransformedArea = function (t) {
                    var a = new Area(this);
                    a.transform(t);
                    return a;
                };
                Area.prototype.contains$double$double = function (x, y) {
                    if (!this.getCachedBounds().contains$double$double(x, y)) {
                        return false;
                    }
                    var enum_ = (function (a) { var i = 0; return { nextElement: function () { return i < a.length ? a[i++] : null; }, hasMoreElements: function () { return i < a.length; } }; })(this.curves);
                    var crossings = 0;
                    while ((enum_.hasMoreElements())) {
                        {
                            var c = enum_.nextElement();
                            crossings += c.crossingsFor(x, y);
                        }
                    }
                    ;
                    return ((crossings & 1) === 1);
                };
                Area.prototype.contains$java_awt_geom_Point2D = function (p) {
                    return this.contains$double$double(p.getX(), p.getY());
                };
                Area.prototype.contains$double$double$double$double = function (x, y, w, h) {
                    if (w < 0 || h < 0) {
                        return false;
                    }
                    if (!this.getCachedBounds().contains$double$double$double$double(x, y, w, h)) {
                        return false;
                    }
                    var c = sun.awt.geom.Crossings.findCrossings$java_util_Vector$double$double$double$double(this.curves, x, y, x + w, y + h);
                    return (c != null && c.covers(y, y + h));
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 * @param {number} x
                 * @param {number} y
                 * @param {number} w
                 * @param {number} h
                 * @return {boolean}
                 */
                Area.prototype.contains = function (x, y, w, h) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        return this.contains$double$double$double$double(x, y, w, h);
                    }
                    else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && w === undefined && h === undefined) {
                        return this.contains$double$double(x, y);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.contains$java_awt_geom_Point2D(x);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.contains$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Area.prototype.contains$java_awt_geom_Rectangle2D = function (r) {
                    return this.contains$double$double$double$double(r.getX(), r.getY(), r.getWidth(), r.getHeight());
                };
                Area.prototype.intersects$double$double$double$double = function (x, y, w, h) {
                    if (w < 0 || h < 0) {
                        return false;
                    }
                    if (!this.getCachedBounds().intersects$double$double$double$double(x, y, w, h)) {
                        return false;
                    }
                    var c = sun.awt.geom.Crossings.findCrossings$java_util_Vector$double$double$double$double(this.curves, x, y, x + w, y + h);
                    return (c == null || !c.isEmpty());
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 * @param {number} x
                 * @param {number} y
                 * @param {number} w
                 * @param {number} h
                 * @return {boolean}
                 */
                Area.prototype.intersects = function (x, y, w, h) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        return this.intersects$double$double$double$double(x, y, w, h);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.intersects$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Area.prototype.intersects$java_awt_geom_Rectangle2D = function (r) {
                    return this.intersects$double$double$double$double(r.getX(), r.getY(), r.getWidth(), r.getHeight());
                };
                Area.prototype.getPathIterator$java_awt_geom_AffineTransform = function (at) {
                    return new java.awt.geom.AreaIterator(this.curves, at);
                };
                Area.prototype.getPathIterator$java_awt_geom_AffineTransform$double = function (at, flatness) {
                    return new java.awt.geom.FlatteningPathIterator(this.getPathIterator$java_awt_geom_AffineTransform(at), flatness);
                };
                /**
                 * Creates a <code>PathIterator</code> for the flattened outline of this
                 * <code>Area</code> object. Only uncurved path segments represented by the
                 * SEG_MOVETO, SEG_LINETO, and SEG_CLOSE point types are returned by the
                 * iterator. This <code>Area</code> object is unchanged.
                 *
                 * @param {java.awt.geom.AffineTransform} at
                 * an optional <code>AffineTransform</code> to be applied to the
                 * coordinates as they are returned in the iteration, or
                 * <code>null</code> if untransformed coordinates are desired
                 * @param {number} flatness
                 * the maximum amount that the control points for a given curve
                 * can vary from colinear before a subdivided curve is replaced
                 * by a straight line connecting the end points
                 * @return {*} the <code>PathIterator</code> object that returns the geometry of
                 * the outline of this <code>Area</code>, one segment at a time.
                 * @since 1.2
                 */
                Area.prototype.getPathIterator = function (at, flatness) {
                    if (((at != null && at instanceof java.awt.geom.AffineTransform) || at === null) && ((typeof flatness === 'number') || flatness === null)) {
                        return this.getPathIterator$java_awt_geom_AffineTransform$double(at, flatness);
                    }
                    else if (((at != null && at instanceof java.awt.geom.AffineTransform) || at === null) && flatness === undefined) {
                        return this.getPathIterator$java_awt_geom_AffineTransform(at);
                    }
                    else
                        throw new Error('invalid overload');
                };
                return Area;
            }());
            geom.Area = Area;
            Area["__class"] = "java.awt.geom.Area";
            Area["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable"];
            var AreaIterator = /** @class */ (function () {
                function AreaIterator(curves, at) {
                    if (this.transform === undefined)
                        this.transform = null;
                    if (this.curves === undefined)
                        this.curves = null;
                    if (this.index === undefined)
                        this.index = 0;
                    if (this.prevcurve === undefined)
                        this.prevcurve = null;
                    if (this.thiscurve === undefined)
                        this.thiscurve = null;
                    this.curves = curves;
                    this.transform = at;
                    if ( /* size */curves.length >= 1) {
                        this.thiscurve = curves[0];
                    }
                }
                AreaIterator.prototype.getWindingRule = function () {
                    return java.awt.geom.PathIterator.WIND_NON_ZERO;
                };
                AreaIterator.prototype.isDone = function () {
                    return (this.prevcurve == null && this.thiscurve == null);
                };
                AreaIterator.prototype.next = function () {
                    if (this.prevcurve != null) {
                        this.prevcurve = null;
                    }
                    else {
                        this.prevcurve = this.thiscurve;
                        this.index++;
                        if (this.index < /* size */ this.curves.length) {
                            this.thiscurve = this.curves[this.index];
                            if (this.thiscurve.getOrder() !== 0 && this.prevcurve.getX1() === this.thiscurve.getX0() && this.prevcurve.getY1() === this.thiscurve.getY0()) {
                                this.prevcurve = null;
                            }
                        }
                        else {
                            this.thiscurve = null;
                        }
                    }
                };
                AreaIterator.prototype.currentSegment$float_A = function (coords) {
                    var dcoords = [0, 0, 0, 0, 0, 0];
                    var segtype = this.currentSegment$double_A(dcoords);
                    var numpoints = (segtype === java.awt.geom.PathIterator.SEG_CLOSE ? 0 : (segtype === java.awt.geom.PathIterator.SEG_QUADTO ? 2 : (segtype === java.awt.geom.PathIterator.SEG_CUBICTO ? 3 : 1)));
                    for (var i = 0; i < numpoints * 2; i++) {
                        {
                            coords[i] = dcoords[i];
                        }
                        ;
                    }
                    return segtype;
                };
                AreaIterator.prototype.currentSegment = function (coords) {
                    if (((coords != null && coords instanceof Array && (coords.length == 0 || coords[0] == null || (typeof coords[0] === 'number'))) || coords === null)) {
                        return this.currentSegment$float_A(coords);
                    }
                    else if (((coords != null && coords instanceof Array && (coords.length == 0 || coords[0] == null || (typeof coords[0] === 'number'))) || coords === null)) {
                        return this.currentSegment$double_A(coords);
                    }
                    else
                        throw new Error('invalid overload');
                };
                AreaIterator.prototype.currentSegment$double_A = function (coords) {
                    var segtype;
                    var numpoints;
                    if (this.prevcurve != null) {
                        if (this.thiscurve == null || this.thiscurve.getOrder() === 0) {
                            return java.awt.geom.PathIterator.SEG_CLOSE;
                        }
                        coords[0] = this.thiscurve.getX0();
                        coords[1] = this.thiscurve.getY0();
                        segtype = java.awt.geom.PathIterator.SEG_LINETO;
                        numpoints = 1;
                    }
                    else if (this.thiscurve == null) {
                        throw Object.defineProperty(new Error("area iterator out of bounds"), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.Object', 'java.lang.RuntimeException', 'java.util.NoSuchElementException', 'java.lang.Exception'] });
                    }
                    else {
                        segtype = this.thiscurve.getSegment(coords);
                        numpoints = this.thiscurve.getOrder();
                        if (numpoints === 0) {
                            numpoints = 1;
                        }
                    }
                    if (this.transform != null) {
                        this.transform.transform$double_A$int$double_A$int$int(coords, 0, coords, 0, numpoints);
                    }
                    return segtype;
                };
                return AreaIterator;
            }());
            geom.AreaIterator = AreaIterator;
            AreaIterator["__class"] = "java.awt.geom.AreaIterator";
            AreaIterator["__interfaces"] = ["java.awt.geom.PathIterator"];
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * The <code>QuadCurve2D</code> class defines a quadratic parametric curve
             * segment in {@code (x,y)} coordinate space.
             * <p>
             * This class is only the abstract superclass for all objects that store a 2D
             * quadratic curve segment. The actual storage representation of the coordinates
             * is left to the subclass.
             *
             * @author Jim Graham
             * @since 1.2
             * @class
             */
            var QuadCurve2D = /** @class */ (function () {
                function QuadCurve2D() {
                }
                QuadCurve2D.prototype.setCurve$double$double$double$double$double$double = function (x1, y1, ctrlx, ctrly, x2, y2) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
                /**
                 * Sets the location of the end points and control point of this curve to
                 * the specified <code>double</code> coordinates.
                 *
                 * @param {number} x1
                 * the X coordinate of the start point
                 * @param {number} y1
                 * the Y coordinate of the start point
                 * @param {number} ctrlx
                 * the X coordinate of the control point
                 * @param {number} ctrly
                 * the Y coordinate of the control point
                 * @param {number} x2
                 * the X coordinate of the end point
                 * @param {number} y2
                 * the Y coordinate of the end point
                 * @since 1.2
                 */
                QuadCurve2D.prototype.setCurve = function (x1, y1, ctrlx, ctrly, x2, y2) {
                    if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx === 'number') || ctrlx === null) && ((typeof ctrly === 'number') || ctrly === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                        return this.setCurve$double$double$double$double$double$double(x1, y1, ctrlx, ctrly, x2, y2);
                    }
                    else if (((x1 != null && x1 instanceof java.awt.geom.Point2D) || x1 === null) && ((y1 != null && y1 instanceof java.awt.geom.Point2D) || y1 === null) && ((ctrlx != null && ctrlx instanceof java.awt.geom.Point2D) || ctrlx === null) && ctrly === undefined && x2 === undefined && y2 === undefined) {
                        return this.setCurve$java_awt_geom_Point2D$java_awt_geom_Point2D$java_awt_geom_Point2D(x1, y1, ctrlx);
                    }
                    else if (((x1 != null && x1 instanceof Array && (x1.length == 0 || x1[0] == null || (typeof x1[0] === 'number'))) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx === undefined && ctrly === undefined && x2 === undefined && y2 === undefined) {
                        return this.setCurve$double_A$int(x1, y1);
                    }
                    else if (((x1 != null && x1 instanceof Array && (x1.length == 0 || x1[0] == null || (x1[0] != null && x1[0] instanceof java.awt.geom.Point2D))) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx === undefined && ctrly === undefined && x2 === undefined && y2 === undefined) {
                        return this.setCurve$java_awt_geom_Point2D_A$int(x1, y1);
                    }
                    else if (((x1 != null && x1 instanceof java.awt.geom.QuadCurve2D) || x1 === null) && y1 === undefined && ctrlx === undefined && ctrly === undefined && x2 === undefined && y2 === undefined) {
                        return this.setCurve$java_awt_geom_QuadCurve2D(x1);
                    }
                    else
                        throw new Error('invalid overload');
                };
                QuadCurve2D.prototype.setCurve$double_A$int = function (coords, offset) {
                    this.setCurve$double$double$double$double$double$double(coords[offset + 0], coords[offset + 1], coords[offset + 2], coords[offset + 3], coords[offset + 4], coords[offset + 5]);
                };
                QuadCurve2D.prototype.setCurve$java_awt_geom_Point2D$java_awt_geom_Point2D$java_awt_geom_Point2D = function (p1, cp, p2) {
                    this.setCurve$double$double$double$double$double$double(p1.getX(), p1.getY(), cp.getX(), cp.getY(), p2.getX(), p2.getY());
                };
                QuadCurve2D.prototype.setCurve$java_awt_geom_Point2D_A$int = function (pts, offset) {
                    this.setCurve$double$double$double$double$double$double(pts[offset + 0].getX(), pts[offset + 0].getY(), pts[offset + 1].getX(), pts[offset + 1].getY(), pts[offset + 2].getX(), pts[offset + 2].getY());
                };
                QuadCurve2D.prototype.setCurve$java_awt_geom_QuadCurve2D = function (c) {
                    this.setCurve$double$double$double$double$double$double(c.getX1(), c.getY1(), c.getCtrlX(), c.getCtrlY(), c.getX2(), c.getY2());
                };
                QuadCurve2D.getFlatnessSq$double$double$double$double$double$double = function (x1, y1, ctrlx, ctrly, x2, y2) {
                    return java.awt.geom.Line2D.ptSegDistSq(x1, y1, x2, y2, ctrlx, ctrly);
                };
                /**
                 * Returns the square of the flatness, or maximum distance of a control
                 * point from the line connecting the end points, of the quadratic curve
                 * specified by the indicated control points.
                 *
                 * @param {number} x1
                 * the X coordinate of the start point
                 * @param {number} y1
                 * the Y coordinate of the start point
                 * @param {number} ctrlx
                 * the X coordinate of the control point
                 * @param {number} ctrly
                 * the Y coordinate of the control point
                 * @param {number} x2
                 * the X coordinate of the end point
                 * @param {number} y2
                 * the Y coordinate of the end point
                 * @return {number} the square of the flatness of the quadratic curve defined by the
                 * specified coordinates.
                 * @since 1.2
                 */
                QuadCurve2D.getFlatnessSq = function (x1, y1, ctrlx, ctrly, x2, y2) {
                    if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx === 'number') || ctrlx === null) && ((typeof ctrly === 'number') || ctrly === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                        return java.awt.geom.QuadCurve2D.getFlatnessSq$double$double$double$double$double$double(x1, y1, ctrlx, ctrly, x2, y2);
                    }
                    else if (((x1 != null && x1 instanceof Array && (x1.length == 0 || x1[0] == null || (typeof x1[0] === 'number'))) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx === undefined && ctrly === undefined && x2 === undefined && y2 === undefined) {
                        return java.awt.geom.QuadCurve2D.getFlatnessSq$double_A$int(x1, y1);
                    }
                    else
                        throw new Error('invalid overload');
                };
                QuadCurve2D.getFlatness$double$double$double$double$double$double = function (x1, y1, ctrlx, ctrly, x2, y2) {
                    return java.awt.geom.Line2D.ptSegDist(x1, y1, x2, y2, ctrlx, ctrly);
                };
                /**
                 * Returns the flatness, or maximum distance of a control point from the
                 * line connecting the end points, of the quadratic curve specified by the
                 * indicated control points.
                 *
                 * @param {number} x1
                 * the X coordinate of the start point
                 * @param {number} y1
                 * the Y coordinate of the start point
                 * @param {number} ctrlx
                 * the X coordinate of the control point
                 * @param {number} ctrly
                 * the Y coordinate of the control point
                 * @param {number} x2
                 * the X coordinate of the end point
                 * @param {number} y2
                 * the Y coordinate of the end point
                 * @return {number} the flatness of the quadratic curve defined by the specified
                 * coordinates.
                 * @since 1.2
                 */
                QuadCurve2D.getFlatness = function (x1, y1, ctrlx, ctrly, x2, y2) {
                    if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx === 'number') || ctrlx === null) && ((typeof ctrly === 'number') || ctrly === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                        return java.awt.geom.QuadCurve2D.getFlatness$double$double$double$double$double$double(x1, y1, ctrlx, ctrly, x2, y2);
                    }
                    else if (((x1 != null && x1 instanceof Array && (x1.length == 0 || x1[0] == null || (typeof x1[0] === 'number'))) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx === undefined && ctrly === undefined && x2 === undefined && y2 === undefined) {
                        return java.awt.geom.QuadCurve2D.getFlatness$double_A$int(x1, y1);
                    }
                    else
                        throw new Error('invalid overload');
                };
                QuadCurve2D.getFlatnessSq$double_A$int = function (coords, offset) {
                    return java.awt.geom.Line2D.ptSegDistSq(coords[offset + 0], coords[offset + 1], coords[offset + 4], coords[offset + 5], coords[offset + 2], coords[offset + 3]);
                };
                QuadCurve2D.getFlatness$double_A$int = function (coords, offset) {
                    return java.awt.geom.Line2D.ptSegDist(coords[offset + 0], coords[offset + 1], coords[offset + 4], coords[offset + 5], coords[offset + 2], coords[offset + 3]);
                };
                /**
                 * Returns the square of the flatness, or maximum distance of a control
                 * point from the line connecting the end points, of this
                 * <code>QuadCurve2D</code>.
                 *
                 * @return {number} the square of the flatness of this <code>QuadCurve2D</code>.
                 * @since 1.2
                 */
                QuadCurve2D.prototype.getFlatnessSq = function () {
                    return java.awt.geom.Line2D.ptSegDistSq(this.getX1(), this.getY1(), this.getX2(), this.getY2(), this.getCtrlX(), this.getCtrlY());
                };
                /**
                 * Returns the flatness, or maximum distance of a control point from the
                 * line connecting the end points, of this <code>QuadCurve2D</code>.
                 *
                 * @return {number} the flatness of this <code>QuadCurve2D</code>.
                 * @since 1.2
                 */
                QuadCurve2D.prototype.getFlatness = function () {
                    return java.awt.geom.Line2D.ptSegDist(this.getX1(), this.getY1(), this.getX2(), this.getY2(), this.getCtrlX(), this.getCtrlY());
                };
                /**
                 * Subdivides this <code>QuadCurve2D</code> and stores the resulting two
                 * subdivided curves into the <code>left</code> and <code>right</code> curve
                 * parameters. Either or both of the <code>left</code> and
                 * <code>right</code> objects can be the same as this
                 * <code>QuadCurve2D</code> or <code>null</code>.
                 *
                 * @param {java.awt.geom.QuadCurve2D} left
                 * the <code>QuadCurve2D</code> object for storing the left or
                 * first half of the subdivided curve
                 * @param {java.awt.geom.QuadCurve2D} right
                 * the <code>QuadCurve2D</code> object for storing the right or
                 * second half of the subdivided curve
                 * @since 1.2
                 */
                QuadCurve2D.prototype.subdivide = function (left, right) {
                    QuadCurve2D.subdivide$java_awt_geom_QuadCurve2D$java_awt_geom_QuadCurve2D$java_awt_geom_QuadCurve2D(this, left, right);
                };
                QuadCurve2D.subdivide$java_awt_geom_QuadCurve2D$java_awt_geom_QuadCurve2D$java_awt_geom_QuadCurve2D = function (src, left, right) {
                    var x1 = src.getX1();
                    var y1 = src.getY1();
                    var ctrlx = src.getCtrlX();
                    var ctrly = src.getCtrlY();
                    var x2 = src.getX2();
                    var y2 = src.getY2();
                    var ctrlx1 = (x1 + ctrlx) / 2.0;
                    var ctrly1 = (y1 + ctrly) / 2.0;
                    var ctrlx2 = (x2 + ctrlx) / 2.0;
                    var ctrly2 = (y2 + ctrly) / 2.0;
                    ctrlx = (ctrlx1 + ctrlx2) / 2.0;
                    ctrly = (ctrly1 + ctrly2) / 2.0;
                    if (left != null) {
                        left.setCurve$double$double$double$double$double$double(x1, y1, ctrlx1, ctrly1, ctrlx, ctrly);
                    }
                    if (right != null) {
                        right.setCurve$double$double$double$double$double$double(ctrlx, ctrly, ctrlx2, ctrly2, x2, y2);
                    }
                };
                QuadCurve2D.subdivide$double_A$int$double_A$int$double_A$int = function (src, srcoff, left, leftoff, right, rightoff) {
                    var x1 = src[srcoff + 0];
                    var y1 = src[srcoff + 1];
                    var ctrlx = src[srcoff + 2];
                    var ctrly = src[srcoff + 3];
                    var x2 = src[srcoff + 4];
                    var y2 = src[srcoff + 5];
                    if (left != null) {
                        left[leftoff + 0] = x1;
                        left[leftoff + 1] = y1;
                    }
                    if (right != null) {
                        right[rightoff + 4] = x2;
                        right[rightoff + 5] = y2;
                    }
                    x1 = (x1 + ctrlx) / 2.0;
                    y1 = (y1 + ctrly) / 2.0;
                    x2 = (x2 + ctrlx) / 2.0;
                    y2 = (y2 + ctrly) / 2.0;
                    ctrlx = (x1 + x2) / 2.0;
                    ctrly = (y1 + y2) / 2.0;
                    if (left != null) {
                        left[leftoff + 2] = x1;
                        left[leftoff + 3] = y1;
                        left[leftoff + 4] = ctrlx;
                        left[leftoff + 5] = ctrly;
                    }
                    if (right != null) {
                        right[rightoff + 0] = ctrlx;
                        right[rightoff + 1] = ctrly;
                        right[rightoff + 2] = x2;
                        right[rightoff + 3] = y2;
                    }
                };
                /**
                 * Subdivides the quadratic curve specified by the coordinates stored in the
                 * <code>src</code> array at indices <code>srcoff</code> through
                 * <code>srcoff</code>&nbsp;+&nbsp;5 and stores the resulting two subdivided
                 * curves into the two result arrays at the corresponding indices. Either or
                 * both of the <code>left</code> and <code>right</code> arrays can be
                 * <code>null</code> or a reference to the same array and offset as the
                 * <code>src</code> array. Note that the last point in the first subdivided
                 * curve is the same as the first point in the second subdivided curve.
                 * Thus, it is possible to pass the same array for <code>left</code> and
                 * <code>right</code> and to use offsets such that <code>rightoff</code>
                 * equals <code>leftoff</code> + 4 in order to avoid allocating extra
                 * storage for this common point.
                 *
                 * @param {Array} src
                 * the array holding the coordinates for the source curve
                 * @param {number} srcoff
                 * the offset into the array of the beginning of the the 6 source
                 * coordinates
                 * @param {Array} left
                 * the array for storing the coordinates for the first half of
                 * the subdivided curve
                 * @param {number} leftoff
                 * the offset into the array of the beginning of the the 6 left
                 * coordinates
                 * @param {Array} right
                 * the array for storing the coordinates for the second half of
                 * the subdivided curve
                 * @param {number} rightoff
                 * the offset into the array of the beginning of the the 6 right
                 * coordinates
                 * @since 1.2
                 */
                QuadCurve2D.subdivide = function (src, srcoff, left, leftoff, right, rightoff) {
                    if (((src != null && src instanceof Array && (src.length == 0 || src[0] == null || (typeof src[0] === 'number'))) || src === null) && ((typeof srcoff === 'number') || srcoff === null) && ((left != null && left instanceof Array && (left.length == 0 || left[0] == null || (typeof left[0] === 'number'))) || left === null) && ((typeof leftoff === 'number') || leftoff === null) && ((right != null && right instanceof Array && (right.length == 0 || right[0] == null || (typeof right[0] === 'number'))) || right === null) && ((typeof rightoff === 'number') || rightoff === null)) {
                        return java.awt.geom.QuadCurve2D.subdivide$double_A$int$double_A$int$double_A$int(src, srcoff, left, leftoff, right, rightoff);
                    }
                    else if (((src != null && src instanceof java.awt.geom.QuadCurve2D) || src === null) && ((srcoff != null && srcoff instanceof java.awt.geom.QuadCurve2D) || srcoff === null) && ((left != null && left instanceof java.awt.geom.QuadCurve2D) || left === null) && leftoff === undefined && right === undefined && rightoff === undefined) {
                        return java.awt.geom.QuadCurve2D.subdivide$java_awt_geom_QuadCurve2D$java_awt_geom_QuadCurve2D$java_awt_geom_QuadCurve2D(src, srcoff, left);
                    }
                    else
                        throw new Error('invalid overload');
                };
                QuadCurve2D.solveQuadratic$double_A = function (eqn) {
                    return QuadCurve2D.solveQuadratic$double_A$double_A(eqn, eqn);
                };
                QuadCurve2D.solveQuadratic$double_A$double_A = function (eqn, res) {
                    var a = eqn[2];
                    var b = eqn[1];
                    var c = eqn[0];
                    var roots = 0;
                    if (a === 0.0) {
                        if (b === 0.0) {
                            return -1;
                        }
                        res[roots++] = -c / b;
                    }
                    else {
                        var d = b * b - 4.0 * a * c;
                        if (d < 0.0) {
                            return 0;
                        }
                        d = Math.sqrt(d);
                        if (b < 0.0) {
                            d = -d;
                        }
                        var q = (b + d) / -2.0;
                        res[roots++] = q / a;
                        if (q !== 0.0) {
                            res[roots++] = c / q;
                        }
                    }
                    return roots;
                };
                /**
                 * Solves the quadratic whose coefficients are in the <code>eqn</code> array
                 * and places the non-complex roots into the <code>res</code> array,
                 * returning the number of roots. The quadratic solved is represented by the
                 * equation:
                 *
                 * <pre>
                 * eqn = {C, B, A};
                 * ax^2 + bx + c = 0
                 * </pre>
                 *
                 * A return value of <code>-1</code> is used to distinguish a constant
                 * equation, which might be always 0 or never 0, from an equation that has
                 * no zeroes.
                 *
                 * @param {Array} eqn
                 * the specified array of coefficients to use to solve the
                 * quadratic equation
                 * @param {Array} res
                 * the array that contains the non-complex roots resulting from
                 * the solution of the quadratic equation
                 * @return {number} the number of roots, or <code>-1</code> if the equation is a
                 * constant.
                 * @since 1.3
                 */
                QuadCurve2D.solveQuadratic = function (eqn, res) {
                    if (((eqn != null && eqn instanceof Array && (eqn.length == 0 || eqn[0] == null || (typeof eqn[0] === 'number'))) || eqn === null) && ((res != null && res instanceof Array && (res.length == 0 || res[0] == null || (typeof res[0] === 'number'))) || res === null)) {
                        return java.awt.geom.QuadCurve2D.solveQuadratic$double_A$double_A(eqn, res);
                    }
                    else if (((eqn != null && eqn instanceof Array && (eqn.length == 0 || eqn[0] == null || (typeof eqn[0] === 'number'))) || eqn === null) && res === undefined) {
                        return java.awt.geom.QuadCurve2D.solveQuadratic$double_A(eqn);
                    }
                    else
                        throw new Error('invalid overload');
                };
                QuadCurve2D.prototype.contains$double$double = function (x, y) {
                    var x1 = this.getX1();
                    var y1 = this.getY1();
                    var xc = this.getCtrlX();
                    var yc = this.getCtrlY();
                    var x2 = this.getX2();
                    var y2 = this.getY2();
                    var kx = x1 - 2 * xc + x2;
                    var ky = y1 - 2 * yc + y2;
                    var dx = x - x1;
                    var dy = y - y1;
                    var dxl = x2 - x1;
                    var dyl = y2 - y1;
                    var t0 = (dx * ky - dy * kx) / (dxl * ky - dyl * kx);
                    if (t0 < 0 || t0 > 1 || t0 !== t0) {
                        return false;
                    }
                    var xb = kx * t0 * t0 + 2 * (xc - x1) * t0 + x1;
                    var yb = ky * t0 * t0 + 2 * (yc - y1) * t0 + y1;
                    var xl = dxl * t0 + x1;
                    var yl = dyl * t0 + y1;
                    return (x >= xb && x < xl) || (x >= xl && x < xb) || (y >= yb && y < yl) || (y >= yl && y < yb);
                };
                QuadCurve2D.prototype.contains$java_awt_geom_Point2D = function (p) {
                    return this.contains$double$double(p.getX(), p.getY());
                };
                /**
                 * Fill an array with the coefficients of the parametric equation in t,
                 * ready for solving against val with solveQuadratic. We currently have: val
                 * = Py(t) = C1*(1-t)^2 + 2*CP*t*(1-t) + C2*t^2 = C1 - 2*C1*t + C1*t^2 +
                 * 2*CP*t - 2*CP*t^2 + C2*t^2 = C1 + (2*CP - 2*C1)*t + (C1 - 2*CP + C2)*t^2
                 * 0 = (C1 - val) + (2*CP - 2*C1)*t + (C1 - 2*CP + C2)*t^2 0 = C + Bt + At^2
                 * C = C1 - val B = 2*CP - 2*C1 A = C1 - 2*CP + C2
                 * @param {Array} eqn
                 * @param {number} val
                 * @param {number} c1
                 * @param {number} cp
                 * @param {number} c2
                 * @private
                 */
                QuadCurve2D.fillEqn = function (eqn, val, c1, cp, c2) {
                    eqn[0] = c1 - val;
                    eqn[1] = cp + cp - c1 - c1;
                    eqn[2] = c1 - cp - cp + c2;
                    return;
                };
                /**
                 * Evaluate the t values in the first num slots of the vals[] array and
                 * place the evaluated values back into the same array. Only evaluate t
                 * values that are within the range &lt;0, 1&gt;, including the 0 and 1 ends
                 * of the range iff the include0 or include1 booleans are true. If an
                 * "inflection" equation is handed in, then any points which represent a
                 * point of inflection for that quadratic equation are also ignored.
                 * @param {Array} vals
                 * @param {number} num
                 * @param {boolean} include0
                 * @param {boolean} include1
                 * @param {Array} inflect
                 * @param {number} c1
                 * @param {number} ctrl
                 * @param {number} c2
                 * @return {number}
                 * @private
                 */
                QuadCurve2D.evalQuadratic = function (vals, num, include0, include1, inflect, c1, ctrl, c2) {
                    var j = 0;
                    for (var i = 0; i < num; i++) {
                        {
                            var t = vals[i];
                            if ((include0 ? t >= 0 : t > 0) && (include1 ? t <= 1 : t < 1) && (inflect == null || inflect[1] + 2 * inflect[2] * t !== 0)) {
                                var u = 1 - t;
                                vals[j++] = c1 * u * u + 2 * ctrl * t * u + c2 * t * t;
                            }
                        }
                        ;
                    }
                    return j;
                };
                /**
                 * Determine where coord lies with respect to the range from low to high. It
                 * is assumed that low &lt;= high. The return value is one of the 5 values
                 * BELOW, LOWEDGE, INSIDE, HIGHEDGE, or ABOVE.
                 * @param {number} coord
                 * @param {number} low
                 * @param {number} high
                 * @return {number}
                 * @private
                 */
                QuadCurve2D.getTag = function (coord, low, high) {
                    if (coord <= low) {
                        return (coord < low ? QuadCurve2D.BELOW : QuadCurve2D.LOWEDGE);
                    }
                    if (coord >= high) {
                        return (coord > high ? QuadCurve2D.ABOVE : QuadCurve2D.HIGHEDGE);
                    }
                    return QuadCurve2D.INSIDE;
                };
                /**
                 * Determine if the pttag represents a coordinate that is already in its
                 * test range, or is on the border with either of the two opttags
                 * representing another coordinate that is "towards the inside" of that test
                 * range. In other words, are either of the two "opt" points
                 * "drawing the pt inward"?
                 * @param {number} pttag
                 * @param {number} opt1tag
                 * @param {number} opt2tag
                 * @return {boolean}
                 * @private
                 */
                QuadCurve2D.inwards = function (pttag, opt1tag, opt2tag) {
                    switch ((pttag)) {
                        case -2 /* BELOW */:
                        case 2 /* ABOVE */:
                        default:
                            return false;
                        case -1 /* LOWEDGE */:
                            return (opt1tag >= QuadCurve2D.INSIDE || opt2tag >= QuadCurve2D.INSIDE);
                        case 0 /* INSIDE */:
                            return true;
                        case 1 /* HIGHEDGE */:
                            return (opt1tag <= QuadCurve2D.INSIDE || opt2tag <= QuadCurve2D.INSIDE);
                    }
                };
                QuadCurve2D.prototype.intersects$double$double$double$double = function (x, y, w, h) {
                    if (w <= 0 || h <= 0) {
                        return false;
                    }
                    var x1 = this.getX1();
                    var y1 = this.getY1();
                    var x1tag = QuadCurve2D.getTag(x1, x, x + w);
                    var y1tag = QuadCurve2D.getTag(y1, y, y + h);
                    if (x1tag === QuadCurve2D.INSIDE && y1tag === QuadCurve2D.INSIDE) {
                        return true;
                    }
                    var x2 = this.getX2();
                    var y2 = this.getY2();
                    var x2tag = QuadCurve2D.getTag(x2, x, x + w);
                    var y2tag = QuadCurve2D.getTag(y2, y, y + h);
                    if (x2tag === QuadCurve2D.INSIDE && y2tag === QuadCurve2D.INSIDE) {
                        return true;
                    }
                    var ctrlx = this.getCtrlX();
                    var ctrly = this.getCtrlY();
                    var ctrlxtag = QuadCurve2D.getTag(ctrlx, x, x + w);
                    var ctrlytag = QuadCurve2D.getTag(ctrly, y, y + h);
                    if (x1tag < QuadCurve2D.INSIDE && x2tag < QuadCurve2D.INSIDE && ctrlxtag < QuadCurve2D.INSIDE) {
                        return false;
                    }
                    if (y1tag < QuadCurve2D.INSIDE && y2tag < QuadCurve2D.INSIDE && ctrlytag < QuadCurve2D.INSIDE) {
                        return false;
                    }
                    if (x1tag > QuadCurve2D.INSIDE && x2tag > QuadCurve2D.INSIDE && ctrlxtag > QuadCurve2D.INSIDE) {
                        return false;
                    }
                    if (y1tag > QuadCurve2D.INSIDE && y2tag > QuadCurve2D.INSIDE && ctrlytag > QuadCurve2D.INSIDE) {
                        return false;
                    }
                    if (QuadCurve2D.inwards(x1tag, x2tag, ctrlxtag) && QuadCurve2D.inwards(y1tag, y2tag, ctrlytag)) {
                        return true;
                    }
                    if (QuadCurve2D.inwards(x2tag, x1tag, ctrlxtag) && QuadCurve2D.inwards(y2tag, y1tag, ctrlytag)) {
                        return true;
                    }
                    var xoverlap = (x1tag * x2tag <= 0);
                    var yoverlap = (y1tag * y2tag <= 0);
                    if (x1tag === QuadCurve2D.INSIDE && x2tag === QuadCurve2D.INSIDE && yoverlap) {
                        return true;
                    }
                    if (y1tag === QuadCurve2D.INSIDE && y2tag === QuadCurve2D.INSIDE && xoverlap) {
                        return true;
                    }
                    var eqn = [0, 0, 0];
                    var res = [0, 0, 0];
                    if (!yoverlap) {
                        QuadCurve2D.fillEqn(eqn, (y1tag < QuadCurve2D.INSIDE ? y : y + h), y1, ctrly, y2);
                        return (QuadCurve2D.solveQuadratic$double_A$double_A(eqn, res) === 2 && QuadCurve2D.evalQuadratic(res, 2, true, true, null, x1, ctrlx, x2) === 2 && QuadCurve2D.getTag(res[0], x, x + w) * QuadCurve2D.getTag(res[1], x, x + w) <= 0);
                    }
                    if (!xoverlap) {
                        QuadCurve2D.fillEqn(eqn, (x1tag < QuadCurve2D.INSIDE ? x : x + w), x1, ctrlx, x2);
                        return (QuadCurve2D.solveQuadratic$double_A$double_A(eqn, res) === 2 && QuadCurve2D.evalQuadratic(res, 2, true, true, null, y1, ctrly, y2) === 2 && QuadCurve2D.getTag(res[0], y, y + h) * QuadCurve2D.getTag(res[1], y, y + h) <= 0);
                    }
                    var dx = x2 - x1;
                    var dy = y2 - y1;
                    var k = y2 * x1 - x2 * y1;
                    var c1tag;
                    var c2tag;
                    if (y1tag === QuadCurve2D.INSIDE) {
                        c1tag = x1tag;
                    }
                    else {
                        c1tag = QuadCurve2D.getTag((k + dx * (y1tag < QuadCurve2D.INSIDE ? y : y + h)) / dy, x, x + w);
                    }
                    if (y2tag === QuadCurve2D.INSIDE) {
                        c2tag = x2tag;
                    }
                    else {
                        c2tag = QuadCurve2D.getTag((k + dx * (y2tag < QuadCurve2D.INSIDE ? y : y + h)) / dy, x, x + w);
                    }
                    if (c1tag * c2tag <= 0) {
                        return true;
                    }
                    c1tag = ((c1tag * x1tag <= 0) ? y1tag : y2tag);
                    QuadCurve2D.fillEqn(eqn, (c2tag < QuadCurve2D.INSIDE ? x : x + w), x1, ctrlx, x2);
                    var num = QuadCurve2D.solveQuadratic$double_A$double_A(eqn, res);
                    QuadCurve2D.evalQuadratic(res, num, true, true, null, y1, ctrly, y2);
                    c2tag = QuadCurve2D.getTag(res[0], y, y + h);
                    return (c1tag * c2tag <= 0);
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 * @param {number} x
                 * @param {number} y
                 * @param {number} w
                 * @param {number} h
                 * @return {boolean}
                 */
                QuadCurve2D.prototype.intersects = function (x, y, w, h) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        return this.intersects$double$double$double$double(x, y, w, h);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.intersects$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                QuadCurve2D.prototype.intersects$java_awt_geom_Rectangle2D = function (r) {
                    return this.intersects$double$double$double$double(r.getX(), r.getY(), r.getWidth(), r.getHeight());
                };
                QuadCurve2D.prototype.contains$double$double$double$double = function (x, y, w, h) {
                    if (w <= 0 || h <= 0) {
                        return false;
                    }
                    return (this.contains$double$double(x, y) && this.contains$double$double(x + w, y) && this.contains$double$double(x + w, y + h) && this.contains$double$double(x, y + h));
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 * @param {number} x
                 * @param {number} y
                 * @param {number} w
                 * @param {number} h
                 * @return {boolean}
                 */
                QuadCurve2D.prototype.contains = function (x, y, w, h) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        return this.contains$double$double$double$double(x, y, w, h);
                    }
                    else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && w === undefined && h === undefined) {
                        return this.contains$double$double(x, y);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.contains$java_awt_geom_Point2D(x);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.contains$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                QuadCurve2D.prototype.contains$java_awt_geom_Rectangle2D = function (r) {
                    return this.contains$double$double$double$double(r.getX(), r.getY(), r.getWidth(), r.getHeight());
                };
                QuadCurve2D.prototype.getPathIterator$java_awt_geom_AffineTransform = function (at) {
                    return new java.awt.geom.QuadIterator(this, at);
                };
                QuadCurve2D.prototype.getPathIterator$java_awt_geom_AffineTransform$double = function (at, flatness) {
                    return new java.awt.geom.FlatteningPathIterator(this.getPathIterator$java_awt_geom_AffineTransform(at), flatness);
                };
                /**
                 * Returns an iteration object that defines the boundary of the flattened
                 * shape of this <code>QuadCurve2D</code>. The iterator for this class is
                 * not multi-threaded safe, which means that this <code>QuadCurve2D</code>
                 * class does not guarantee that modifications to the geometry of this
                 * <code>QuadCurve2D</code> object do not affect any iterations of that
                 * geometry that are already in process.
                 *
                 * @param {java.awt.geom.AffineTransform} at
                 * an optional <code>AffineTransform</code> to apply to the
                 * boundary of the shape
                 * @param {number} flatness
                 * the maximum distance that the control points for a subdivided
                 * curve can be with respect to a line connecting the end points
                 * of this curve before this curve is replaced by a straight line
                 * connecting the end points.
                 * @return {*} a <code>PathIterator</code> object that defines the flattened
                 * boundary of the shape.
                 * @since 1.2
                 */
                QuadCurve2D.prototype.getPathIterator = function (at, flatness) {
                    if (((at != null && at instanceof java.awt.geom.AffineTransform) || at === null) && ((typeof flatness === 'number') || flatness === null)) {
                        return this.getPathIterator$java_awt_geom_AffineTransform$double(at, flatness);
                    }
                    else if (((at != null && at instanceof java.awt.geom.AffineTransform) || at === null) && flatness === undefined) {
                        return this.getPathIterator$java_awt_geom_AffineTransform(at);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Creates a new object of the same class and with the same contents as this
                 * object.
                 *
                 * @return {*} a clone of this instance.
                 * @exception OutOfMemoryError
                 * if there is not enough memory.
                 * @see java.lang.Cloneable
                 * @since 1.2
                 */
                QuadCurve2D.prototype.clone = function () {
                    try {
                        return /* clone */ /* clone */ (function (o) { var clone = Object.create(o); for (var p in o) {
                            if (o.hasOwnProperty(p))
                                clone[p] = o[p];
                        } return clone; })(this);
                    }
                    catch (e) {
                        throw Object.defineProperty(new Error(e.message), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.VirtualMachineError', 'java.lang.InternalError', 'java.lang.Error', 'java.lang.Object'] });
                    }
                    ;
                };
                QuadCurve2D.BELOW = -2;
                QuadCurve2D.LOWEDGE = -1;
                QuadCurve2D.INSIDE = 0;
                QuadCurve2D.HIGHEDGE = 1;
                QuadCurve2D.ABOVE = 2;
                return QuadCurve2D;
            }());
            geom.QuadCurve2D = QuadCurve2D;
            QuadCurve2D["__class"] = "java.awt.geom.QuadCurve2D";
            QuadCurve2D["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable"];
            (function (QuadCurve2D) {
                /**
                 * Constructs and initializes a <code>QuadCurve2D</code> from the
                 * specified {@code float} coordinates.
                 *
                 * @param {number} x1
                 * the X coordinate of the start point
                 * @param {number} y1
                 * the Y coordinate of the start point
                 * @param {number} ctrlx
                 * the X coordinate of the control point
                 * @param {number} ctrly
                 * the Y coordinate of the control point
                 * @param {number} x2
                 * the X coordinate of the end point
                 * @param {number} y2
                 * the Y coordinate of the end point
                 * @since 1.2
                 * @class
                 * @extends java.awt.geom.QuadCurve2D
                 */
                var Float = /** @class */ (function (_super) {
                    __extends(Float, _super);
                    function Float(x1, y1, ctrlx, ctrly, x2, y2) {
                        var _this = this;
                        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx === 'number') || ctrlx === null) && ((typeof ctrly === 'number') || ctrly === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                            var __args = arguments;
                            _this = _super.call(this) || this;
                            if (_this.x1 === undefined)
                                _this.x1 = 0;
                            if (_this.y1 === undefined)
                                _this.y1 = 0;
                            if (_this.ctrlx === undefined)
                                _this.ctrlx = 0;
                            if (_this.ctrly === undefined)
                                _this.ctrly = 0;
                            if (_this.x2 === undefined)
                                _this.x2 = 0;
                            if (_this.y2 === undefined)
                                _this.y2 = 0;
                            if (_this.x1 === undefined)
                                _this.x1 = 0;
                            if (_this.y1 === undefined)
                                _this.y1 = 0;
                            if (_this.ctrlx === undefined)
                                _this.ctrlx = 0;
                            if (_this.ctrly === undefined)
                                _this.ctrly = 0;
                            if (_this.x2 === undefined)
                                _this.x2 = 0;
                            if (_this.y2 === undefined)
                                _this.y2 = 0;
                            (function () {
                                _this.setCurve$float$float$float$float$float$float(x1, y1, ctrlx, ctrly, x2, y2);
                            })();
                        }
                        else if (x1 === undefined && y1 === undefined && ctrlx === undefined && ctrly === undefined && x2 === undefined && y2 === undefined) {
                            var __args = arguments;
                            _this = _super.call(this) || this;
                            if (_this.x1 === undefined)
                                _this.x1 = 0;
                            if (_this.y1 === undefined)
                                _this.y1 = 0;
                            if (_this.ctrlx === undefined)
                                _this.ctrlx = 0;
                            if (_this.ctrly === undefined)
                                _this.ctrly = 0;
                            if (_this.x2 === undefined)
                                _this.x2 = 0;
                            if (_this.y2 === undefined)
                                _this.y2 = 0;
                            if (_this.x1 === undefined)
                                _this.x1 = 0;
                            if (_this.y1 === undefined)
                                _this.y1 = 0;
                            if (_this.ctrlx === undefined)
                                _this.ctrlx = 0;
                            if (_this.ctrly === undefined)
                                _this.ctrly = 0;
                            if (_this.x2 === undefined)
                                _this.x2 = 0;
                            if (_this.y2 === undefined)
                                _this.y2 = 0;
                        }
                        else
                            throw new Error('invalid overload');
                        return _this;
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Float.prototype.getX1 = function () {
                        return this.x1;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Float.prototype.getY1 = function () {
                        return this.y1;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {java.awt.geom.Point2D}
                     */
                    Float.prototype.getP1 = function () {
                        return new java.awt.geom.Point2D.Float(this.x1, this.y1);
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Float.prototype.getCtrlX = function () {
                        return this.ctrlx;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Float.prototype.getCtrlY = function () {
                        return this.ctrly;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {java.awt.geom.Point2D}
                     */
                    Float.prototype.getCtrlPt = function () {
                        return new java.awt.geom.Point2D.Float(this.ctrlx, this.ctrly);
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Float.prototype.getX2 = function () {
                        return this.x2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Float.prototype.getY2 = function () {
                        return this.y2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {java.awt.geom.Point2D}
                     */
                    Float.prototype.getP2 = function () {
                        return new java.awt.geom.Point2D.Float(this.x2, this.y2);
                    };
                    Float.prototype.setCurve$double$double$double$double$double$double = function (x1, y1, ctrlx, ctrly, x2, y2) {
                        this.x1 = x1;
                        this.y1 = y1;
                        this.ctrlx = ctrlx;
                        this.ctrly = ctrly;
                        this.x2 = x2;
                        this.y2 = y2;
                    };
                    Float.prototype.setCurve$float$float$float$float$float$float = function (x1, y1, ctrlx, ctrly, x2, y2) {
                        this.x1 = x1;
                        this.y1 = y1;
                        this.ctrlx = ctrlx;
                        this.ctrly = ctrly;
                        this.x2 = x2;
                        this.y2 = y2;
                    };
                    /**
                     * Sets the location of the end points and control point of this curve
                     * to the specified {@code float} coordinates.
                     *
                     * @param {number} x1
                     * the X coordinate of the start point
                     * @param {number} y1
                     * the Y coordinate of the start point
                     * @param {number} ctrlx
                     * the X coordinate of the control point
                     * @param {number} ctrly
                     * the Y coordinate of the control point
                     * @param {number} x2
                     * the X coordinate of the end point
                     * @param {number} y2
                     * the Y coordinate of the end point
                     * @since 1.2
                     */
                    Float.prototype.setCurve = function (x1, y1, ctrlx, ctrly, x2, y2) {
                        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx === 'number') || ctrlx === null) && ((typeof ctrly === 'number') || ctrly === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                            return this.setCurve$float$float$float$float$float$float(x1, y1, ctrlx, ctrly, x2, y2);
                        }
                        else if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx === 'number') || ctrlx === null) && ((typeof ctrly === 'number') || ctrly === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                            return this.setCurve$double$double$double$double$double$double(x1, y1, ctrlx, ctrly, x2, y2);
                        }
                        else if (((x1 != null && x1 instanceof java.awt.geom.Point2D) || x1 === null) && ((y1 != null && y1 instanceof java.awt.geom.Point2D) || y1 === null) && ((ctrlx != null && ctrlx instanceof java.awt.geom.Point2D) || ctrlx === null) && ctrly === undefined && x2 === undefined && y2 === undefined) {
                            return this.setCurve$java_awt_geom_Point2D$java_awt_geom_Point2D$java_awt_geom_Point2D(x1, y1, ctrlx);
                        }
                        else if (((x1 != null && x1 instanceof Array && (x1.length == 0 || x1[0] == null || (typeof x1[0] === 'number'))) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx === undefined && ctrly === undefined && x2 === undefined && y2 === undefined) {
                            return this.setCurve$double_A$int(x1, y1);
                        }
                        else if (((x1 != null && x1 instanceof Array && (x1.length == 0 || x1[0] == null || (x1[0] != null && x1[0] instanceof java.awt.geom.Point2D))) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx === undefined && ctrly === undefined && x2 === undefined && y2 === undefined) {
                            return this.setCurve$java_awt_geom_Point2D_A$int(x1, y1);
                        }
                        else if (((x1 != null && x1 instanceof java.awt.geom.QuadCurve2D) || x1 === null) && y1 === undefined && ctrlx === undefined && ctrly === undefined && x2 === undefined && y2 === undefined) {
                            return this.setCurve$java_awt_geom_QuadCurve2D(x1);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {java.awt.geom.Rectangle2D}
                     */
                    Float.prototype.getBounds2D = function () {
                        var left = Math.min(Math.min(this.x1, this.x2), this.ctrlx);
                        var top = Math.min(Math.min(this.y1, this.y2), this.ctrly);
                        var right = Math.max(Math.max(this.x1, this.x2), this.ctrlx);
                        var bottom = Math.max(Math.max(this.y1, this.y2), this.ctrly);
                        return new java.awt.geom.Rectangle2D.Float(left, top, right - left, bottom - top);
                    };
                    Float.serialVersionUID = -8511188402130719609;
                    return Float;
                }(java.awt.geom.QuadCurve2D));
                QuadCurve2D.Float = Float;
                Float["__class"] = "java.awt.geom.QuadCurve2D.Float";
                Float["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"];
                /**
                 * Constructs and initializes a <code>QuadCurve2D</code> from the
                 * specified {@code double} coordinates.
                 *
                 * @param {number} x1
                 * the X coordinate of the start point
                 * @param {number} y1
                 * the Y coordinate of the start point
                 * @param {number} ctrlx
                 * the X coordinate of the control point
                 * @param {number} ctrly
                 * the Y coordinate of the control point
                 * @param {number} x2
                 * the X coordinate of the end point
                 * @param {number} y2
                 * the Y coordinate of the end point
                 * @since 1.2
                 * @class
                 * @extends java.awt.geom.QuadCurve2D
                 */
                var Double = /** @class */ (function (_super) {
                    __extends(Double, _super);
                    function Double(x1, y1, ctrlx, ctrly, x2, y2) {
                        var _this = this;
                        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx === 'number') || ctrlx === null) && ((typeof ctrly === 'number') || ctrly === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                            var __args = arguments;
                            _this = _super.call(this) || this;
                            if (_this.x1 === undefined)
                                _this.x1 = 0;
                            if (_this.y1 === undefined)
                                _this.y1 = 0;
                            if (_this.ctrlx === undefined)
                                _this.ctrlx = 0;
                            if (_this.ctrly === undefined)
                                _this.ctrly = 0;
                            if (_this.x2 === undefined)
                                _this.x2 = 0;
                            if (_this.y2 === undefined)
                                _this.y2 = 0;
                            if (_this.x1 === undefined)
                                _this.x1 = 0;
                            if (_this.y1 === undefined)
                                _this.y1 = 0;
                            if (_this.ctrlx === undefined)
                                _this.ctrlx = 0;
                            if (_this.ctrly === undefined)
                                _this.ctrly = 0;
                            if (_this.x2 === undefined)
                                _this.x2 = 0;
                            if (_this.y2 === undefined)
                                _this.y2 = 0;
                            (function () {
                                _this.setCurve$double$double$double$double$double$double(x1, y1, ctrlx, ctrly, x2, y2);
                            })();
                        }
                        else if (x1 === undefined && y1 === undefined && ctrlx === undefined && ctrly === undefined && x2 === undefined && y2 === undefined) {
                            var __args = arguments;
                            _this = _super.call(this) || this;
                            if (_this.x1 === undefined)
                                _this.x1 = 0;
                            if (_this.y1 === undefined)
                                _this.y1 = 0;
                            if (_this.ctrlx === undefined)
                                _this.ctrlx = 0;
                            if (_this.ctrly === undefined)
                                _this.ctrly = 0;
                            if (_this.x2 === undefined)
                                _this.x2 = 0;
                            if (_this.y2 === undefined)
                                _this.y2 = 0;
                            if (_this.x1 === undefined)
                                _this.x1 = 0;
                            if (_this.y1 === undefined)
                                _this.y1 = 0;
                            if (_this.ctrlx === undefined)
                                _this.ctrlx = 0;
                            if (_this.ctrly === undefined)
                                _this.ctrly = 0;
                            if (_this.x2 === undefined)
                                _this.x2 = 0;
                            if (_this.y2 === undefined)
                                _this.y2 = 0;
                        }
                        else
                            throw new Error('invalid overload');
                        return _this;
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Double.prototype.getX1 = function () {
                        return this.x1;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Double.prototype.getY1 = function () {
                        return this.y1;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {java.awt.geom.Point2D}
                     */
                    Double.prototype.getP1 = function () {
                        return new java.awt.geom.Point2D.Double(this.x1, this.y1);
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Double.prototype.getCtrlX = function () {
                        return this.ctrlx;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Double.prototype.getCtrlY = function () {
                        return this.ctrly;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {java.awt.geom.Point2D}
                     */
                    Double.prototype.getCtrlPt = function () {
                        return new java.awt.geom.Point2D.Double(this.ctrlx, this.ctrly);
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Double.prototype.getX2 = function () {
                        return this.x2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Double.prototype.getY2 = function () {
                        return this.y2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {java.awt.geom.Point2D}
                     */
                    Double.prototype.getP2 = function () {
                        return new java.awt.geom.Point2D.Double(this.x2, this.y2);
                    };
                    Double.prototype.setCurve$double$double$double$double$double$double = function (x1, y1, ctrlx, ctrly, x2, y2) {
                        this.x1 = x1;
                        this.y1 = y1;
                        this.ctrlx = ctrlx;
                        this.ctrly = ctrly;
                        this.x2 = x2;
                        this.y2 = y2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @param {number} x1
                     * @param {number} y1
                     * @param {number} ctrlx
                     * @param {number} ctrly
                     * @param {number} x2
                     * @param {number} y2
                     */
                    Double.prototype.setCurve = function (x1, y1, ctrlx, ctrly, x2, y2) {
                        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof ctrlx === 'number') || ctrlx === null) && ((typeof ctrly === 'number') || ctrly === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                            return this.setCurve$double$double$double$double$double$double(x1, y1, ctrlx, ctrly, x2, y2);
                        }
                        else if (((x1 != null && x1 instanceof java.awt.geom.Point2D) || x1 === null) && ((y1 != null && y1 instanceof java.awt.geom.Point2D) || y1 === null) && ((ctrlx != null && ctrlx instanceof java.awt.geom.Point2D) || ctrlx === null) && ctrly === undefined && x2 === undefined && y2 === undefined) {
                            return this.setCurve$java_awt_geom_Point2D$java_awt_geom_Point2D$java_awt_geom_Point2D(x1, y1, ctrlx);
                        }
                        else if (((x1 != null && x1 instanceof Array && (x1.length == 0 || x1[0] == null || (typeof x1[0] === 'number'))) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx === undefined && ctrly === undefined && x2 === undefined && y2 === undefined) {
                            return this.setCurve$double_A$int(x1, y1);
                        }
                        else if (((x1 != null && x1 instanceof Array && (x1.length == 0 || x1[0] == null || (x1[0] != null && x1[0] instanceof java.awt.geom.Point2D))) || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ctrlx === undefined && ctrly === undefined && x2 === undefined && y2 === undefined) {
                            return this.setCurve$java_awt_geom_Point2D_A$int(x1, y1);
                        }
                        else if (((x1 != null && x1 instanceof java.awt.geom.QuadCurve2D) || x1 === null) && y1 === undefined && ctrlx === undefined && ctrly === undefined && x2 === undefined && y2 === undefined) {
                            return this.setCurve$java_awt_geom_QuadCurve2D(x1);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {java.awt.geom.Rectangle2D}
                     */
                    Double.prototype.getBounds2D = function () {
                        var left = Math.min(Math.min(this.x1, this.x2), this.ctrlx);
                        var top = Math.min(Math.min(this.y1, this.y2), this.ctrly);
                        var right = Math.max(Math.max(this.x1, this.x2), this.ctrlx);
                        var bottom = Math.max(Math.max(this.y1, this.y2), this.ctrly);
                        return new java.awt.geom.Rectangle2D.Double(left, top, right - left, bottom - top);
                    };
                    Double.serialVersionUID = 4217149928428559721;
                    return Double;
                }(java.awt.geom.QuadCurve2D));
                QuadCurve2D.Double = Double;
                Double["__class"] = "java.awt.geom.QuadCurve2D.Double";
                Double["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"];
            })(QuadCurve2D = geom.QuadCurve2D || (geom.QuadCurve2D = {}));
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * A utility class to iterate over the path segments of an ellipse through the
             * PathIterator interface.
             *
             * @author Jim Graham
             * @class
             */
            var EllipseIterator = /** @class */ (function () {
                function EllipseIterator(e, at) {
                    if (this.x === undefined)
                        this.x = 0;
                    if (this.y === undefined)
                        this.y = 0;
                    if (this.w === undefined)
                        this.w = 0;
                    if (this.h === undefined)
                        this.h = 0;
                    if (this.affine === undefined)
                        this.affine = null;
                    if (this.index === undefined)
                        this.index = 0;
                    this.x = e.getX();
                    this.y = e.getY();
                    this.w = e.getWidth();
                    this.h = e.getHeight();
                    this.affine = at;
                    if (this.w < 0 || this.h < 0) {
                        this.index = 6;
                    }
                }
                /**
                 * Return the winding rule for determining the insideness of the path.
                 *
                 * @see #WIND_EVEN_ODD
                 * @see #WIND_NON_ZERO
                 * @return {number}
                 */
                EllipseIterator.prototype.getWindingRule = function () {
                    return java.awt.geom.PathIterator.WIND_NON_ZERO;
                };
                /**
                 * Tests if there are more points to read.
                 *
                 * @return {boolean} true if there are more points to read
                 */
                EllipseIterator.prototype.isDone = function () {
                    return this.index > 5;
                };
                /**
                 * Moves the iterator to the next segment of the path forwards along the
                 * primary direction of traversal as long as there are more points in that
                 * direction.
                 */
                EllipseIterator.prototype.next = function () {
                    this.index++;
                };
                EllipseIterator.pcv_$LI$ = function () { if (EllipseIterator.pcv == null)
                    EllipseIterator.pcv = 0.5 + EllipseIterator.CtrlVal * 0.5; return EllipseIterator.pcv; };
                ;
                EllipseIterator.ncv_$LI$ = function () { if (EllipseIterator.ncv == null)
                    EllipseIterator.ncv = 0.5 - EllipseIterator.CtrlVal * 0.5; return EllipseIterator.ncv; };
                ;
                EllipseIterator.ctrlpts_$LI$ = function () { if (EllipseIterator.ctrlpts == null)
                    EllipseIterator.ctrlpts = [[1.0, EllipseIterator.pcv_$LI$(), EllipseIterator.pcv_$LI$(), 1.0, 0.5, 1.0], [EllipseIterator.ncv_$LI$(), 1.0, 0.0, EllipseIterator.pcv_$LI$(), 0.0, 0.5], [0.0, EllipseIterator.ncv_$LI$(), EllipseIterator.ncv_$LI$(), 0.0, 0.5, 0.0], [EllipseIterator.pcv_$LI$(), 0.0, 1.0, EllipseIterator.ncv_$LI$(), 1.0, 0.5]]; return EllipseIterator.ctrlpts; };
                ;
                EllipseIterator.prototype.currentSegment$float_A = function (coords) {
                    if (this.isDone()) {
                        throw Object.defineProperty(new Error("ellipse iterator out of bounds"), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.Object', 'java.lang.RuntimeException', 'java.util.NoSuchElementException', 'java.lang.Exception'] });
                    }
                    if (this.index === 5) {
                        return java.awt.geom.PathIterator.SEG_CLOSE;
                    }
                    if (this.index === 0) {
                        var ctrls_1 = EllipseIterator.ctrlpts_$LI$()[3];
                        coords[0] = (this.x + ctrls_1[4] * this.w);
                        coords[1] = (this.y + ctrls_1[5] * this.h);
                        if (this.affine != null) {
                            this.affine.transform$float_A$int$float_A$int$int(coords, 0, coords, 0, 1);
                        }
                        return java.awt.geom.PathIterator.SEG_MOVETO;
                    }
                    var ctrls = EllipseIterator.ctrlpts_$LI$()[this.index - 1];
                    coords[0] = (this.x + ctrls[0] * this.w);
                    coords[1] = (this.y + ctrls[1] * this.h);
                    coords[2] = (this.x + ctrls[2] * this.w);
                    coords[3] = (this.y + ctrls[3] * this.h);
                    coords[4] = (this.x + ctrls[4] * this.w);
                    coords[5] = (this.y + ctrls[5] * this.h);
                    if (this.affine != null) {
                        this.affine.transform$float_A$int$float_A$int$int(coords, 0, coords, 0, 3);
                    }
                    return java.awt.geom.PathIterator.SEG_CUBICTO;
                };
                /**
                 * Returns the coordinates and type of the current path segment in the
                 * iteration. The return value is the path segment type: SEG_MOVETO,
                 * SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE. A float array of
                 * length 6 must be passed in and may be used to store the coordinates of
                 * the point(s). Each point is stored as a pair of float x,y coordinates.
                 * SEG_MOVETO and SEG_LINETO types will return one point, SEG_QUADTO will
                 * return two points, SEG_CUBICTO will return 3 points and SEG_CLOSE will
                 * not return any points.
                 *
                 * @see #SEG_MOVETO
                 * @see #SEG_LINETO
                 * @see #SEG_QUADTO
                 * @see #SEG_CUBICTO
                 * @see #SEG_CLOSE
                 * @param {Array} coords
                 * @return {number}
                 */
                EllipseIterator.prototype.currentSegment = function (coords) {
                    if (((coords != null && coords instanceof Array && (coords.length == 0 || coords[0] == null || (typeof coords[0] === 'number'))) || coords === null)) {
                        return this.currentSegment$float_A(coords);
                    }
                    else if (((coords != null && coords instanceof Array && (coords.length == 0 || coords[0] == null || (typeof coords[0] === 'number'))) || coords === null)) {
                        return this.currentSegment$double_A(coords);
                    }
                    else
                        throw new Error('invalid overload');
                };
                EllipseIterator.prototype.currentSegment$double_A = function (coords) {
                    if (this.isDone()) {
                        throw Object.defineProperty(new Error("ellipse iterator out of bounds"), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.Object', 'java.lang.RuntimeException', 'java.util.NoSuchElementException', 'java.lang.Exception'] });
                    }
                    if (this.index === 5) {
                        return java.awt.geom.PathIterator.SEG_CLOSE;
                    }
                    if (this.index === 0) {
                        var ctrls_2 = EllipseIterator.ctrlpts_$LI$()[3];
                        coords[0] = this.x + ctrls_2[4] * this.w;
                        coords[1] = this.y + ctrls_2[5] * this.h;
                        if (this.affine != null) {
                            this.affine.transform$double_A$int$double_A$int$int(coords, 0, coords, 0, 1);
                        }
                        return java.awt.geom.PathIterator.SEG_MOVETO;
                    }
                    var ctrls = EllipseIterator.ctrlpts_$LI$()[this.index - 1];
                    coords[0] = this.x + ctrls[0] * this.w;
                    coords[1] = this.y + ctrls[1] * this.h;
                    coords[2] = this.x + ctrls[2] * this.w;
                    coords[3] = this.y + ctrls[3] * this.h;
                    coords[4] = this.x + ctrls[4] * this.w;
                    coords[5] = this.y + ctrls[5] * this.h;
                    if (this.affine != null) {
                        this.affine.transform$double_A$int$double_A$int$int(coords, 0, coords, 0, 3);
                    }
                    return java.awt.geom.PathIterator.SEG_CUBICTO;
                };
                EllipseIterator.CtrlVal = 0.5522847498307933;
                return EllipseIterator;
            }());
            geom.EllipseIterator = EllipseIterator;
            EllipseIterator["__class"] = "java.awt.geom.EllipseIterator";
            EllipseIterator["__interfaces"] = ["java.awt.geom.PathIterator"];
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * A utility class to iterate over the path segments of a rectangle through the
             * PathIterator interface.
             *
             * @author Jim Graham
             * @class
             */
            var RectIterator = /** @class */ (function () {
                function RectIterator(r, at) {
                    if (this.x === undefined)
                        this.x = 0;
                    if (this.y === undefined)
                        this.y = 0;
                    if (this.w === undefined)
                        this.w = 0;
                    if (this.h === undefined)
                        this.h = 0;
                    if (this.affine === undefined)
                        this.affine = null;
                    if (this.index === undefined)
                        this.index = 0;
                    this.x = r.getX();
                    this.y = r.getY();
                    this.w = r.getWidth();
                    this.h = r.getHeight();
                    this.affine = at;
                    if (this.w < 0 || this.h < 0) {
                        this.index = 6;
                    }
                }
                /**
                 * Return the winding rule for determining the insideness of the path.
                 *
                 * @see #WIND_EVEN_ODD
                 * @see #WIND_NON_ZERO
                 * @return {number}
                 */
                RectIterator.prototype.getWindingRule = function () {
                    return java.awt.geom.PathIterator.WIND_NON_ZERO;
                };
                /**
                 * Tests if there are more points to read.
                 *
                 * @return {boolean} true if there are more points to read
                 */
                RectIterator.prototype.isDone = function () {
                    return this.index > 5;
                };
                /**
                 * Moves the iterator to the next segment of the path forwards along the
                 * primary direction of traversal as long as there are more points in that
                 * direction.
                 */
                RectIterator.prototype.next = function () {
                    this.index++;
                };
                RectIterator.prototype.currentSegment$float_A = function (coords) {
                    if (this.isDone()) {
                        throw Object.defineProperty(new Error("rect iterator out of bounds"), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.Object', 'java.lang.RuntimeException', 'java.util.NoSuchElementException', 'java.lang.Exception'] });
                    }
                    if (this.index === 5) {
                        return java.awt.geom.PathIterator.SEG_CLOSE;
                    }
                    coords[0] = this.x;
                    coords[1] = this.y;
                    if (this.index === 1 || this.index === 2) {
                        coords[0] += this.w;
                    }
                    if (this.index === 2 || this.index === 3) {
                        coords[1] += this.h;
                    }
                    if (this.affine != null) {
                        this.affine.transform$float_A$int$float_A$int$int(coords, 0, coords, 0, 1);
                    }
                    return (this.index === 0 ? java.awt.geom.PathIterator.SEG_MOVETO : java.awt.geom.PathIterator.SEG_LINETO);
                };
                /**
                 * Returns the coordinates and type of the current path segment in the
                 * iteration. The return value is the path segment type: SEG_MOVETO,
                 * SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE. A float array of
                 * length 6 must be passed in and may be used to store the coordinates of
                 * the point(s). Each point is stored as a pair of float x,y coordinates.
                 * SEG_MOVETO and SEG_LINETO types will return one point, SEG_QUADTO will
                 * return two points, SEG_CUBICTO will return 3 points and SEG_CLOSE will
                 * not return any points.
                 *
                 * @see #SEG_MOVETO
                 * @see #SEG_LINETO
                 * @see #SEG_QUADTO
                 * @see #SEG_CUBICTO
                 * @see #SEG_CLOSE
                 * @param {Array} coords
                 * @return {number}
                 */
                RectIterator.prototype.currentSegment = function (coords) {
                    if (((coords != null && coords instanceof Array && (coords.length == 0 || coords[0] == null || (typeof coords[0] === 'number'))) || coords === null)) {
                        return this.currentSegment$float_A(coords);
                    }
                    else if (((coords != null && coords instanceof Array && (coords.length == 0 || coords[0] == null || (typeof coords[0] === 'number'))) || coords === null)) {
                        return this.currentSegment$double_A(coords);
                    }
                    else
                        throw new Error('invalid overload');
                };
                RectIterator.prototype.currentSegment$double_A = function (coords) {
                    if (this.isDone()) {
                        throw Object.defineProperty(new Error("rect iterator out of bounds"), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.Object', 'java.lang.RuntimeException', 'java.util.NoSuchElementException', 'java.lang.Exception'] });
                    }
                    if (this.index === 5) {
                        return java.awt.geom.PathIterator.SEG_CLOSE;
                    }
                    coords[0] = this.x;
                    coords[1] = this.y;
                    if (this.index === 1 || this.index === 2) {
                        coords[0] += this.w;
                    }
                    if (this.index === 2 || this.index === 3) {
                        coords[1] += this.h;
                    }
                    if (this.affine != null) {
                        this.affine.transform$double_A$int$double_A$int$int(coords, 0, coords, 0, 1);
                    }
                    return (this.index === 0 ? java.awt.geom.PathIterator.SEG_MOVETO : java.awt.geom.PathIterator.SEG_LINETO);
                };
                return RectIterator;
            }());
            geom.RectIterator = RectIterator;
            RectIterator["__class"] = "java.awt.geom.RectIterator";
            RectIterator["__interfaces"] = ["java.awt.geom.PathIterator"];
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * Constructs a new <code>FlatteningPathIterator</code> object that flattens
             * a path as it iterates over it. The <code>limit</code> parameter allows
             * you to control the maximum number of recursive subdivisions that the
             * iterator can make before it assumes that the curve is flat enough without
             * measuring against the <code>flatness</code> parameter. The flattened
             * iteration therefore never generates more than a maximum of
             * <code>(2^limit)</code> line segments per curve.
             *
             * @param {*} src
             * the original unflattened path being iterated over
             * @param {number} flatness
             * the maximum allowable distance between the control points and
             * the flattened curve
             * @param {number} limit
             * the maximum number of recursive subdivisions allowed for any
             * curved segment
             * @exception IllegalArgumentException
             * if <code>flatness</code> or <code>limit</code> is less
             * than zero
             * @class
             * @author Jim Graham
             */
            var FlatteningPathIterator = /** @class */ (function () {
                function FlatteningPathIterator(src, flatness, limit) {
                    var _this = this;
                    if (((src != null && (src["__interfaces"] != null && src["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0 || src.constructor != null && src.constructor["__interfaces"] != null && src.constructor["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0)) || src === null) && ((typeof flatness === 'number') || flatness === null) && ((typeof limit === 'number') || limit === null)) {
                        var __args = arguments;
                        if (this.src === undefined)
                            this.src = null;
                        if (this.squareflat === undefined)
                            this.squareflat = 0;
                        if (this.limit === undefined)
                            this.limit = 0;
                        if (this.curx === undefined)
                            this.curx = 0;
                        if (this.cury === undefined)
                            this.cury = 0;
                        if (this.movx === undefined)
                            this.movx = 0;
                        if (this.movy === undefined)
                            this.movy = 0;
                        if (this.holdType === undefined)
                            this.holdType = 0;
                        if (this.holdEnd === undefined)
                            this.holdEnd = 0;
                        if (this.holdIndex === undefined)
                            this.holdIndex = 0;
                        if (this.levels === undefined)
                            this.levels = null;
                        if (this.levelIndex === undefined)
                            this.levelIndex = 0;
                        if (this.done === undefined)
                            this.done = false;
                        this.hold = (function (s) { var a = []; while (s-- > 0)
                            a.push(0); return a; })(14);
                        if (this.src === undefined)
                            this.src = null;
                        if (this.squareflat === undefined)
                            this.squareflat = 0;
                        if (this.limit === undefined)
                            this.limit = 0;
                        this.hold = (function (s) { var a = []; while (s-- > 0)
                            a.push(0); return a; })(14);
                        if (this.curx === undefined)
                            this.curx = 0;
                        if (this.cury === undefined)
                            this.cury = 0;
                        if (this.movx === undefined)
                            this.movx = 0;
                        if (this.movy === undefined)
                            this.movy = 0;
                        if (this.holdType === undefined)
                            this.holdType = 0;
                        if (this.holdEnd === undefined)
                            this.holdEnd = 0;
                        if (this.holdIndex === undefined)
                            this.holdIndex = 0;
                        if (this.levels === undefined)
                            this.levels = null;
                        if (this.levelIndex === undefined)
                            this.levelIndex = 0;
                        if (this.done === undefined)
                            this.done = false;
                        (function () {
                            if (flatness < 0.0) {
                                throw Object.defineProperty(new Error("flatness must be >= 0"), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.Object', 'java.lang.RuntimeException', 'java.lang.IllegalArgumentException', 'java.lang.Exception'] });
                            }
                            if (limit < 0) {
                                throw Object.defineProperty(new Error("limit must be >= 0"), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.Object', 'java.lang.RuntimeException', 'java.lang.IllegalArgumentException', 'java.lang.Exception'] });
                            }
                            _this.src = src;
                            _this.squareflat = flatness * flatness;
                            _this.limit = limit;
                            _this.levels = (function (s) { var a = []; while (s-- > 0)
                                a.push(0); return a; })(limit + 1);
                            _this.next$boolean(false);
                        })();
                    }
                    else if (((src != null && (src["__interfaces"] != null && src["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0 || src.constructor != null && src.constructor["__interfaces"] != null && src.constructor["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0)) || src === null) && ((typeof flatness === 'number') || flatness === null) && limit === undefined) {
                        var __args = arguments;
                        {
                            var __args_2 = arguments;
                            var limit_1 = 10;
                            if (this.src === undefined)
                                this.src = null;
                            if (this.squareflat === undefined)
                                this.squareflat = 0;
                            if (this.limit === undefined)
                                this.limit = 0;
                            if (this.curx === undefined)
                                this.curx = 0;
                            if (this.cury === undefined)
                                this.cury = 0;
                            if (this.movx === undefined)
                                this.movx = 0;
                            if (this.movy === undefined)
                                this.movy = 0;
                            if (this.holdType === undefined)
                                this.holdType = 0;
                            if (this.holdEnd === undefined)
                                this.holdEnd = 0;
                            if (this.holdIndex === undefined)
                                this.holdIndex = 0;
                            if (this.levels === undefined)
                                this.levels = null;
                            if (this.levelIndex === undefined)
                                this.levelIndex = 0;
                            if (this.done === undefined)
                                this.done = false;
                            this.hold = (function (s) { var a = []; while (s-- > 0)
                                a.push(0); return a; })(14);
                            if (this.src === undefined)
                                this.src = null;
                            if (this.squareflat === undefined)
                                this.squareflat = 0;
                            if (this.limit === undefined)
                                this.limit = 0;
                            this.hold = (function (s) { var a = []; while (s-- > 0)
                                a.push(0); return a; })(14);
                            if (this.curx === undefined)
                                this.curx = 0;
                            if (this.cury === undefined)
                                this.cury = 0;
                            if (this.movx === undefined)
                                this.movx = 0;
                            if (this.movy === undefined)
                                this.movy = 0;
                            if (this.holdType === undefined)
                                this.holdType = 0;
                            if (this.holdEnd === undefined)
                                this.holdEnd = 0;
                            if (this.holdIndex === undefined)
                                this.holdIndex = 0;
                            if (this.levels === undefined)
                                this.levels = null;
                            if (this.levelIndex === undefined)
                                this.levelIndex = 0;
                            if (this.done === undefined)
                                this.done = false;
                            (function () {
                                if (flatness < 0.0) {
                                    throw Object.defineProperty(new Error("flatness must be >= 0"), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.Object', 'java.lang.RuntimeException', 'java.lang.IllegalArgumentException', 'java.lang.Exception'] });
                                }
                                if (limit_1 < 0) {
                                    throw Object.defineProperty(new Error("limit must be >= 0"), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.Object', 'java.lang.RuntimeException', 'java.lang.IllegalArgumentException', 'java.lang.Exception'] });
                                }
                                _this.src = src;
                                _this.squareflat = flatness * flatness;
                                _this.limit = limit_1;
                                _this.levels = (function (s) { var a = []; while (s-- > 0)
                                    a.push(0); return a; })(limit_1 + 1);
                                _this.next$boolean(false);
                            })();
                        }
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Returns the flatness of this iterator.
                 *
                 * @return {number} the flatness of this <code>FlatteningPathIterator</code>.
                 */
                FlatteningPathIterator.prototype.getFlatness = function () {
                    return Math.sqrt(this.squareflat);
                };
                /**
                 * Returns the recursion limit of this iterator.
                 *
                 * @return {number} the recursion limit of this <code>FlatteningPathIterator</code>.
                 */
                FlatteningPathIterator.prototype.getRecursionLimit = function () {
                    return this.limit;
                };
                /**
                 * Returns the winding rule for determining the interior of the path.
                 *
                 * @return {number} the winding rule of the original unflattened path being iterated
                 * over.
                 * @see PathIterator#WIND_EVEN_ODD
                 * @see PathIterator#WIND_NON_ZERO
                 */
                FlatteningPathIterator.prototype.getWindingRule = function () {
                    return this.src.getWindingRule();
                };
                /**
                 * Tests if the iteration is complete.
                 *
                 * @return {boolean} <code>true</code> if all the segments have been read;
                 * <code>false</code> otherwise.
                 */
                FlatteningPathIterator.prototype.isDone = function () {
                    return this.done;
                };
                FlatteningPathIterator.prototype.ensureHoldCapacity = function (want) {
                    if (this.holdIndex - want < 0) {
                        var have = this.hold.length - this.holdIndex;
                        var newsize = this.hold.length + FlatteningPathIterator.GROW_SIZE;
                        var newhold = (function (s) { var a = []; while (s-- > 0)
                            a.push(0); return a; })(newsize);
                        java.awt.geom.Helper.arraycopy(this.hold, this.holdIndex, newhold, this.holdIndex + FlatteningPathIterator.GROW_SIZE, have);
                        this.hold = newhold;
                        this.holdIndex += FlatteningPathIterator.GROW_SIZE;
                        this.holdEnd += FlatteningPathIterator.GROW_SIZE;
                    }
                };
                FlatteningPathIterator.prototype.next$ = function () {
                    this.next$boolean(true);
                };
                FlatteningPathIterator.prototype.next$boolean = function (doNext) {
                    var level;
                    if (this.holdIndex >= this.holdEnd) {
                        if (doNext) {
                            this.src.next();
                        }
                        if (this.src.isDone()) {
                            this.done = true;
                            return;
                        }
                        this.holdType = this.src['currentSegment$double_A'](this.hold);
                        this.levelIndex = 0;
                        this.levels[0] = 0;
                    }
                    switch ((this.holdType)) {
                        case 0 /* SEG_MOVETO */:
                        case 1 /* SEG_LINETO */:
                            this.curx = this.hold[0];
                            this.cury = this.hold[1];
                            if (this.holdType === java.awt.geom.PathIterator.SEG_MOVETO) {
                                this.movx = this.curx;
                                this.movy = this.cury;
                            }
                            this.holdIndex = 0;
                            this.holdEnd = 0;
                            break;
                        case 4 /* SEG_CLOSE */:
                            this.curx = this.movx;
                            this.cury = this.movy;
                            this.holdIndex = 0;
                            this.holdEnd = 0;
                            break;
                        case 2 /* SEG_QUADTO */:
                            if (this.holdIndex >= this.holdEnd) {
                                this.holdIndex = this.hold.length - 6;
                                this.holdEnd = this.hold.length - 2;
                                this.hold[this.holdIndex + 0] = this.curx;
                                this.hold[this.holdIndex + 1] = this.cury;
                                this.hold[this.holdIndex + 2] = this.hold[0];
                                this.hold[this.holdIndex + 3] = this.hold[1];
                                this.hold[this.holdIndex + 4] = this.curx = this.hold[2];
                                this.hold[this.holdIndex + 5] = this.cury = this.hold[3];
                            }
                            level = this.levels[this.levelIndex];
                            while ((level < this.limit)) {
                                {
                                    if (java.awt.geom.QuadCurve2D.getFlatnessSq$double_A$int(this.hold, this.holdIndex) < this.squareflat) {
                                        break;
                                    }
                                    this.ensureHoldCapacity(4);
                                    java.awt.geom.QuadCurve2D.subdivide$double_A$int$double_A$int$double_A$int(this.hold, this.holdIndex, this.hold, this.holdIndex - 4, this.hold, this.holdIndex);
                                    this.holdIndex -= 4;
                                    level++;
                                    this.levels[this.levelIndex] = level;
                                    this.levelIndex++;
                                    this.levels[this.levelIndex] = level;
                                }
                            }
                            ;
                            this.holdIndex += 4;
                            this.levelIndex--;
                            break;
                        case 3 /* SEG_CUBICTO */:
                            if (this.holdIndex >= this.holdEnd) {
                                this.holdIndex = this.hold.length - 8;
                                this.holdEnd = this.hold.length - 2;
                                this.hold[this.holdIndex + 0] = this.curx;
                                this.hold[this.holdIndex + 1] = this.cury;
                                this.hold[this.holdIndex + 2] = this.hold[0];
                                this.hold[this.holdIndex + 3] = this.hold[1];
                                this.hold[this.holdIndex + 4] = this.hold[2];
                                this.hold[this.holdIndex + 5] = this.hold[3];
                                this.hold[this.holdIndex + 6] = this.curx = this.hold[4];
                                this.hold[this.holdIndex + 7] = this.cury = this.hold[5];
                            }
                            level = this.levels[this.levelIndex];
                            while ((level < this.limit)) {
                                {
                                    if (java.awt.geom.CubicCurve2D.getFlatnessSq$double_A$int(this.hold, this.holdIndex) < this.squareflat) {
                                        break;
                                    }
                                    this.ensureHoldCapacity(6);
                                    java.awt.geom.CubicCurve2D.subdivide$double_A$int$double_A$int$double_A$int(this.hold, this.holdIndex, this.hold, this.holdIndex - 6, this.hold, this.holdIndex);
                                    this.holdIndex -= 6;
                                    level++;
                                    this.levels[this.levelIndex] = level;
                                    this.levelIndex++;
                                    this.levels[this.levelIndex] = level;
                                }
                            }
                            ;
                            this.holdIndex += 6;
                            this.levelIndex--;
                            break;
                    }
                };
                FlatteningPathIterator.prototype.next = function (doNext) {
                    if (((typeof doNext === 'boolean') || doNext === null)) {
                        return this.next$boolean(doNext);
                    }
                    else if (doNext === undefined) {
                        return this.next$();
                    }
                    else
                        throw new Error('invalid overload');
                };
                FlatteningPathIterator.prototype.currentSegment$float_A = function (coords) {
                    if (this.isDone()) {
                        throw Object.defineProperty(new Error("flattening iterator out of bounds"), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.Object', 'java.lang.RuntimeException', 'java.util.NoSuchElementException', 'java.lang.Exception'] });
                    }
                    var type = this.holdType;
                    if (type !== java.awt.geom.PathIterator.SEG_CLOSE) {
                        coords[0] = this.hold[this.holdIndex + 0];
                        coords[1] = this.hold[this.holdIndex + 1];
                        if (type !== java.awt.geom.PathIterator.SEG_MOVETO) {
                            type = java.awt.geom.PathIterator.SEG_LINETO;
                        }
                    }
                    return type;
                };
                /**
                 * Returns the coordinates and type of the current path segment in the
                 * iteration. The return value is the path segment type: SEG_MOVETO,
                 * SEG_LINETO, or SEG_CLOSE. A float array of length 6 must be passed in and
                 * can be used to store the coordinates of the point(s). Each point is
                 * stored as a pair of float x,y coordinates. SEG_MOVETO and SEG_LINETO
                 * types return one point, and SEG_CLOSE does not return any points.
                 *
                 * @param {Array} coords
                 * an array that holds the data returned from this method
                 * @return {number} the path segment type of the current path segment.
                 * @exception NoSuchElementException
                 * if there are no more elements in the flattening path to be
                 * returned.
                 * @see PathIterator#SEG_MOVETO
                 * @see PathIterator#SEG_LINETO
                 * @see PathIterator#SEG_CLOSE
                 */
                FlatteningPathIterator.prototype.currentSegment = function (coords) {
                    if (((coords != null && coords instanceof Array && (coords.length == 0 || coords[0] == null || (typeof coords[0] === 'number'))) || coords === null)) {
                        return this.currentSegment$float_A(coords);
                    }
                    else if (((coords != null && coords instanceof Array && (coords.length == 0 || coords[0] == null || (typeof coords[0] === 'number'))) || coords === null)) {
                        return this.currentSegment$double_A(coords);
                    }
                    else
                        throw new Error('invalid overload');
                };
                FlatteningPathIterator.prototype.currentSegment$double_A = function (coords) {
                    if (this.isDone()) {
                        throw Object.defineProperty(new Error("flattening iterator out of bounds"), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.Object', 'java.lang.RuntimeException', 'java.util.NoSuchElementException', 'java.lang.Exception'] });
                    }
                    var type = this.holdType;
                    if (type !== java.awt.geom.PathIterator.SEG_CLOSE) {
                        coords[0] = this.hold[this.holdIndex + 0];
                        coords[1] = this.hold[this.holdIndex + 1];
                        if (type !== java.awt.geom.PathIterator.SEG_MOVETO) {
                            type = java.awt.geom.PathIterator.SEG_LINETO;
                        }
                    }
                    return type;
                };
                FlatteningPathIterator.GROW_SIZE = 24;
                return FlatteningPathIterator;
            }());
            geom.FlatteningPathIterator = FlatteningPathIterator;
            FlatteningPathIterator["__class"] = "java.awt.geom.FlatteningPathIterator";
            FlatteningPathIterator["__interfaces"] = ["java.awt.geom.PathIterator"];
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * A utility class to iterate over the path segments of a line segment through
             * the PathIterator interface.
             *
             * @author Jim Graham
             * @class
             */
            var LineIterator = /** @class */ (function () {
                function LineIterator(l, at) {
                    if (this.line === undefined)
                        this.line = null;
                    if (this.affine === undefined)
                        this.affine = null;
                    if (this.index === undefined)
                        this.index = 0;
                    this.line = l;
                    this.affine = at;
                }
                /**
                 * Return the winding rule for determining the insideness of the path.
                 *
                 * @see #WIND_EVEN_ODD
                 * @see #WIND_NON_ZERO
                 * @return {number}
                 */
                LineIterator.prototype.getWindingRule = function () {
                    return java.awt.geom.PathIterator.WIND_NON_ZERO;
                };
                /**
                 * Tests if there are more points to read.
                 *
                 * @return {boolean} true if there are more points to read
                 */
                LineIterator.prototype.isDone = function () {
                    return (this.index > 1);
                };
                /**
                 * Moves the iterator to the next segment of the path forwards along the
                 * primary direction of traversal as long as there are more points in that
                 * direction.
                 */
                LineIterator.prototype.next = function () {
                    this.index++;
                };
                LineIterator.prototype.currentSegment$float_A = function (coords) {
                    if (this.isDone()) {
                        throw Object.defineProperty(new Error("line iterator out of bounds"), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.Object', 'java.lang.RuntimeException', 'java.util.NoSuchElementException', 'java.lang.Exception'] });
                    }
                    var type;
                    if (this.index === 0) {
                        coords[0] = this.line.getX1();
                        coords[1] = this.line.getY1();
                        type = java.awt.geom.PathIterator.SEG_MOVETO;
                    }
                    else {
                        coords[0] = this.line.getX2();
                        coords[1] = this.line.getY2();
                        type = java.awt.geom.PathIterator.SEG_LINETO;
                    }
                    if (this.affine != null) {
                        this.affine.transform$float_A$int$float_A$int$int(coords, 0, coords, 0, 1);
                    }
                    return type;
                };
                /**
                 * Returns the coordinates and type of the current path segment in the
                 * iteration. The return value is the path segment type: SEG_MOVETO,
                 * SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE. A float array of
                 * length 6 must be passed in and may be used to store the coordinates of
                 * the point(s). Each point is stored as a pair of float x,y coordinates.
                 * SEG_MOVETO and SEG_LINETO types will return one point, SEG_QUADTO will
                 * return two points, SEG_CUBICTO will return 3 points and SEG_CLOSE will
                 * not return any points.
                 *
                 * @see #SEG_MOVETO
                 * @see #SEG_LINETO
                 * @see #SEG_QUADTO
                 * @see #SEG_CUBICTO
                 * @see #SEG_CLOSE
                 * @param {Array} coords
                 * @return {number}
                 */
                LineIterator.prototype.currentSegment = function (coords) {
                    if (((coords != null && coords instanceof Array && (coords.length == 0 || coords[0] == null || (typeof coords[0] === 'number'))) || coords === null)) {
                        return this.currentSegment$float_A(coords);
                    }
                    else if (((coords != null && coords instanceof Array && (coords.length == 0 || coords[0] == null || (typeof coords[0] === 'number'))) || coords === null)) {
                        return this.currentSegment$double_A(coords);
                    }
                    else
                        throw new Error('invalid overload');
                };
                LineIterator.prototype.currentSegment$double_A = function (coords) {
                    if (this.isDone()) {
                        throw Object.defineProperty(new Error("line iterator out of bounds"), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.Object', 'java.lang.RuntimeException', 'java.util.NoSuchElementException', 'java.lang.Exception'] });
                    }
                    var type;
                    if (this.index === 0) {
                        coords[0] = this.line.getX1();
                        coords[1] = this.line.getY1();
                        type = java.awt.geom.PathIterator.SEG_MOVETO;
                    }
                    else {
                        coords[0] = this.line.getX2();
                        coords[1] = this.line.getY2();
                        type = java.awt.geom.PathIterator.SEG_LINETO;
                    }
                    if (this.affine != null) {
                        this.affine.transform$double_A$int$double_A$int$int(coords, 0, coords, 0, 1);
                    }
                    return type;
                };
                return LineIterator;
            }());
            geom.LineIterator = LineIterator;
            LineIterator["__class"] = "java.awt.geom.LineIterator";
            LineIterator["__interfaces"] = ["java.awt.geom.PathIterator"];
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
(function (sun) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            var Order2 = /** @class */ (function (_super) {
                __extends(Order2, _super);
                function Order2(x0, y0, cx0, cy0, x1, y1, direction) {
                    var _this = _super.call(this, direction) || this;
                    if (_this.x0 === undefined)
                        _this.x0 = 0;
                    if (_this.y0 === undefined)
                        _this.y0 = 0;
                    if (_this.cx0 === undefined)
                        _this.cx0 = 0;
                    if (_this.cy0 === undefined)
                        _this.cy0 = 0;
                    if (_this.x1 === undefined)
                        _this.x1 = 0;
                    if (_this.y1 === undefined)
                        _this.y1 = 0;
                    if (_this.xmin === undefined)
                        _this.xmin = 0;
                    if (_this.xmax === undefined)
                        _this.xmax = 0;
                    if (_this.xcoeff0 === undefined)
                        _this.xcoeff0 = 0;
                    if (_this.xcoeff1 === undefined)
                        _this.xcoeff1 = 0;
                    if (_this.xcoeff2 === undefined)
                        _this.xcoeff2 = 0;
                    if (_this.ycoeff0 === undefined)
                        _this.ycoeff0 = 0;
                    if (_this.ycoeff1 === undefined)
                        _this.ycoeff1 = 0;
                    if (_this.ycoeff2 === undefined)
                        _this.ycoeff2 = 0;
                    if (cy0 < y0) {
                        cy0 = y0;
                    }
                    else if (cy0 > y1) {
                        cy0 = y1;
                    }
                    _this.x0 = x0;
                    _this.y0 = y0;
                    _this.cx0 = cx0;
                    _this.cy0 = cy0;
                    _this.x1 = x1;
                    _this.y1 = y1;
                    _this.xmin = Math.min(Math.min(x0, x1), cx0);
                    _this.xmax = Math.max(Math.max(x0, x1), cx0);
                    _this.xcoeff0 = x0;
                    _this.xcoeff1 = cx0 + cx0 - x0 - x0;
                    _this.xcoeff2 = x0 - cx0 - cx0 + x1;
                    _this.ycoeff0 = y0;
                    _this.ycoeff1 = cy0 + cy0 - y0 - y0;
                    _this.ycoeff2 = y0 - cy0 - cy0 + y1;
                    return _this;
                }
                Order2.insert = function (curves, tmp, x0, y0, cx0, cy0, x1, y1, direction) {
                    var numparams = Order2.getHorizontalParams(y0, cy0, y1, tmp);
                    if (numparams === 0) {
                        Order2.addInstance(curves, x0, y0, cx0, cy0, x1, y1, direction);
                        return;
                    }
                    var t = tmp[0];
                    tmp[0] = x0;
                    tmp[1] = y0;
                    tmp[2] = cx0;
                    tmp[3] = cy0;
                    tmp[4] = x1;
                    tmp[5] = y1;
                    Order2.split(tmp, 0, t);
                    var i0 = (direction === sun.awt.geom.Curve.INCREASING) ? 0 : 4;
                    var i1 = 4 - i0;
                    Order2.addInstance(curves, tmp[i0], tmp[i0 + 1], tmp[i0 + 2], tmp[i0 + 3], tmp[i0 + 4], tmp[i0 + 5], direction);
                    Order2.addInstance(curves, tmp[i1], tmp[i1 + 1], tmp[i1 + 2], tmp[i1 + 3], tmp[i1 + 4], tmp[i1 + 5], direction);
                };
                Order2.addInstance = function (curves, x0, y0, cx0, cy0, x1, y1, direction) {
                    if (y0 > y1) {
                        /* add */ (curves.push(new Order2(x1, y1, cx0, cy0, x0, y0, -direction)) > 0);
                    }
                    else if (y1 > y0) {
                        /* add */ (curves.push(new Order2(x0, y0, cx0, cy0, x1, y1, direction)) > 0);
                    }
                };
                Order2.getHorizontalParams = function (c0, cp, c1, ret) {
                    if (c0 <= cp && cp <= c1) {
                        return 0;
                    }
                    c0 -= cp;
                    c1 -= cp;
                    var denom = c0 + c1;
                    if (denom === 0) {
                        return 0;
                    }
                    var t = c0 / denom;
                    if (t <= 0 || t >= 1) {
                        return 0;
                    }
                    ret[0] = t;
                    return 1;
                };
                Order2.split = function (coords, pos, t) {
                    var x0;
                    var y0;
                    var cx;
                    var cy;
                    var x1;
                    var y1;
                    coords[pos + 8] = x1 = coords[pos + 4];
                    coords[pos + 9] = y1 = coords[pos + 5];
                    cx = coords[pos + 2];
                    cy = coords[pos + 3];
                    x1 = cx + (x1 - cx) * t;
                    y1 = cy + (y1 - cy) * t;
                    x0 = coords[pos + 0];
                    y0 = coords[pos + 1];
                    x0 = x0 + (cx - x0) * t;
                    y0 = y0 + (cy - y0) * t;
                    cx = x0 + (x1 - x0) * t;
                    cy = y0 + (y1 - y0) * t;
                    coords[pos + 2] = x0;
                    coords[pos + 3] = y0;
                    coords[pos + 4] = cx;
                    coords[pos + 5] = cy;
                    coords[pos + 6] = x1;
                    coords[pos + 7] = y1;
                };
                Order2.prototype.getOrder = function () {
                    return 2;
                };
                Order2.prototype.getXTop = function () {
                    return this.x0;
                };
                Order2.prototype.getYTop = function () {
                    return this.y0;
                };
                Order2.prototype.getXBot = function () {
                    return this.x1;
                };
                Order2.prototype.getYBot = function () {
                    return this.y1;
                };
                Order2.prototype.getXMin = function () {
                    return this.xmin;
                };
                Order2.prototype.getXMax = function () {
                    return this.xmax;
                };
                Order2.prototype.getX0 = function () {
                    return (this.direction === sun.awt.geom.Curve.INCREASING) ? this.x0 : this.x1;
                };
                Order2.prototype.getY0 = function () {
                    return (this.direction === sun.awt.geom.Curve.INCREASING) ? this.y0 : this.y1;
                };
                Order2.prototype.getCX0 = function () {
                    return this.cx0;
                };
                Order2.prototype.getCY0 = function () {
                    return this.cy0;
                };
                Order2.prototype.getX1 = function () {
                    return (this.direction === sun.awt.geom.Curve.DECREASING) ? this.x0 : this.x1;
                };
                Order2.prototype.getY1 = function () {
                    return (this.direction === sun.awt.geom.Curve.DECREASING) ? this.y0 : this.y1;
                };
                Order2.prototype.XforY = function (y) {
                    if (y <= this.y0) {
                        return this.x0;
                    }
                    if (y >= this.y1) {
                        return this.x1;
                    }
                    return this.XforT(this.TforY(y));
                };
                Order2.prototype.TforY = function (y) {
                    if (y <= this.y0) {
                        return 0;
                    }
                    if (y >= this.y1) {
                        return 1;
                    }
                    return Order2.TforY(y, this.ycoeff0, this.ycoeff1, this.ycoeff2);
                };
                Order2.TforY = function (y, ycoeff0, ycoeff1, ycoeff2) {
                    ycoeff0 -= y;
                    if (ycoeff2 === 0.0) {
                        var root = -ycoeff0 / ycoeff1;
                        if (root >= 0 && root <= 1) {
                            return root;
                        }
                    }
                    else {
                        var d = ycoeff1 * ycoeff1 - 4.0 * ycoeff2 * ycoeff0;
                        if (d >= 0.0) {
                            d = Math.sqrt(d);
                            if (ycoeff1 < 0.0) {
                                d = -d;
                            }
                            var q = (ycoeff1 + d) / -2.0;
                            var root = q / ycoeff2;
                            if (root >= 0 && root <= 1) {
                                return root;
                            }
                            if (q !== 0.0) {
                                root = ycoeff0 / q;
                                if (root >= 0 && root <= 1) {
                                    return root;
                                }
                            }
                        }
                    }
                    var y0 = ycoeff0;
                    var y1 = ycoeff0 + ycoeff1 + ycoeff2;
                    return (0 < (y0 + y1) / 2) ? 0.0 : 1.0;
                };
                Order2.prototype.XforT = function (t) {
                    return (this.xcoeff2 * t + this.xcoeff1) * t + this.xcoeff0;
                };
                Order2.prototype.YforT = function (t) {
                    return (this.ycoeff2 * t + this.ycoeff1) * t + this.ycoeff0;
                };
                Order2.prototype.dXforT = function (t, deriv) {
                    switch ((deriv)) {
                        case 0:
                            return (this.xcoeff2 * t + this.xcoeff1) * t + this.xcoeff0;
                        case 1:
                            return 2 * this.xcoeff2 * t + this.xcoeff1;
                        case 2:
                            return 2 * this.xcoeff2;
                        default:
                            return 0;
                    }
                };
                Order2.prototype.dYforT = function (t, deriv) {
                    switch ((deriv)) {
                        case 0:
                            return (this.ycoeff2 * t + this.ycoeff1) * t + this.ycoeff0;
                        case 1:
                            return 2 * this.ycoeff2 * t + this.ycoeff1;
                        case 2:
                            return 2 * this.ycoeff2;
                        default:
                            return 0;
                    }
                };
                Order2.prototype.nextVertical = function (t0, t1) {
                    var t = -this.xcoeff1 / (2 * this.xcoeff2);
                    if (t > t0 && t < t1) {
                        return t;
                    }
                    return t1;
                };
                Order2.prototype.enlarge = function (r) {
                    r.add$double$double(this.x0, this.y0);
                    var t = -this.xcoeff1 / (2 * this.xcoeff2);
                    if (t > 0 && t < 1) {
                        r.add$double$double(this.XforT(t), this.YforT(t));
                    }
                    r.add$double$double(this.x1, this.y1);
                };
                Order2.prototype.getSubCurve$double$double$int = function (ystart, yend, dir) {
                    var t0;
                    var t1;
                    if (ystart <= this.y0) {
                        if (yend >= this.y1) {
                            return this.getWithDirection(dir);
                        }
                        t0 = 0;
                    }
                    else {
                        t0 = Order2.TforY(ystart, this.ycoeff0, this.ycoeff1, this.ycoeff2);
                    }
                    if (yend >= this.y1) {
                        t1 = 1;
                    }
                    else {
                        t1 = Order2.TforY(yend, this.ycoeff0, this.ycoeff1, this.ycoeff2);
                    }
                    var eqn = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
                    eqn[0] = this.x0;
                    eqn[1] = this.y0;
                    eqn[2] = this.cx0;
                    eqn[3] = this.cy0;
                    eqn[4] = this.x1;
                    eqn[5] = this.y1;
                    if (t1 < 1) {
                        Order2.split(eqn, 0, t1);
                    }
                    var i;
                    if (t0 <= 0) {
                        i = 0;
                    }
                    else {
                        Order2.split(eqn, 0, t0 / t1);
                        i = 4;
                    }
                    return new Order2(eqn[i + 0], ystart, eqn[i + 2], eqn[i + 3], eqn[i + 4], yend, dir);
                };
                Order2.prototype.getSubCurve = function (ystart, yend, dir) {
                    if (((typeof ystart === 'number') || ystart === null) && ((typeof yend === 'number') || yend === null) && ((typeof dir === 'number') || dir === null)) {
                        return this.getSubCurve$double$double$int(ystart, yend, dir);
                    }
                    else if (((typeof ystart === 'number') || ystart === null) && ((typeof yend === 'number') || yend === null) && dir === undefined) {
                        return this.getSubCurve$double$double(ystart, yend);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Order2.prototype.getReversedCurve = function () {
                    return new Order2(this.x0, this.y0, this.cx0, this.cy0, this.x1, this.y1, -this.direction);
                };
                Order2.prototype.getSegment = function (coords) {
                    coords[0] = this.cx0;
                    coords[1] = this.cy0;
                    if (this.direction === sun.awt.geom.Curve.INCREASING) {
                        coords[2] = this.x1;
                        coords[3] = this.y1;
                    }
                    else {
                        coords[2] = this.x0;
                        coords[3] = this.y0;
                    }
                    return java.awt.geom.PathIterator.SEG_QUADTO;
                };
                Order2.prototype.controlPointString = function () {
                    return ("(" + geom.Curve.round(this.cx0) + ", " + geom.Curve.round(this.cy0) + "), ");
                };
                return Order2;
            }(sun.awt.geom.Curve));
            geom.Order2 = Order2;
            Order2["__class"] = "sun.awt.geom.Order2";
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = sun.awt || (sun.awt = {}));
})(sun || (sun = {}));
(function (sun) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            var Order3 = /** @class */ (function (_super) {
                __extends(Order3, _super);
                function Order3(x0, y0, cx0, cy0, cx1, cy1, x1, y1, direction) {
                    var _this = _super.call(this, direction) || this;
                    if (_this.x0 === undefined)
                        _this.x0 = 0;
                    if (_this.y0 === undefined)
                        _this.y0 = 0;
                    if (_this.cx0 === undefined)
                        _this.cx0 = 0;
                    if (_this.cy0 === undefined)
                        _this.cy0 = 0;
                    if (_this.cx1 === undefined)
                        _this.cx1 = 0;
                    if (_this.cy1 === undefined)
                        _this.cy1 = 0;
                    if (_this.x1 === undefined)
                        _this.x1 = 0;
                    if (_this.y1 === undefined)
                        _this.y1 = 0;
                    if (_this.xmin === undefined)
                        _this.xmin = 0;
                    if (_this.xmax === undefined)
                        _this.xmax = 0;
                    if (_this.xcoeff0 === undefined)
                        _this.xcoeff0 = 0;
                    if (_this.xcoeff1 === undefined)
                        _this.xcoeff1 = 0;
                    if (_this.xcoeff2 === undefined)
                        _this.xcoeff2 = 0;
                    if (_this.xcoeff3 === undefined)
                        _this.xcoeff3 = 0;
                    if (_this.ycoeff0 === undefined)
                        _this.ycoeff0 = 0;
                    if (_this.ycoeff1 === undefined)
                        _this.ycoeff1 = 0;
                    if (_this.ycoeff2 === undefined)
                        _this.ycoeff2 = 0;
                    if (_this.ycoeff3 === undefined)
                        _this.ycoeff3 = 0;
                    if (_this.TforY1 === undefined)
                        _this.TforY1 = 0;
                    if (_this.YforT1 === undefined)
                        _this.YforT1 = 0;
                    if (_this.TforY2 === undefined)
                        _this.TforY2 = 0;
                    if (_this.YforT2 === undefined)
                        _this.YforT2 = 0;
                    if (_this.TforY3 === undefined)
                        _this.TforY3 = 0;
                    if (_this.YforT3 === undefined)
                        _this.YforT3 = 0;
                    if (cy0 < y0)
                        cy0 = y0;
                    if (cy1 > y1)
                        cy1 = y1;
                    _this.x0 = x0;
                    _this.y0 = y0;
                    _this.cx0 = cx0;
                    _this.cy0 = cy0;
                    _this.cx1 = cx1;
                    _this.cy1 = cy1;
                    _this.x1 = x1;
                    _this.y1 = y1;
                    _this.xmin = Math.min(Math.min(x0, x1), Math.min(cx0, cx1));
                    _this.xmax = Math.max(Math.max(x0, x1), Math.max(cx0, cx1));
                    _this.xcoeff0 = x0;
                    _this.xcoeff1 = (cx0 - x0) * 3.0;
                    _this.xcoeff2 = (cx1 - cx0 - cx0 + x0) * 3.0;
                    _this.xcoeff3 = x1 - (cx1 - cx0) * 3.0 - x0;
                    _this.ycoeff0 = y0;
                    _this.ycoeff1 = (cy0 - y0) * 3.0;
                    _this.ycoeff2 = (cy1 - cy0 - cy0 + y0) * 3.0;
                    _this.ycoeff3 = y1 - (cy1 - cy0) * 3.0 - y0;
                    _this.YforT1 = _this.YforT2 = _this.YforT3 = y0;
                    return _this;
                }
                Order3.insert = function (curves, tmp, x0, y0, cx0, cy0, cx1, cy1, x1, y1, direction) {
                    var numparams = Order3.getHorizontalParams(y0, cy0, cy1, y1, tmp);
                    if (numparams === 0) {
                        Order3.addInstance(curves, x0, y0, cx0, cy0, cx1, cy1, x1, y1, direction);
                        return;
                    }
                    tmp[3] = x0;
                    tmp[4] = y0;
                    tmp[5] = cx0;
                    tmp[6] = cy0;
                    tmp[7] = cx1;
                    tmp[8] = cy1;
                    tmp[9] = x1;
                    tmp[10] = y1;
                    var t = tmp[0];
                    if (numparams > 1 && t > tmp[1]) {
                        tmp[0] = tmp[1];
                        tmp[1] = t;
                        t = tmp[0];
                    }
                    Order3.split(tmp, 3, t);
                    if (numparams > 1) {
                        t = (tmp[1] - t) / (1 - t);
                        Order3.split(tmp, 9, t);
                    }
                    var index = 3;
                    if (direction === sun.awt.geom.Curve.DECREASING) {
                        index += numparams * 6;
                    }
                    while ((numparams >= 0)) {
                        {
                            Order3.addInstance(curves, tmp[index + 0], tmp[index + 1], tmp[index + 2], tmp[index + 3], tmp[index + 4], tmp[index + 5], tmp[index + 6], tmp[index + 7], direction);
                            numparams--;
                            if (direction === sun.awt.geom.Curve.INCREASING) {
                                index += 6;
                            }
                            else {
                                index -= 6;
                            }
                        }
                    }
                    ;
                };
                Order3.addInstance = function (curves, x0, y0, cx0, cy0, cx1, cy1, x1, y1, direction) {
                    if (y0 > y1) {
                        /* add */ (curves.push(new Order3(x1, y1, cx1, cy1, cx0, cy0, x0, y0, -direction)) > 0);
                    }
                    else if (y1 > y0) {
                        /* add */ (curves.push(new Order3(x0, y0, cx0, cy0, cx1, cy1, x1, y1, direction)) > 0);
                    }
                };
                Order3.getHorizontalParams = function (c0, cp0, cp1, c1, ret) {
                    if (c0 <= cp0 && cp0 <= cp1 && cp1 <= c1) {
                        return 0;
                    }
                    c1 -= cp1;
                    cp1 -= cp0;
                    cp0 -= c0;
                    ret[0] = cp0;
                    ret[1] = (cp1 - cp0) * 2;
                    ret[2] = (c1 - cp1 - cp1 + cp0);
                    var numroots = java.awt.geom.QuadCurve2D.solveQuadratic$double_A$double_A(ret, ret);
                    var j = 0;
                    for (var i = 0; i < numroots; i++) {
                        {
                            var t = ret[i];
                            if (t > 0 && t < 1) {
                                if (j < i) {
                                    ret[j] = t;
                                }
                                j++;
                            }
                        }
                        ;
                    }
                    return j;
                };
                Order3.split = function (coords, pos, t) {
                    var x0;
                    var y0;
                    var cx0;
                    var cy0;
                    var cx1;
                    var cy1;
                    var x1;
                    var y1;
                    coords[pos + 12] = x1 = coords[pos + 6];
                    coords[pos + 13] = y1 = coords[pos + 7];
                    cx1 = coords[pos + 4];
                    cy1 = coords[pos + 5];
                    x1 = cx1 + (x1 - cx1) * t;
                    y1 = cy1 + (y1 - cy1) * t;
                    x0 = coords[pos + 0];
                    y0 = coords[pos + 1];
                    cx0 = coords[pos + 2];
                    cy0 = coords[pos + 3];
                    x0 = x0 + (cx0 - x0) * t;
                    y0 = y0 + (cy0 - y0) * t;
                    cx0 = cx0 + (cx1 - cx0) * t;
                    cy0 = cy0 + (cy1 - cy0) * t;
                    cx1 = cx0 + (x1 - cx0) * t;
                    cy1 = cy0 + (y1 - cy0) * t;
                    cx0 = x0 + (cx0 - x0) * t;
                    cy0 = y0 + (cy0 - y0) * t;
                    coords[pos + 2] = x0;
                    coords[pos + 3] = y0;
                    coords[pos + 4] = cx0;
                    coords[pos + 5] = cy0;
                    coords[pos + 6] = cx0 + (cx1 - cx0) * t;
                    coords[pos + 7] = cy0 + (cy1 - cy0) * t;
                    coords[pos + 8] = cx1;
                    coords[pos + 9] = cy1;
                    coords[pos + 10] = x1;
                    coords[pos + 11] = y1;
                };
                Order3.prototype.getOrder = function () {
                    return 3;
                };
                Order3.prototype.getXTop = function () {
                    return this.x0;
                };
                Order3.prototype.getYTop = function () {
                    return this.y0;
                };
                Order3.prototype.getXBot = function () {
                    return this.x1;
                };
                Order3.prototype.getYBot = function () {
                    return this.y1;
                };
                Order3.prototype.getXMin = function () {
                    return this.xmin;
                };
                Order3.prototype.getXMax = function () {
                    return this.xmax;
                };
                Order3.prototype.getX0 = function () {
                    return (this.direction === sun.awt.geom.Curve.INCREASING) ? this.x0 : this.x1;
                };
                Order3.prototype.getY0 = function () {
                    return (this.direction === sun.awt.geom.Curve.INCREASING) ? this.y0 : this.y1;
                };
                Order3.prototype.getCX0 = function () {
                    return (this.direction === sun.awt.geom.Curve.INCREASING) ? this.cx0 : this.cx1;
                };
                Order3.prototype.getCY0 = function () {
                    return (this.direction === sun.awt.geom.Curve.INCREASING) ? this.cy0 : this.cy1;
                };
                Order3.prototype.getCX1 = function () {
                    return (this.direction === sun.awt.geom.Curve.DECREASING) ? this.cx0 : this.cx1;
                };
                Order3.prototype.getCY1 = function () {
                    return (this.direction === sun.awt.geom.Curve.DECREASING) ? this.cy0 : this.cy1;
                };
                Order3.prototype.getX1 = function () {
                    return (this.direction === sun.awt.geom.Curve.DECREASING) ? this.x0 : this.x1;
                };
                Order3.prototype.getY1 = function () {
                    return (this.direction === sun.awt.geom.Curve.DECREASING) ? this.y0 : this.y1;
                };
                Order3.prototype.TforY = function (y) {
                    if (y <= this.y0)
                        return 0;
                    if (y >= this.y1)
                        return 1;
                    if (y === this.YforT1)
                        return this.TforY1;
                    if (y === this.YforT2)
                        return this.TforY2;
                    if (y === this.YforT3)
                        return this.TforY3;
                    if (this.ycoeff3 === 0.0) {
                        return sun.awt.geom.Order2.TforY(y, this.ycoeff0, this.ycoeff1, this.ycoeff2);
                    }
                    var a = this.ycoeff2 / this.ycoeff3;
                    var b = this.ycoeff1 / this.ycoeff3;
                    var c = (this.ycoeff0 - y) / this.ycoeff3;
                    var roots = 0;
                    var Q = (a * a - 3.0 * b) / 9.0;
                    var R = (2.0 * a * a * a - 9.0 * a * b + 27.0 * c) / 54.0;
                    var R2 = R * R;
                    var Q3 = Q * Q * Q;
                    var a_3 = a / 3.0;
                    var t;
                    if (R2 < Q3) {
                        var theta = Math.acos(R / Math.sqrt(Q3));
                        Q = -2.0 * Math.sqrt(Q);
                        t = this.refine(a, b, c, y, Q * Math.cos(theta / 3.0) - a_3);
                        if (t < 0) {
                            t = this.refine(a, b, c, y, Q * Math.cos((theta + Math.PI * 2.0) / 3.0) - a_3);
                        }
                        if (t < 0) {
                            t = this.refine(a, b, c, y, Q * Math.cos((theta - Math.PI * 2.0) / 3.0) - a_3);
                        }
                    }
                    else {
                        var neg = (R < 0.0);
                        var S = Math.sqrt(R2 - Q3);
                        if (neg) {
                            R = -R;
                        }
                        var A = Math.pow(R + S, 1.0 / 3.0);
                        if (!neg) {
                            A = -A;
                        }
                        var B = (A === 0.0) ? 0.0 : (Q / A);
                        t = this.refine(a, b, c, y, (A + B) - a_3);
                    }
                    if (t < 0) {
                        var t0 = 0;
                        var t1 = 1;
                        while ((true)) {
                            {
                                t = (t0 + t1) / 2;
                                if (t === t0 || t === t1) {
                                    break;
                                }
                                var yt = this.YforT(t);
                                if (yt < y) {
                                    t0 = t;
                                }
                                else if (yt > y) {
                                    t1 = t;
                                }
                                else {
                                    break;
                                }
                            }
                        }
                        ;
                    }
                    if (t >= 0) {
                        this.TforY3 = this.TforY2;
                        this.YforT3 = this.YforT2;
                        this.TforY2 = this.TforY1;
                        this.YforT2 = this.YforT1;
                        this.TforY1 = t;
                        this.YforT1 = y;
                    }
                    return t;
                };
                Order3.prototype.refine = function (a, b, c, target, t) {
                    if (t < -0.1 || t > 1.1) {
                        return -1;
                    }
                    var y = this.YforT(t);
                    var t0;
                    var t1;
                    if (y < target) {
                        t0 = t;
                        t1 = 1;
                    }
                    else {
                        t0 = 0;
                        t1 = t;
                    }
                    var origt = t;
                    var origy = y;
                    var useslope = true;
                    while ((y !== target)) {
                        {
                            if (!useslope) {
                                var t2 = (t0 + t1) / 2;
                                if (t2 === t0 || t2 === t1) {
                                    break;
                                }
                                t = t2;
                            }
                            else {
                                var slope = this.dYforT(t, 1);
                                if (slope === 0) {
                                    useslope = false;
                                    continue;
                                }
                                var t2 = t + ((target - y) / slope);
                                if (t2 === t || t2 <= t0 || t2 >= t1) {
                                    useslope = false;
                                    continue;
                                }
                                t = t2;
                            }
                            y = this.YforT(t);
                            if (y < target) {
                                t0 = t;
                            }
                            else if (y > target) {
                                t1 = t;
                            }
                            else {
                                break;
                            }
                        }
                    }
                    ;
                    return (t > 1) ? -1 : t;
                };
                Order3.prototype.XforY = function (y) {
                    if (y <= this.y0) {
                        return this.x0;
                    }
                    if (y >= this.y1) {
                        return this.x1;
                    }
                    return this.XforT(this.TforY(y));
                };
                Order3.prototype.XforT = function (t) {
                    return (((this.xcoeff3 * t) + this.xcoeff2) * t + this.xcoeff1) * t + this.xcoeff0;
                };
                Order3.prototype.YforT = function (t) {
                    return (((this.ycoeff3 * t) + this.ycoeff2) * t + this.ycoeff1) * t + this.ycoeff0;
                };
                Order3.prototype.dXforT = function (t, deriv) {
                    switch ((deriv)) {
                        case 0:
                            return (((this.xcoeff3 * t) + this.xcoeff2) * t + this.xcoeff1) * t + this.xcoeff0;
                        case 1:
                            return ((3 * this.xcoeff3 * t) + 2 * this.xcoeff2) * t + this.xcoeff1;
                        case 2:
                            return (6 * this.xcoeff3 * t) + 2 * this.xcoeff2;
                        case 3:
                            return 6 * this.xcoeff3;
                        default:
                            return 0;
                    }
                };
                Order3.prototype.dYforT = function (t, deriv) {
                    switch ((deriv)) {
                        case 0:
                            return (((this.ycoeff3 * t) + this.ycoeff2) * t + this.ycoeff1) * t + this.ycoeff0;
                        case 1:
                            return ((3 * this.ycoeff3 * t) + 2 * this.ycoeff2) * t + this.ycoeff1;
                        case 2:
                            return (6 * this.ycoeff3 * t) + 2 * this.ycoeff2;
                        case 3:
                            return 6 * this.ycoeff3;
                        default:
                            return 0;
                    }
                };
                Order3.prototype.nextVertical = function (t0, t1) {
                    var eqn = [this.xcoeff1, 2 * this.xcoeff2, 3 * this.xcoeff3];
                    var numroots = java.awt.geom.QuadCurve2D.solveQuadratic$double_A$double_A(eqn, eqn);
                    for (var i = 0; i < numroots; i++) {
                        {
                            if (eqn[i] > t0 && eqn[i] < t1) {
                                t1 = eqn[i];
                            }
                        }
                        ;
                    }
                    return t1;
                };
                Order3.prototype.enlarge = function (r) {
                    r.add$double$double(this.x0, this.y0);
                    var eqn = [this.xcoeff1, 2 * this.xcoeff2, 3 * this.xcoeff3];
                    var numroots = java.awt.geom.QuadCurve2D.solveQuadratic$double_A$double_A(eqn, eqn);
                    for (var i = 0; i < numroots; i++) {
                        {
                            var t = eqn[i];
                            if (t > 0 && t < 1) {
                                r.add$double$double(this.XforT(t), this.YforT(t));
                            }
                        }
                        ;
                    }
                    r.add$double$double(this.x1, this.y1);
                };
                Order3.prototype.getSubCurve$double$double$int = function (ystart, yend, dir) {
                    if (ystart <= this.y0 && yend >= this.y1) {
                        return this.getWithDirection(dir);
                    }
                    var eqn = (function (s) { var a = []; while (s-- > 0)
                        a.push(0); return a; })(14);
                    var t0;
                    var t1;
                    t0 = this.TforY(ystart);
                    t1 = this.TforY(yend);
                    eqn[0] = this.x0;
                    eqn[1] = this.y0;
                    eqn[2] = this.cx0;
                    eqn[3] = this.cy0;
                    eqn[4] = this.cx1;
                    eqn[5] = this.cy1;
                    eqn[6] = this.x1;
                    eqn[7] = this.y1;
                    if (t0 > t1) {
                        var t = t0;
                        t0 = t1;
                        t1 = t;
                    }
                    if (t1 < 1) {
                        Order3.split(eqn, 0, t1);
                    }
                    var i;
                    if (t0 <= 0) {
                        i = 0;
                    }
                    else {
                        Order3.split(eqn, 0, t0 / t1);
                        i = 6;
                    }
                    return new Order3(eqn[i + 0], ystart, eqn[i + 2], eqn[i + 3], eqn[i + 4], eqn[i + 5], eqn[i + 6], yend, dir);
                };
                Order3.prototype.getSubCurve = function (ystart, yend, dir) {
                    if (((typeof ystart === 'number') || ystart === null) && ((typeof yend === 'number') || yend === null) && ((typeof dir === 'number') || dir === null)) {
                        return this.getSubCurve$double$double$int(ystart, yend, dir);
                    }
                    else if (((typeof ystart === 'number') || ystart === null) && ((typeof yend === 'number') || yend === null) && dir === undefined) {
                        return this.getSubCurve$double$double(ystart, yend);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Order3.prototype.getReversedCurve = function () {
                    return new Order3(this.x0, this.y0, this.cx0, this.cy0, this.cx1, this.cy1, this.x1, this.y1, -this.direction);
                };
                Order3.prototype.getSegment = function (coords) {
                    if (this.direction === sun.awt.geom.Curve.INCREASING) {
                        coords[0] = this.cx0;
                        coords[1] = this.cy0;
                        coords[2] = this.cx1;
                        coords[3] = this.cy1;
                        coords[4] = this.x1;
                        coords[5] = this.y1;
                    }
                    else {
                        coords[0] = this.cx1;
                        coords[1] = this.cy1;
                        coords[2] = this.cx0;
                        coords[3] = this.cy0;
                        coords[4] = this.x0;
                        coords[5] = this.y0;
                    }
                    return java.awt.geom.PathIterator.SEG_CUBICTO;
                };
                Order3.prototype.controlPointString = function () {
                    return (("(" + geom.Curve.round(this.getCX0()) + ", " + geom.Curve.round(this.getCY0()) + "), ") + ("(" + geom.Curve.round(this.getCX1()) + ", " + geom.Curve.round(this.getCY1()) + "), "));
                };
                return Order3;
            }(sun.awt.geom.Curve));
            geom.Order3 = Order3;
            Order3["__class"] = "sun.awt.geom.Order3";
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = sun.awt || (sun.awt = {}));
})(sun || (sun = {}));
(function (sun) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            var Order0 = /** @class */ (function (_super) {
                __extends(Order0, _super);
                function Order0(x, y) {
                    var _this = _super.call(this, sun.awt.geom.Curve.INCREASING) || this;
                    if (_this.x === undefined)
                        _this.x = 0;
                    if (_this.y === undefined)
                        _this.y = 0;
                    _this.x = x;
                    _this.y = y;
                    return _this;
                }
                Order0.prototype.getOrder = function () {
                    return 0;
                };
                Order0.prototype.getXTop = function () {
                    return this.x;
                };
                Order0.prototype.getYTop = function () {
                    return this.y;
                };
                Order0.prototype.getXBot = function () {
                    return this.x;
                };
                Order0.prototype.getYBot = function () {
                    return this.y;
                };
                Order0.prototype.getXMin = function () {
                    return this.x;
                };
                Order0.prototype.getXMax = function () {
                    return this.x;
                };
                Order0.prototype.getX0 = function () {
                    return this.x;
                };
                Order0.prototype.getY0 = function () {
                    return this.y;
                };
                Order0.prototype.getX1 = function () {
                    return this.x;
                };
                Order0.prototype.getY1 = function () {
                    return this.y;
                };
                Order0.prototype.XforY = function (y) {
                    return y;
                };
                Order0.prototype.TforY = function (y) {
                    return 0;
                };
                Order0.prototype.XforT = function (t) {
                    return this.x;
                };
                Order0.prototype.YforT = function (t) {
                    return this.y;
                };
                Order0.prototype.dXforT = function (t, deriv) {
                    return 0;
                };
                Order0.prototype.dYforT = function (t, deriv) {
                    return 0;
                };
                Order0.prototype.nextVertical = function (t0, t1) {
                    return t1;
                };
                Order0.prototype.crossingsFor = function (x, y) {
                    return 0;
                };
                Order0.prototype.accumulateCrossings = function (c) {
                    return (this.x > c.getXLo() && this.x < c.getXHi() && this.y > c.getYLo() && this.y < c.getYHi());
                };
                Order0.prototype.enlarge = function (r) {
                    r.add$double$double(this.x, this.y);
                };
                Order0.prototype.getSubCurve$double$double$int = function (ystart, yend, dir) {
                    return this;
                };
                Order0.prototype.getSubCurve = function (ystart, yend, dir) {
                    if (((typeof ystart === 'number') || ystart === null) && ((typeof yend === 'number') || yend === null) && ((typeof dir === 'number') || dir === null)) {
                        return this.getSubCurve$double$double$int(ystart, yend, dir);
                    }
                    else if (((typeof ystart === 'number') || ystart === null) && ((typeof yend === 'number') || yend === null) && dir === undefined) {
                        return this.getSubCurve$double$double(ystart, yend);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Order0.prototype.getReversedCurve = function () {
                    return this;
                };
                Order0.prototype.getSegment = function (coords) {
                    coords[0] = this.x;
                    coords[1] = this.y;
                    return java.awt.geom.PathIterator.SEG_MOVETO;
                };
                return Order0;
            }(sun.awt.geom.Curve));
            geom.Order0 = Order0;
            Order0["__class"] = "sun.awt.geom.Order0";
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = sun.awt || (sun.awt = {}));
})(sun || (sun = {}));
(function (sun) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            var Order1 = /** @class */ (function (_super) {
                __extends(Order1, _super);
                function Order1(x0, y0, x1, y1, direction) {
                    var _this = _super.call(this, direction) || this;
                    if (_this.x0 === undefined)
                        _this.x0 = 0;
                    if (_this.y0 === undefined)
                        _this.y0 = 0;
                    if (_this.x1 === undefined)
                        _this.x1 = 0;
                    if (_this.y1 === undefined)
                        _this.y1 = 0;
                    if (_this.xmin === undefined)
                        _this.xmin = 0;
                    if (_this.xmax === undefined)
                        _this.xmax = 0;
                    _this.x0 = x0;
                    _this.y0 = y0;
                    _this.x1 = x1;
                    _this.y1 = y1;
                    if (x0 < x1) {
                        _this.xmin = x0;
                        _this.xmax = x1;
                    }
                    else {
                        _this.xmin = x1;
                        _this.xmax = x0;
                    }
                    return _this;
                }
                Order1.prototype.getOrder = function () {
                    return 1;
                };
                Order1.prototype.getXTop = function () {
                    return this.x0;
                };
                Order1.prototype.getYTop = function () {
                    return this.y0;
                };
                Order1.prototype.getXBot = function () {
                    return this.x1;
                };
                Order1.prototype.getYBot = function () {
                    return this.y1;
                };
                Order1.prototype.getXMin = function () {
                    return this.xmin;
                };
                Order1.prototype.getXMax = function () {
                    return this.xmax;
                };
                Order1.prototype.getX0 = function () {
                    return (this.direction === sun.awt.geom.Curve.INCREASING) ? this.x0 : this.x1;
                };
                Order1.prototype.getY0 = function () {
                    return (this.direction === sun.awt.geom.Curve.INCREASING) ? this.y0 : this.y1;
                };
                Order1.prototype.getX1 = function () {
                    return (this.direction === sun.awt.geom.Curve.DECREASING) ? this.x0 : this.x1;
                };
                Order1.prototype.getY1 = function () {
                    return (this.direction === sun.awt.geom.Curve.DECREASING) ? this.y0 : this.y1;
                };
                Order1.prototype.XforY = function (y) {
                    if (this.x0 === this.x1 || y <= this.y0) {
                        return this.x0;
                    }
                    if (y >= this.y1) {
                        return this.x1;
                    }
                    return (this.x0 + (y - this.y0) * (this.x1 - this.x0) / (this.y1 - this.y0));
                };
                Order1.prototype.TforY = function (y) {
                    if (y <= this.y0) {
                        return 0;
                    }
                    if (y >= this.y1) {
                        return 1;
                    }
                    return (y - this.y0) / (this.y1 - this.y0);
                };
                Order1.prototype.XforT = function (t) {
                    return this.x0 + t * (this.x1 - this.x0);
                };
                Order1.prototype.YforT = function (t) {
                    return this.y0 + t * (this.y1 - this.y0);
                };
                Order1.prototype.dXforT = function (t, deriv) {
                    switch ((deriv)) {
                        case 0:
                            return this.x0 + t * (this.x1 - this.x0);
                        case 1:
                            return (this.x1 - this.x0);
                        default:
                            return 0;
                    }
                };
                Order1.prototype.dYforT = function (t, deriv) {
                    switch ((deriv)) {
                        case 0:
                            return this.y0 + t * (this.y1 - this.y0);
                        case 1:
                            return (this.y1 - this.y0);
                        default:
                            return 0;
                    }
                };
                Order1.prototype.nextVertical = function (t0, t1) {
                    return t1;
                };
                Order1.prototype.accumulateCrossings = function (c) {
                    var xlo = c.getXLo();
                    var ylo = c.getYLo();
                    var xhi = c.getXHi();
                    var yhi = c.getYHi();
                    if (this.xmin >= xhi) {
                        return false;
                    }
                    var xstart;
                    var ystart;
                    var xend;
                    var yend;
                    if (this.y0 < ylo) {
                        if (this.y1 <= ylo) {
                            return false;
                        }
                        ystart = ylo;
                        xstart = this.XforY(ylo);
                    }
                    else {
                        if (this.y0 >= yhi) {
                            return false;
                        }
                        ystart = this.y0;
                        xstart = this.x0;
                    }
                    if (this.y1 > yhi) {
                        yend = yhi;
                        xend = this.XforY(yhi);
                    }
                    else {
                        yend = this.y1;
                        xend = this.x1;
                    }
                    if (xstart >= xhi && xend >= xhi) {
                        return false;
                    }
                    if (xstart > xlo || xend > xlo) {
                        return true;
                    }
                    c.record(ystart, yend, this.direction);
                    return false;
                };
                Order1.prototype.enlarge = function (r) {
                    r.add$double$double(this.x0, this.y0);
                    r.add$double$double(this.x1, this.y1);
                };
                Order1.prototype.getSubCurve$double$double$int = function (ystart, yend, dir) {
                    if (ystart === this.y0 && yend === this.y1) {
                        return this.getWithDirection(dir);
                    }
                    if (this.x0 === this.x1) {
                        return new Order1(this.x0, ystart, this.x1, yend, dir);
                    }
                    var num = this.x0 - this.x1;
                    var denom = this.y0 - this.y1;
                    var xstart = (this.x0 + (ystart - this.y0) * num / denom);
                    var xend = (this.x0 + (yend - this.y0) * num / denom);
                    return new Order1(xstart, ystart, xend, yend, dir);
                };
                Order1.prototype.getSubCurve = function (ystart, yend, dir) {
                    if (((typeof ystart === 'number') || ystart === null) && ((typeof yend === 'number') || yend === null) && ((typeof dir === 'number') || dir === null)) {
                        return this.getSubCurve$double$double$int(ystart, yend, dir);
                    }
                    else if (((typeof ystart === 'number') || ystart === null) && ((typeof yend === 'number') || yend === null) && dir === undefined) {
                        return this.getSubCurve$double$double(ystart, yend);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Order1.prototype.getReversedCurve = function () {
                    return new Order1(this.x0, this.y0, this.x1, this.y1, -this.direction);
                };
                Order1.prototype.compareTo = function (other, yrange) {
                    if (!(other != null && other instanceof sun.awt.geom.Order1)) {
                        return _super.prototype.compareTo.call(this, other, yrange);
                    }
                    var c1 = other;
                    if (yrange[1] <= yrange[0]) {
                        throw Object.defineProperty(new Error("yrange already screwed up..."), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.VirtualMachineError', 'java.lang.InternalError', 'java.lang.Error', 'java.lang.Object'] });
                    }
                    yrange[1] = Math.min(Math.min(yrange[1], this.y1), c1.y1);
                    if (yrange[1] <= yrange[0]) {
                        throw Object.defineProperty(new Error("backstepping from " + yrange[0] + " to " + yrange[1]), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.VirtualMachineError', 'java.lang.InternalError', 'java.lang.Error', 'java.lang.Object'] });
                    }
                    if (this.xmax <= c1.xmin) {
                        return (this.xmin === c1.xmax) ? 0 : -1;
                    }
                    if (this.xmin >= c1.xmax) {
                        return 1;
                    }
                    var dxa = this.x1 - this.x0;
                    var dya = this.y1 - this.y0;
                    var dxb = c1.x1 - c1.x0;
                    var dyb = c1.y1 - c1.y0;
                    var denom = dxb * dya - dxa * dyb;
                    var y;
                    if (denom !== 0) {
                        var num = ((this.x0 - c1.x0) * dya * dyb - this.y0 * dxa * dyb + c1.y0 * dxb * dya);
                        y = num / denom;
                        if (y <= yrange[0]) {
                            y = Math.min(this.y1, c1.y1);
                        }
                        else {
                            if (y < yrange[1]) {
                                yrange[1] = y;
                            }
                            y = Math.max(this.y0, c1.y0);
                        }
                    }
                    else {
                        y = Math.max(this.y0, c1.y0);
                    }
                    return geom.Curve.orderof(this.XforY(y), c1.XforY(y));
                };
                Order1.prototype.getSegment = function (coords) {
                    if (this.direction === sun.awt.geom.Curve.INCREASING) {
                        coords[0] = this.x1;
                        coords[1] = this.y1;
                    }
                    else {
                        coords[0] = this.x0;
                        coords[1] = this.y0;
                    }
                    return java.awt.geom.PathIterator.SEG_LINETO;
                };
                return Order1;
            }(sun.awt.geom.Curve));
            geom.Order1 = Order1;
            Order1["__class"] = "sun.awt.geom.Order1";
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = sun.awt || (sun.awt = {}));
})(sun || (sun = {}));
(function (sun) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            var AreaOp = /** @class */ (function () {
                function AreaOp() {
                    this.verbose = false;
                }
                AreaOp.prototype.calculate = function (left, right) {
                    var edges = ([]);
                    AreaOp.addEdges(edges, left, AreaOp.CTAG_LEFT);
                    AreaOp.addEdges(edges, right, AreaOp.CTAG_RIGHT);
                    edges = this.pruneEdges(edges);
                    if (this.verbose) {
                        console.info("result: ");
                        var numcurves = edges.length;
                        var curvelist = (function (a1, a2) { if (a1.length >= a2.length) {
                            a1.length = 0;
                            a1.push.apply(a1, a2);
                            return a1;
                        }
                        else {
                            return a2.slice(0);
                        } })((function (s) { var a = []; while (s-- > 0)
                            a.push(null); return a; })(numcurves), edges);
                        for (var i = 0; i < numcurves; i++) {
                            {
                                console.info("curvelist[" + i + "] = " + curvelist[i]);
                            }
                            ;
                        }
                    }
                    return edges;
                };
                AreaOp.addEdges = function (edges, curves, curvetag) {
                    for (var index121 = 0; index121 < curves.length; index121++) {
                        var c = curves[index121];
                        {
                            if (c.getOrder() > 0) {
                                /* add */ (edges.push(new sun.awt.geom.Edge(c, curvetag)) > 0);
                            }
                        }
                    }
                };
                AreaOp.YXTopComparator_$LI$ = function () {
                    if (AreaOp.YXTopComparator == null)
                        AreaOp.YXTopComparator = function (o1, o2) {
                            var c1 = o1.getCurve();
                            var c2 = o2.getCurve();
                            var v1;
                            var v2;
                            if ((v1 = c1.getYTop()) === (v2 = c2.getYTop())) {
                                if ((v1 = c1.getXTop()) === (v2 = c2.getXTop())) {
                                    return 0;
                                }
                            }
                            if (v1 < v2) {
                                return -1;
                            }
                            return 1;
                        };
                    return AreaOp.YXTopComparator;
                };
                ;
                AreaOp.prototype.pruneEdges = function (edges) {
                    var numedges = edges.length;
                    if (numedges < 2) {
                        return edges;
                    }
                    var edgelist = (function (a1, a2) { if (a1.length >= a2.length) {
                        a1.length = 0;
                        a1.push.apply(a1, a2);
                        return a1;
                    }
                    else {
                        return a2.slice(0);
                    } })((function (s) { var a = []; while (s-- > 0)
                        a.push(null); return a; })(numedges), edges);
                    /* sort */ (function (l, c) { if (c.compare)
                        l.sort(function (e1, e2) { return c.compare(e1, e2); });
                    else
                        l.sort(c); })(edgelist, AreaOp.YXTopComparator_$LI$());
                    if (this.verbose) {
                        console.info("pruning: ");
                        for (var i = 0; i < numedges; i++) {
                            {
                                console.info("edgelist[" + i + "] = " + edgelist[i]);
                            }
                            ;
                        }
                    }
                    var e;
                    var left = 0;
                    var right = 0;
                    var cur = 0;
                    var next = 0;
                    var yrange = [0, 0];
                    var subcurves = ([]);
                    var chains = ([]);
                    var links = ([]);
                    while ((left < numedges)) {
                        {
                            var y = yrange[0];
                            for (cur = next = right - 1; cur >= left; cur--) {
                                {
                                    e = edgelist[cur];
                                    if (e.getCurve().getYBot() > y) {
                                        if (next > cur) {
                                            edgelist[next] = e;
                                        }
                                        next--;
                                    }
                                }
                                ;
                            }
                            left = next + 1;
                            if (left >= right) {
                                if (right >= numedges) {
                                    break;
                                }
                                y = edgelist[right].getCurve().getYTop();
                                if (y > yrange[0]) {
                                    AreaOp.finalizeSubCurves(subcurves, chains);
                                }
                                yrange[0] = y;
                            }
                            while ((right < numedges)) {
                                {
                                    e = edgelist[right];
                                    if (e.getCurve().getYTop() > y) {
                                        break;
                                    }
                                    right++;
                                }
                            }
                            ;
                            yrange[1] = edgelist[left].getCurve().getYBot();
                            if (right < numedges) {
                                y = edgelist[right].getCurve().getYTop();
                                if (yrange[1] > y) {
                                    yrange[1] = y;
                                }
                            }
                            if (this.verbose) {
                                console.info("current line: y = [" + yrange[0] + ", " + yrange[1] + "]");
                                for (cur = left; cur < right; cur++) {
                                    {
                                        console.info("  " + edgelist[cur]);
                                    }
                                    ;
                                }
                            }
                            var nexteq = 1;
                            for (cur = left; cur < right; cur++) {
                                {
                                    e = edgelist[cur];
                                    e.setEquivalence(0);
                                    for (next = cur; next > left; next--) {
                                        {
                                            var prevedge = edgelist[next - 1];
                                            var ordering = e.compareTo(prevedge, yrange);
                                            if (yrange[1] <= yrange[0]) {
                                                throw Object.defineProperty(new Error("backstepping to " + yrange[1] + " from " + yrange[0]), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.VirtualMachineError', 'java.lang.InternalError', 'java.lang.Error', 'java.lang.Object'] });
                                            }
                                            if (ordering >= 0) {
                                                if (ordering === 0) {
                                                    var eq = prevedge.getEquivalence();
                                                    if (eq === 0) {
                                                        eq = nexteq++;
                                                        prevedge.setEquivalence(eq);
                                                    }
                                                    e.setEquivalence(eq);
                                                }
                                                break;
                                            }
                                            edgelist[next] = prevedge;
                                        }
                                        ;
                                    }
                                    edgelist[next] = e;
                                }
                                ;
                            }
                            if (this.verbose) {
                                console.info("current sorted line: y = [" + yrange[0] + ", " + yrange[1] + "]");
                                for (cur = left; cur < right; cur++) {
                                    {
                                        console.info("  " + edgelist[cur]);
                                    }
                                    ;
                                }
                            }
                            this.newRow();
                            var ystart = yrange[0];
                            var yend = yrange[1];
                            for (cur = left; cur < right; cur++) {
                                {
                                    e = edgelist[cur];
                                    var etag = void 0;
                                    var eq = e.getEquivalence();
                                    if (eq !== 0) {
                                        var origstate = this.getState();
                                        etag = (origstate === AreaOp.RSTAG_INSIDE ? AreaOp.ETAG_EXIT : AreaOp.ETAG_ENTER);
                                        var activematch = null;
                                        var longestmatch = e;
                                        var furthesty = yend;
                                        do {
                                            {
                                                this.classify(e);
                                                if (activematch == null && e.isActiveFor(ystart, etag)) {
                                                    activematch = e;
                                                }
                                                y = e.getCurve().getYBot();
                                                if (y > furthesty) {
                                                    longestmatch = e;
                                                    furthesty = y;
                                                }
                                            }
                                        } while ((++cur < right && (e = edgelist[cur]).getEquivalence() === eq));
                                        --cur;
                                        if (this.getState() === origstate) {
                                            etag = AreaOp.ETAG_IGNORE;
                                        }
                                        else {
                                            e = (activematch != null ? activematch : longestmatch);
                                        }
                                    }
                                    else {
                                        etag = this.classify(e);
                                    }
                                    if (etag !== AreaOp.ETAG_IGNORE) {
                                        e.record(yend, etag);
                                        /* add */ (links.push(new sun.awt.geom.CurveLink(e.getCurve(), ystart, yend, etag)) > 0);
                                    }
                                }
                                ;
                            }
                            if (this.getState() !== AreaOp.RSTAG_OUTSIDE) {
                                console.info("Still inside at end of active edge list!");
                                console.info("num curves = " + (right - left));
                                console.info("num links = " + /* size */ links.length);
                                console.info("y top = " + yrange[0]);
                                if (right < numedges) {
                                    console.info("y top of next curve = " + edgelist[right].getCurve().getYTop());
                                }
                                else {
                                    console.info("no more curves");
                                }
                                for (cur = left; cur < right; cur++) {
                                    {
                                        e = edgelist[cur];
                                        console.info(e);
                                        var eq = e.getEquivalence();
                                        if (eq !== 0) {
                                            console.info("  was equal to " + eq + "...");
                                        }
                                    }
                                    ;
                                }
                            }
                            if (this.verbose) {
                                console.info("new links:");
                                for (var i = 0; i < /* size */ links.length; i++) {
                                    {
                                        var link = links[i];
                                        console.info("  " + link.getSubCurve());
                                    }
                                    ;
                                }
                            }
                            AreaOp.resolveLinks(subcurves, chains, links);
                            /* clear */ (links.length = 0);
                            yrange[0] = yend;
                        }
                    }
                    ;
                    AreaOp.finalizeSubCurves(subcurves, chains);
                    var ret = ([]);
                    var enum_ = (function (a) { var i = 0; return { nextElement: function () { return i < a.length ? a[i++] : null; }, hasMoreElements: function () { return i < a.length; } }; })(subcurves);
                    while ((enum_.hasMoreElements())) {
                        {
                            var link = enum_.nextElement();
                            /* add */ (ret.push(link.getMoveto()) > 0);
                            var nextlink = link;
                            while (((nextlink = nextlink.getNext()) != null)) {
                                {
                                    if (!link.absorb$sun_awt_geom_CurveLink(nextlink)) {
                                        /* add */ (ret.push(link.getSubCurve()) > 0);
                                        link = nextlink;
                                    }
                                }
                            }
                            ;
                            /* add */ (ret.push(link.getSubCurve()) > 0);
                        }
                    }
                    ;
                    return ret;
                };
                AreaOp.finalizeSubCurves = function (subcurves, chains) {
                    var numchains = chains.length;
                    if (numchains === 0) {
                        return;
                    }
                    if ((numchains & 1) !== 0) {
                        throw Object.defineProperty(new Error("Odd number of chains!"), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.VirtualMachineError', 'java.lang.InternalError', 'java.lang.Error', 'java.lang.Object'] });
                    }
                    var endlist = (function (s) { var a = []; while (s-- > 0)
                        a.push(null); return a; })(numchains);
                    /* toArray */ (function (a1, a2) { if (a1.length >= a2.length) {
                        a1.length = 0;
                        a1.push.apply(a1, a2);
                        return a1;
                    }
                    else {
                        return a2.slice(0);
                    } })(endlist, chains);
                    for (var i = 1; i < numchains; i += 2) {
                        {
                            var open_1 = endlist[i - 1];
                            var close_1 = endlist[i];
                            var subcurve = open_1.linkTo(close_1);
                            if (subcurve != null) {
                                /* add */ (subcurves.push(subcurve) > 0);
                            }
                        }
                        ;
                    }
                    /* clear */ (chains.length = 0);
                };
                AreaOp.EmptyLinkList_$LI$ = function () { if (AreaOp.EmptyLinkList == null)
                    AreaOp.EmptyLinkList = [null, null]; return AreaOp.EmptyLinkList; };
                ;
                AreaOp.EmptyChainList_$LI$ = function () { if (AreaOp.EmptyChainList == null)
                    AreaOp.EmptyChainList = [null, null]; return AreaOp.EmptyChainList; };
                ;
                AreaOp.resolveLinks = function (subcurves, chains, links) {
                    var numlinks = links.length;
                    var linklist;
                    if (numlinks === 0) {
                        linklist = AreaOp.EmptyLinkList_$LI$();
                    }
                    else {
                        if ((numlinks & 1) !== 0) {
                            throw Object.defineProperty(new Error("Odd number of new curves!"), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.VirtualMachineError', 'java.lang.InternalError', 'java.lang.Error', 'java.lang.Object'] });
                        }
                        linklist = (function (s) { var a = []; while (s-- > 0)
                            a.push(null); return a; })(numlinks + 2);
                        /* toArray */ (function (a1, a2) { if (a1.length >= a2.length) {
                            a1.length = 0;
                            a1.push.apply(a1, a2);
                            return a1;
                        }
                        else {
                            return a2.slice(0);
                        } })(linklist, links);
                    }
                    var numchains = chains.length;
                    var endlist;
                    if (numchains === 0) {
                        endlist = AreaOp.EmptyChainList_$LI$();
                    }
                    else {
                        if ((numchains & 1) !== 0) {
                            throw Object.defineProperty(new Error("Odd number of chains!"), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.VirtualMachineError', 'java.lang.InternalError', 'java.lang.Error', 'java.lang.Object'] });
                        }
                        endlist = (function (s) { var a = []; while (s-- > 0)
                            a.push(null); return a; })(numchains + 2);
                        /* toArray */ (function (a1, a2) { if (a1.length >= a2.length) {
                            a1.length = 0;
                            a1.push.apply(a1, a2);
                            return a1;
                        }
                        else {
                            return a2.slice(0);
                        } })(endlist, chains);
                    }
                    var curchain = 0;
                    var curlink = 0;
                    /* clear */ (chains.length = 0);
                    var chain = endlist[0];
                    var nextchain = endlist[1];
                    var link = linklist[0];
                    var nextlink = linklist[1];
                    while ((chain != null || link != null)) {
                        {
                            var connectchains = (link == null);
                            var connectlinks = (chain == null);
                            if (!connectchains && !connectlinks) {
                                connectchains = ((curchain & 1) === 0 && chain.getX() === nextchain.getX());
                                connectlinks = ((curlink & 1) === 0 && link.getX() === nextlink.getX());
                                if (!connectchains && !connectlinks) {
                                    var cx = chain.getX();
                                    var lx = link.getX();
                                    connectchains = (nextchain != null && cx < lx && AreaOp.obstructs(nextchain.getX(), lx, curchain));
                                    connectlinks = (nextlink != null && lx < cx && AreaOp.obstructs(nextlink.getX(), cx, curlink));
                                }
                            }
                            if (connectchains) {
                                var subcurve = chain.linkTo(nextchain);
                                if (subcurve != null) {
                                    /* add */ (subcurves.push(subcurve) > 0);
                                }
                                curchain += 2;
                                chain = endlist[curchain];
                                nextchain = endlist[curchain + 1];
                            }
                            if (connectlinks) {
                                var openend = new sun.awt.geom.ChainEnd(link, null);
                                var closeend = new sun.awt.geom.ChainEnd(nextlink, openend);
                                openend.setOtherEnd(closeend);
                                /* add */ (chains.push(openend) > 0);
                                /* add */ (chains.push(closeend) > 0);
                                curlink += 2;
                                link = linklist[curlink];
                                nextlink = linklist[curlink + 1];
                            }
                            if (!connectchains && !connectlinks) {
                                chain.addLink(link);
                                /* add */ (chains.push(chain) > 0);
                                curchain++;
                                chain = nextchain;
                                nextchain = endlist[curchain + 1];
                                curlink++;
                                link = nextlink;
                                nextlink = linklist[curlink + 1];
                            }
                        }
                    }
                    ;
                    if (( /* size */chains.length & 1) !== 0) {
                        console.info("Odd number of chains!");
                    }
                };
                AreaOp.obstructs = function (v1, v2, phase) {
                    return (((phase & 1) === 0) ? (v1 <= v2) : (v1 < v2));
                };
                AreaOp.CTAG_LEFT = 0;
                AreaOp.CTAG_RIGHT = 1;
                AreaOp.ETAG_IGNORE = 0;
                AreaOp.ETAG_ENTER = 1;
                AreaOp.ETAG_EXIT = -1;
                AreaOp.RSTAG_INSIDE = 1;
                AreaOp.RSTAG_OUTSIDE = -1;
                return AreaOp;
            }());
            geom.AreaOp = AreaOp;
            AreaOp["__class"] = "sun.awt.geom.AreaOp";
            (function (AreaOp) {
                var CAGOp = /** @class */ (function (_super) {
                    __extends(CAGOp, _super);
                    function CAGOp() {
                        var _this = _super.call(this) || this;
                        if (_this.inLeft === undefined)
                            _this.inLeft = false;
                        if (_this.inRight === undefined)
                            _this.inRight = false;
                        if (_this.inResult === undefined)
                            _this.inResult = false;
                        return _this;
                    }
                    CAGOp.prototype.newRow = function () {
                        this.inLeft = false;
                        this.inRight = false;
                        this.inResult = false;
                    };
                    CAGOp.prototype.classify = function (e) {
                        if (e.getCurveTag() === sun.awt.geom.AreaOp.CTAG_LEFT) {
                            this.inLeft = !this.inLeft;
                        }
                        else {
                            this.inRight = !this.inRight;
                        }
                        var newClass = this.newClassification(this.inLeft, this.inRight);
                        if (this.inResult === newClass) {
                            return sun.awt.geom.AreaOp.ETAG_IGNORE;
                        }
                        this.inResult = newClass;
                        return (newClass ? sun.awt.geom.AreaOp.ETAG_ENTER : sun.awt.geom.AreaOp.ETAG_EXIT);
                    };
                    CAGOp.prototype.getState = function () {
                        return (this.inResult ? sun.awt.geom.AreaOp.RSTAG_INSIDE : sun.awt.geom.AreaOp.RSTAG_OUTSIDE);
                    };
                    return CAGOp;
                }(sun.awt.geom.AreaOp));
                AreaOp.CAGOp = CAGOp;
                CAGOp["__class"] = "sun.awt.geom.AreaOp.CAGOp";
                var NZWindOp = /** @class */ (function (_super) {
                    __extends(NZWindOp, _super);
                    function NZWindOp() {
                        var _this = _super.call(this) || this;
                        if (_this.count === undefined)
                            _this.count = 0;
                        return _this;
                    }
                    NZWindOp.prototype.newRow = function () {
                        this.count = 0;
                    };
                    NZWindOp.prototype.classify = function (e) {
                        var newCount = this.count;
                        var type = (newCount === 0 ? sun.awt.geom.AreaOp.ETAG_ENTER : sun.awt.geom.AreaOp.ETAG_IGNORE);
                        newCount += e.getCurve().getDirection();
                        this.count = newCount;
                        return (newCount === 0 ? sun.awt.geom.AreaOp.ETAG_EXIT : type);
                    };
                    NZWindOp.prototype.getState = function () {
                        return ((this.count === 0) ? sun.awt.geom.AreaOp.RSTAG_OUTSIDE : sun.awt.geom.AreaOp.RSTAG_INSIDE);
                    };
                    return NZWindOp;
                }(sun.awt.geom.AreaOp));
                AreaOp.NZWindOp = NZWindOp;
                NZWindOp["__class"] = "sun.awt.geom.AreaOp.NZWindOp";
                var EOWindOp = /** @class */ (function (_super) {
                    __extends(EOWindOp, _super);
                    function EOWindOp() {
                        var _this = _super.call(this) || this;
                        if (_this.inside === undefined)
                            _this.inside = false;
                        return _this;
                    }
                    EOWindOp.prototype.newRow = function () {
                        this.inside = false;
                    };
                    EOWindOp.prototype.classify = function (e) {
                        var newInside = !this.inside;
                        this.inside = newInside;
                        return (newInside ? sun.awt.geom.AreaOp.ETAG_ENTER : sun.awt.geom.AreaOp.ETAG_EXIT);
                    };
                    EOWindOp.prototype.getState = function () {
                        return (this.inside ? sun.awt.geom.AreaOp.RSTAG_INSIDE : sun.awt.geom.AreaOp.RSTAG_OUTSIDE);
                    };
                    return EOWindOp;
                }(sun.awt.geom.AreaOp));
                AreaOp.EOWindOp = EOWindOp;
                EOWindOp["__class"] = "sun.awt.geom.AreaOp.EOWindOp";
                var AddOp = /** @class */ (function (_super) {
                    __extends(AddOp, _super);
                    function AddOp() {
                        return _super.call(this) || this;
                    }
                    AddOp.prototype.newClassification = function (inLeft, inRight) {
                        return (inLeft || inRight);
                    };
                    return AddOp;
                }(AreaOp.CAGOp));
                AreaOp.AddOp = AddOp;
                AddOp["__class"] = "sun.awt.geom.AreaOp.AddOp";
                var SubOp = /** @class */ (function (_super) {
                    __extends(SubOp, _super);
                    function SubOp() {
                        return _super.call(this) || this;
                    }
                    SubOp.prototype.newClassification = function (inLeft, inRight) {
                        return (inLeft && !inRight);
                    };
                    return SubOp;
                }(AreaOp.CAGOp));
                AreaOp.SubOp = SubOp;
                SubOp["__class"] = "sun.awt.geom.AreaOp.SubOp";
                var IntOp = /** @class */ (function (_super) {
                    __extends(IntOp, _super);
                    function IntOp() {
                        return _super.call(this) || this;
                    }
                    IntOp.prototype.newClassification = function (inLeft, inRight) {
                        return (inLeft && inRight);
                    };
                    return IntOp;
                }(AreaOp.CAGOp));
                AreaOp.IntOp = IntOp;
                IntOp["__class"] = "sun.awt.geom.AreaOp.IntOp";
                var XorOp = /** @class */ (function (_super) {
                    __extends(XorOp, _super);
                    function XorOp() {
                        return _super.call(this) || this;
                    }
                    XorOp.prototype.newClassification = function (inLeft, inRight) {
                        return (inLeft !== inRight);
                    };
                    return XorOp;
                }(AreaOp.CAGOp));
                AreaOp.XorOp = XorOp;
                XorOp["__class"] = "sun.awt.geom.AreaOp.XorOp";
            })(AreaOp = geom.AreaOp || (geom.AreaOp = {}));
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = sun.awt || (sun.awt = {}));
})(sun || (sun = {}));
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * The {@code Path2D} class provides a simple, yet flexible shape which
             * represents an arbitrary geometric path. It can fully represent any path which
             * can be iterated by the {@link PathIterator} interface including all of its
             * segment types and winding rules and it implements all of the basic hit
             * testing methods of the {@link Shape} interface.
             * <p>
             * Use {@link Path2D.Float} when dealing with data that can be represented and
             * used with floating point precision. Use {@link Path2D.Double} for data that
             * requires the accuracy or range of double precision.
             * <p>
             * {@code Path2D} provides exactly those facilities required for basic
             * construction and management of a geometric path and implementation of the
             * above interfaces with little added interpretation. If it is useful to
             * manipulate the interiors of closed geometric shapes beyond simple hit testing
             * then the {@link Area} class provides additional capabilities specifically
             * targeted at closed figures. While both classes nominally implement the
             * {@code Shape} interface, they differ in purpose and together they provide two
             * useful views of a geometric shape where {@code Path2D} deals primarily with a
             * trajectory formed by path segments and {@code Area} deals more with
             * interpretation and manipulation of enclosed regions of 2D geometric space.
             * <p>
             * The {@link PathIterator} interface has more detailed descriptions of the
             * types of segments that make up a path and the winding rules that control how
             * to determine which regions are inside or outside the path.
             *
             * @author Jim Graham
             * @since 1.6
             * @class
             */
            var Path2D = /** @class */ (function () {
                function Path2D(rule, initialTypes) {
                    var _this = this;
                    if (((typeof rule === 'number') || rule === null) && ((typeof initialTypes === 'number') || initialTypes === null)) {
                        var __args = arguments;
                        if (this.pointTypes === undefined)
                            this.pointTypes = null;
                        if (this.numTypes === undefined)
                            this.numTypes = 0;
                        if (this.numCoords === undefined)
                            this.numCoords = 0;
                        if (this.windingRule === undefined)
                            this.windingRule = 0;
                        if (this.pointTypes === undefined)
                            this.pointTypes = null;
                        if (this.numTypes === undefined)
                            this.numTypes = 0;
                        if (this.numCoords === undefined)
                            this.numCoords = 0;
                        if (this.windingRule === undefined)
                            this.windingRule = 0;
                        (function () {
                            _this.setWindingRule(rule);
                            _this.pointTypes = (function (s) { var a = []; while (s-- > 0)
                                a.push(0); return a; })(initialTypes);
                        })();
                    }
                    else if (rule === undefined && initialTypes === undefined) {
                        var __args = arguments;
                        if (this.pointTypes === undefined)
                            this.pointTypes = null;
                        if (this.numTypes === undefined)
                            this.numTypes = 0;
                        if (this.numCoords === undefined)
                            this.numCoords = 0;
                        if (this.windingRule === undefined)
                            this.windingRule = 0;
                        if (this.pointTypes === undefined)
                            this.pointTypes = null;
                        if (this.numTypes === undefined)
                            this.numTypes = 0;
                        if (this.numCoords === undefined)
                            this.numCoords = 0;
                        if (this.windingRule === undefined)
                            this.windingRule = 0;
                    }
                    else
                        throw new Error('invalid overload');
                }
                Path2D.WIND_EVEN_ODD_$LI$ = function () { if (Path2D.WIND_EVEN_ODD == null)
                    Path2D.WIND_EVEN_ODD = java.awt.geom.PathIterator.WIND_EVEN_ODD; return Path2D.WIND_EVEN_ODD; };
                ;
                Path2D.WIND_NON_ZERO_$LI$ = function () { if (Path2D.WIND_NON_ZERO == null)
                    Path2D.WIND_NON_ZERO = java.awt.geom.PathIterator.WIND_NON_ZERO; return Path2D.WIND_NON_ZERO; };
                ;
                Path2D.SEG_MOVETO_$LI$ = function () { if (Path2D.SEG_MOVETO == null)
                    Path2D.SEG_MOVETO = (java.awt.geom.PathIterator.SEG_MOVETO | 0); return Path2D.SEG_MOVETO; };
                ;
                Path2D.SEG_LINETO_$LI$ = function () { if (Path2D.SEG_LINETO == null)
                    Path2D.SEG_LINETO = (java.awt.geom.PathIterator.SEG_LINETO | 0); return Path2D.SEG_LINETO; };
                ;
                Path2D.SEG_QUADTO_$LI$ = function () { if (Path2D.SEG_QUADTO == null)
                    Path2D.SEG_QUADTO = (java.awt.geom.PathIterator.SEG_QUADTO | 0); return Path2D.SEG_QUADTO; };
                ;
                Path2D.SEG_CUBICTO_$LI$ = function () { if (Path2D.SEG_CUBICTO == null)
                    Path2D.SEG_CUBICTO = (java.awt.geom.PathIterator.SEG_CUBICTO | 0); return Path2D.SEG_CUBICTO; };
                ;
                Path2D.SEG_CLOSE_$LI$ = function () { if (Path2D.SEG_CLOSE == null)
                    Path2D.SEG_CLOSE = (java.awt.geom.PathIterator.SEG_CLOSE | 0); return Path2D.SEG_CLOSE; };
                ;
                Path2D.prototype.append$float$float = function (x, y) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
                Path2D.prototype.append$double$double = function (x, y) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
                /**
                 * Closes the current subpath by drawing a straight line back to the
                 * coordinates of the last {@code moveTo}. If the path is already closed
                 * then this method has no effect.
                 *
                 * @since 1.6
                 */
                Path2D.prototype.closePath = function () {
                    if (this.numTypes === 0 || this.pointTypes[this.numTypes - 1] !== Path2D.SEG_CLOSE_$LI$()) {
                        this.needRoom(true, 0);
                        this.pointTypes[this.numTypes++] = Path2D.SEG_CLOSE_$LI$();
                    }
                };
                Path2D.prototype.append$java_awt_Shape$boolean = function (s, connect) {
                    this.append$java_awt_geom_PathIterator$boolean(s['getPathIterator$java_awt_geom_AffineTransform'](null), connect);
                };
                /**
                 * Appends the geometry of the specified {@code Shape} object to the path,
                 * possibly connecting the new geometry to the existing path segments with a
                 * line segment. If the {@code connect} parameter is {@code true} and the
                 * path is not empty then any initial {@code moveTo} in the geometry of the
                 * appended {@code Shape} is turned into a {@code lineTo} segment. If the
                 * destination coordinates of such a connecting {@code lineTo} segment match
                 * the ending coordinates of a currently open subpath then the segment is
                 * omitted as superfluous. The winding rule of the specified {@code Shape}
                 * is ignored and the appended geometry is governed by the winding rule
                 * specified for this path.
                 *
                 * @param {*} s
                 * the {@code Shape} whose geometry is appended to this path
                 * @param {boolean} connect
                 * a boolean to control whether or not to turn an initial
                 * {@code moveTo} segment into a {@code lineTo} segment to
                 * connect the new geometry to the existing path
                 * @since 1.6
                 */
                Path2D.prototype.append = function (s, connect) {
                    if (((s != null && (s["__interfaces"] != null && s["__interfaces"].indexOf("java.awt.Shape") >= 0 || s.constructor != null && s.constructor["__interfaces"] != null && s.constructor["__interfaces"].indexOf("java.awt.Shape") >= 0)) || s === null) && ((typeof connect === 'boolean') || connect === null)) {
                        return this.append$java_awt_Shape$boolean(s, connect);
                    }
                    else if (((s != null && (s["__interfaces"] != null && s["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0 || s.constructor != null && s.constructor["__interfaces"] != null && s.constructor["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0)) || s === null) && ((typeof connect === 'boolean') || connect === null)) {
                        return this.append$java_awt_geom_PathIterator$boolean(s, connect);
                    }
                    else if (((typeof s === 'number') || s === null) && ((typeof connect === 'number') || connect === null)) {
                        return this.append$float$float(s, connect);
                    }
                    else if (((typeof s === 'number') || s === null) && ((typeof connect === 'number') || connect === null)) {
                        return this.append$double$double(s, connect);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Path2D.prototype.append$java_awt_geom_PathIterator$boolean = function (pi, connect) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
                /**
                 * Returns the fill style winding rule.
                 *
                 * @return {number} an integer representing the current winding rule.
                 * @see #WIND_EVEN_ODD
                 * @see #WIND_NON_ZERO
                 * @see #setWindingRule
                 * @since 1.6
                 */
                Path2D.prototype.getWindingRule = function () {
                    return this.windingRule;
                };
                /**
                 * Sets the winding rule for this path to the specified value.
                 *
                 * @param {number} rule
                 * an integer representing the specified winding rule
                 * @exception IllegalArgumentException
                 * if {@code rule} is not either {@link #WIND_EVEN_ODD} or
                 * {@link #WIND_NON_ZERO}
                 * @see #getWindingRule
                 * @since 1.6
                 */
                Path2D.prototype.setWindingRule = function (rule) {
                    if (rule !== Path2D.WIND_EVEN_ODD_$LI$() && rule !== Path2D.WIND_NON_ZERO_$LI$()) {
                        throw Object.defineProperty(new Error("winding rule must be WIND_EVEN_ODD or WIND_NON_ZERO"), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.Object', 'java.lang.RuntimeException', 'java.lang.IllegalArgumentException', 'java.lang.Exception'] });
                    }
                    this.windingRule = rule;
                };
                /**
                 * Returns the coordinates most recently added to the end of the path as a
                 * {@link Point2D} object.
                 *
                 * @return {java.awt.geom.Point2D} a {@code Point2D} object containing the ending coordinates of the
                 * path or {@code null} if there are no points in the path.
                 * @since 1.6
                 */
                Path2D.prototype.getCurrentPoint = function () {
                    var index = this.numCoords;
                    if (this.numTypes < 1 || index < 1) {
                        return null;
                    }
                    if (this.pointTypes[this.numTypes - 1] === Path2D.SEG_CLOSE_$LI$()) {
                        loop: for (var i = this.numTypes - 2; i > 0; i--) {
                            {
                                switch ((this.pointTypes[i])) {
                                    case 0 /* SEG_MOVETO */:
                                        break loop;
                                    case 1 /* SEG_LINETO */:
                                        index -= 2;
                                        break;
                                    case 2 /* SEG_QUADTO */:
                                        index -= 4;
                                        break;
                                    case 3 /* SEG_CUBICTO */:
                                        index -= 6;
                                        break;
                                    case 4 /* SEG_CLOSE */:
                                        break;
                                }
                            }
                            ;
                        }
                    }
                    return this.getPoint(index - 2);
                };
                /**
                 * Resets the path to empty. The append position is set back to the
                 * beginning of the path and all coordinates and point types are forgotten.
                 *
                 * @since 1.6
                 */
                Path2D.prototype.reset = function () {
                    this.numTypes = this.numCoords = 0;
                };
                /**
                 * Returns a new {@code Shape} representing a transformed version of this
                 * {@code Path2D}. Note that the exact type and coordinate precision of the
                 * return value is not specified for this method. The method will return a
                 * Shape that contains no less precision for the transformed geometry than
                 * this {@code Path2D} currently maintains, but it may contain no more
                 * precision either. If the tradeoff of precision vs. storage size in the
                 * result is important then the convenience constructors in the
                 * {@link Path2D.Float#Path2D.Float(Shape, AffineTransform) Path2D.Float}
                 * and {@link Path2D.Double#Path2D.Double(Shape, AffineTransform)
                 * Path2D.Double} subclasses should be used to make the choice explicit.
                 *
                 * @param {java.awt.geom.AffineTransform} at
                 * the {@code AffineTransform} used to transform a new
                 * {@code Shape}.
                 * @return {*} a new {@code Shape}, transformed with the specified
                 * {@code AffineTransform}.
                 * @since 1.6
                 */
                Path2D.prototype.createTransformedShape = function (at) {
                    var p2d = (function (o) { if (o.clone != undefined) {
                        return o.clone();
                    }
                    else {
                        var clone = Object.create(o);
                        for (var p in o) {
                            if (o.hasOwnProperty(p))
                                clone[p] = o[p];
                        }
                        return clone;
                    } })(this);
                    if (at != null) {
                        p2d.transform(at);
                    }
                    return p2d;
                };
                Path2D.contains$java_awt_geom_PathIterator$double$double = function (pi, x, y) {
                    if (x * 0.0 + y * 0.0 === 0.0) {
                        var mask = (pi.getWindingRule() === Path2D.WIND_NON_ZERO_$LI$() ? -1 : 1);
                        var cross = sun.awt.geom.Curve.pointCrossingsForPath(pi, x, y);
                        return ((cross & mask) !== 0);
                    }
                    else {
                        return false;
                    }
                };
                Path2D.contains$java_awt_geom_PathIterator$java_awt_geom_Point2D = function (pi, p) {
                    return Path2D.contains$java_awt_geom_PathIterator$double$double(pi, p.getX(), p.getY());
                };
                Path2D.prototype.contains$double$double = function (x, y) {
                    if (x * 0.0 + y * 0.0 === 0.0) {
                        if (this.numTypes < 2) {
                            return false;
                        }
                        var mask = (this.windingRule === Path2D.WIND_NON_ZERO_$LI$() ? -1 : 1);
                        return ((this.pointCrossings(x, y) & mask) !== 0);
                    }
                    else {
                        return false;
                    }
                };
                Path2D.prototype.contains$java_awt_geom_Point2D = function (p) {
                    return this.contains$double$double(p.getX(), p.getY());
                };
                Path2D.contains$java_awt_geom_PathIterator$double$double$double$double = function (pi, x, y, w, h) {
                    if ( /* isNaN */isNaN(x + w) || /* isNaN */ isNaN(y + h)) {
                        return false;
                    }
                    if (w <= 0 || h <= 0) {
                        return false;
                    }
                    var mask = (pi.getWindingRule() === Path2D.WIND_NON_ZERO_$LI$() ? -1 : 2);
                    var crossings = sun.awt.geom.Curve.rectCrossingsForPath(pi, x, y, x + w, y + h);
                    return (crossings !== sun.awt.geom.Curve.RECT_INTERSECTS && (crossings & mask) !== 0);
                };
                /**
                 * Tests if the specified rectangular area is entirely inside the closed
                 * boundary of the specified {@link PathIterator}.
                 * <p>
                 * This method provides a basic facility for implementors of the
                 * {@link Shape} interface to implement support for the
                 * {@link Shape#contains(double, double, double, double)} method.
                 * <p>
                 * This method object may conservatively return false in cases where the
                 * specified rectangular area intersects a segment of the path, but that
                 * segment does not represent a boundary between the interior and exterior
                 * of the path. Such segments could lie entirely within the interior of the
                 * path if they are part of a path with a {@link #WIND_NON_ZERO} winding
                 * rule or if the segments are retraced in the reverse direction such that
                 * the two sets of segments cancel each other out without any exterior area
                 * falling between them. To determine whether segments represent true
                 * boundaries of the interior of the path would require extensive
                 * calculations involving all of the segments of the path and the winding
                 * rule and are thus beyond the scope of this implementation.
                 *
                 * @param {*} pi
                 * the specified {@code PathIterator}
                 * @param {number} x
                 * the specified X coordinate
                 * @param {number} y
                 * the specified Y coordinate
                 * @param {number} w
                 * the width of the specified rectangular area
                 * @param {number} h
                 * the height of the specified rectangular area
                 * @return {boolean} {@code true} if the specified {@code PathIterator} contains the
                 * specified rectangular area; {@code false} otherwise.
                 * @since 1.6
                 */
                Path2D.contains = function (pi, x, y, w, h) {
                    if (((pi != null && (pi["__interfaces"] != null && pi["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0 || pi.constructor != null && pi.constructor["__interfaces"] != null && pi.constructor["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0)) || pi === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        return java.awt.geom.Path2D.contains$java_awt_geom_PathIterator$double$double$double$double(pi, x, y, w, h);
                    }
                    else if (((pi != null && (pi["__interfaces"] != null && pi["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0 || pi.constructor != null && pi.constructor["__interfaces"] != null && pi.constructor["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0)) || pi === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && w === undefined && h === undefined) {
                        return java.awt.geom.Path2D.contains$java_awt_geom_PathIterator$double$double(pi, x, y);
                    }
                    else if (((pi != null && (pi["__interfaces"] != null && pi["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0 || pi.constructor != null && pi.constructor["__interfaces"] != null && pi.constructor["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0)) || pi === null) && ((x != null && x instanceof java.awt.geom.Point2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return java.awt.geom.Path2D.contains$java_awt_geom_PathIterator$java_awt_geom_Point2D(pi, x);
                    }
                    else if (((pi != null && (pi["__interfaces"] != null && pi["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0 || pi.constructor != null && pi.constructor["__interfaces"] != null && pi.constructor["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0)) || pi === null) && ((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return java.awt.geom.Path2D.contains$java_awt_geom_PathIterator$java_awt_geom_Rectangle2D(pi, x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Path2D.contains$java_awt_geom_PathIterator$java_awt_geom_Rectangle2D = function (pi, r) {
                    return Path2D.contains$java_awt_geom_PathIterator$double$double$double$double(pi, r.getX(), r.getY(), r.getWidth(), r.getHeight());
                };
                Path2D.prototype.contains$double$double$double$double = function (x, y, w, h) {
                    if ( /* isNaN */isNaN(x + w) || /* isNaN */ isNaN(y + h)) {
                        return false;
                    }
                    if (w <= 0 || h <= 0) {
                        return false;
                    }
                    var mask = (this.windingRule === Path2D.WIND_NON_ZERO_$LI$() ? -1 : 2);
                    var crossings = this.rectCrossings(x, y, x + w, y + h);
                    return (crossings !== sun.awt.geom.Curve.RECT_INTERSECTS && (crossings & mask) !== 0);
                };
                /**
                 * {@inheritDoc}
                 * <p>
                 * This method object may conservatively return false in cases where the
                 * specified rectangular area intersects a segment of the path, but that
                 * segment does not represent a boundary between the interior and exterior
                 * of the path. Such segments could lie entirely within the interior of the
                 * path if they are part of a path with a {@link #WIND_NON_ZERO} winding
                 * rule or if the segments are retraced in the reverse direction such that
                 * the two sets of segments cancel each other out without any exterior area
                 * falling between them. To determine whether segments represent true
                 * boundaries of the interior of the path would require extensive
                 * calculations involving all of the segments of the path and the winding
                 * rule and are thus beyond the scope of this implementation.
                 *
                 * @since 1.6
                 * @param {number} x
                 * @param {number} y
                 * @param {number} w
                 * @param {number} h
                 * @return {boolean}
                 */
                Path2D.prototype.contains = function (x, y, w, h) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        return this.contains$double$double$double$double(x, y, w, h);
                    }
                    else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && w === undefined && h === undefined) {
                        return this.contains$double$double(x, y);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.contains$java_awt_geom_Point2D(x);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.contains$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Path2D.prototype.contains$java_awt_geom_Rectangle2D = function (r) {
                    return this.contains$double$double$double$double(r.getX(), r.getY(), r.getWidth(), r.getHeight());
                };
                Path2D.intersects$java_awt_geom_PathIterator$double$double$double$double = function (pi, x, y, w, h) {
                    if ( /* isNaN */isNaN(x + w) || /* isNaN */ isNaN(y + h)) {
                        return false;
                    }
                    if (w <= 0 || h <= 0) {
                        return false;
                    }
                    var mask = (pi.getWindingRule() === Path2D.WIND_NON_ZERO_$LI$() ? -1 : 2);
                    var crossings = sun.awt.geom.Curve.rectCrossingsForPath(pi, x, y, x + w, y + h);
                    return (crossings === sun.awt.geom.Curve.RECT_INTERSECTS || (crossings & mask) !== 0);
                };
                /**
                 * Tests if the interior of the specified {@link PathIterator} intersects
                 * the interior of a specified set of rectangular coordinates.
                 * <p>
                 * This method provides a basic facility for implementors of the
                 * {@link Shape} interface to implement support for the
                 * {@link Shape#intersects(double, double, double, double)} method.
                 * <p>
                 * This method object may conservatively return true in cases where the
                 * specified rectangular area intersects a segment of the path, but that
                 * segment does not represent a boundary between the interior and exterior
                 * of the path. Such a case may occur if some set of segments of the path
                 * are retraced in the reverse direction such that the two sets of segments
                 * cancel each other out without any interior area between them. To
                 * determine whether segments represent true boundaries of the interior of
                 * the path would require extensive calculations involving all of the
                 * segments of the path and the winding rule and are thus beyond the scope
                 * of this implementation.
                 *
                 * @param {*} pi
                 * the specified {@code PathIterator}
                 * @param {number} x
                 * the specified X coordinate
                 * @param {number} y
                 * the specified Y coordinate
                 * @param {number} w
                 * the width of the specified rectangular coordinates
                 * @param {number} h
                 * the height of the specified rectangular coordinates
                 * @return {boolean} {@code true} if the specified {@code PathIterator} and the
                 * interior of the specified set of rectangular coordinates
                 * intersect each other; {@code false} otherwise.
                 * @since 1.6
                 */
                Path2D.intersects = function (pi, x, y, w, h) {
                    if (((pi != null && (pi["__interfaces"] != null && pi["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0 || pi.constructor != null && pi.constructor["__interfaces"] != null && pi.constructor["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0)) || pi === null) && ((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        return java.awt.geom.Path2D.intersects$java_awt_geom_PathIterator$double$double$double$double(pi, x, y, w, h);
                    }
                    else if (((pi != null && (pi["__interfaces"] != null && pi["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0 || pi.constructor != null && pi.constructor["__interfaces"] != null && pi.constructor["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0)) || pi === null) && ((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return java.awt.geom.Path2D.intersects$java_awt_geom_PathIterator$java_awt_geom_Rectangle2D(pi, x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Path2D.intersects$java_awt_geom_PathIterator$java_awt_geom_Rectangle2D = function (pi, r) {
                    return Path2D.intersects$java_awt_geom_PathIterator$double$double$double$double(pi, r.getX(), r.getY(), r.getWidth(), r.getHeight());
                };
                Path2D.prototype.intersects$double$double$double$double = function (x, y, w, h) {
                    if ( /* isNaN */isNaN(x + w) || /* isNaN */ isNaN(y + h)) {
                        return false;
                    }
                    if (w <= 0 || h <= 0) {
                        return false;
                    }
                    var mask = (this.windingRule === Path2D.WIND_NON_ZERO_$LI$() ? -1 : 2);
                    var crossings = this.rectCrossings(x, y, x + w, y + h);
                    return (crossings === sun.awt.geom.Curve.RECT_INTERSECTS || (crossings & mask) !== 0);
                };
                /**
                 * {@inheritDoc}
                 * <p>
                 * This method object may conservatively return true in cases where the
                 * specified rectangular area intersects a segment of the path, but that
                 * segment does not represent a boundary between the interior and exterior
                 * of the path. Such a case may occur if some set of segments of the path
                 * are retraced in the reverse direction such that the two sets of segments
                 * cancel each other out without any interior area between them. To
                 * determine whether segments represent true boundaries of the interior of
                 * the path would require extensive calculations involving all of the
                 * segments of the path and the winding rule and are thus beyond the scope
                 * of this implementation.
                 *
                 * @since 1.6
                 * @param {number} x
                 * @param {number} y
                 * @param {number} w
                 * @param {number} h
                 * @return {boolean}
                 */
                Path2D.prototype.intersects = function (x, y, w, h) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        return this.intersects$double$double$double$double(x, y, w, h);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.intersects$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Path2D.prototype.intersects$java_awt_geom_Rectangle2D = function (r) {
                    return this.intersects$double$double$double$double(r.getX(), r.getY(), r.getWidth(), r.getHeight());
                };
                Path2D.prototype.getPathIterator$java_awt_geom_AffineTransform$double = function (at, flatness) {
                    return new java.awt.geom.FlatteningPathIterator(this['getPathIterator$java_awt_geom_AffineTransform'](at), flatness);
                };
                /**
                 * {@inheritDoc}
                 * <p>
                 * The iterator for this class is not multi-threaded safe, which means that
                 * this {@code Path2D} class does not guarantee that modifications to the
                 * geometry of this {@code Path2D} object do not affect any iterations of
                 * that geometry that are already in process.
                 *
                 * @since 1.6
                 * @param {java.awt.geom.AffineTransform} at
                 * @param {number} flatness
                 * @return {*}
                 */
                Path2D.prototype.getPathIterator = function (at, flatness) {
                    if (((at != null && at instanceof java.awt.geom.AffineTransform) || at === null) && ((typeof flatness === 'number') || flatness === null)) {
                        return this.getPathIterator$java_awt_geom_AffineTransform$double(at, flatness);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Path2D.INIT_SIZE = 20;
                Path2D.EXPAND_MAX = 500;
                return Path2D;
            }());
            geom.Path2D = Path2D;
            Path2D["__class"] = "java.awt.geom.Path2D";
            Path2D["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable"];
            (function (Path2D) {
                var Iterator = /** @class */ (function () {
                    function Iterator(path) {
                        if (this.typeIdx === undefined)
                            this.typeIdx = 0;
                        if (this.pointIdx === undefined)
                            this.pointIdx = 0;
                        if (this.path === undefined)
                            this.path = null;
                        this.path = path;
                    }
                    Iterator.curvecoords_$LI$ = function () { if (Iterator.curvecoords == null)
                        Iterator.curvecoords = [2, 2, 4, 6, 0]; return Iterator.curvecoords; };
                    ;
                    Iterator.prototype.getWindingRule = function () {
                        return this.path.getWindingRule();
                    };
                    Iterator.prototype.isDone = function () {
                        return (this.typeIdx >= this.path.numTypes);
                    };
                    Iterator.prototype.next = function () {
                        var type = this.path.pointTypes[this.typeIdx++];
                        this.pointIdx += Iterator.curvecoords_$LI$()[type];
                    };
                    return Iterator;
                }());
                Path2D.Iterator = Iterator;
                Iterator["__class"] = "java.awt.geom.Path2D.Iterator";
                Iterator["__interfaces"] = ["java.awt.geom.PathIterator"];
                /**
                 * Constructs a new empty single precision {@code Path2D} object with
                 * the specified winding rule and the specified initial capacity to
                 * store path segments. This number is an initial guess as to how many
                 * path segments will be added to the path, but the storage is expanded
                 * as needed to store whatever path segments are added.
                 *
                 * @param {number} rule
                 * the winding rule
                 * @param {number} initialCapacity
                 * the estimate for the number of path segments in the path
                 * @see #WIND_EVEN_ODD
                 * @see #WIND_NON_ZERO
                 * @since 1.6
                 * @class
                 * @extends java.awt.geom.Path2D
                 */
                var Float = /** @class */ (function (_super) {
                    __extends(Float, _super);
                    function Float(s, at) {
                        var _this = this;
                        if (((s != null && (s["__interfaces"] != null && s["__interfaces"].indexOf("java.awt.Shape") >= 0 || s.constructor != null && s.constructor["__interfaces"] != null && s.constructor["__interfaces"].indexOf("java.awt.Shape") >= 0)) || s === null) && ((at != null && at instanceof java.awt.geom.AffineTransform) || at === null)) {
                            var __args = arguments;
                            _this = _super.call(this) || this;
                            if (_this.floatCoords === undefined)
                                _this.floatCoords = null;
                            if (_this.floatCoords === undefined)
                                _this.floatCoords = null;
                            (function () {
                                if (s != null && s instanceof java.awt.geom.Path2D) {
                                    var p2d = s;
                                    _this.setWindingRule(p2d.windingRule);
                                    _this.numTypes = p2d.numTypes;
                                    _this.pointTypes = /* copyOf */ p2d.pointTypes.slice(0, p2d.pointTypes.length);
                                    _this.numCoords = p2d.numCoords;
                                    _this.floatCoords = p2d.cloneCoordsFloat(at);
                                }
                                else {
                                    var pi = s['getPathIterator$java_awt_geom_AffineTransform'](at);
                                    _this.setWindingRule(pi.getWindingRule());
                                    _this.pointTypes = (function (s) { var a = []; while (s-- > 0)
                                        a.push(0); return a; })(java.awt.geom.Path2D.INIT_SIZE);
                                    _this.floatCoords = (function (s) { var a = []; while (s-- > 0)
                                        a.push(0); return a; })(java.awt.geom.Path2D.INIT_SIZE * 2);
                                    _this.append$java_awt_geom_PathIterator$boolean(pi, false);
                                }
                            })();
                        }
                        else if (((typeof s === 'number') || s === null) && ((typeof at === 'number') || at === null)) {
                            var __args = arguments;
                            var rule = __args[0];
                            var initialCapacity_1 = __args[1];
                            _this = _super.call(this, rule, initialCapacity_1) || this;
                            if (_this.floatCoords === undefined)
                                _this.floatCoords = null;
                            if (_this.floatCoords === undefined)
                                _this.floatCoords = null;
                            (function () {
                                _this.floatCoords = (function (s) { var a = []; while (s-- > 0)
                                    a.push(0); return a; })(initialCapacity_1 * 2);
                            })();
                        }
                        else if (((s != null && (s["__interfaces"] != null && s["__interfaces"].indexOf("java.awt.Shape") >= 0 || s.constructor != null && s.constructor["__interfaces"] != null && s.constructor["__interfaces"].indexOf("java.awt.Shape") >= 0)) || s === null) && at === undefined) {
                            var __args = arguments;
                            {
                                var __args_3 = arguments;
                                var at_1 = null;
                                _this = _super.call(this) || this;
                                if (_this.floatCoords === undefined)
                                    _this.floatCoords = null;
                                if (_this.floatCoords === undefined)
                                    _this.floatCoords = null;
                                (function () {
                                    if (s != null && s instanceof java.awt.geom.Path2D) {
                                        var p2d = s;
                                        _this.setWindingRule(p2d.windingRule);
                                        _this.numTypes = p2d.numTypes;
                                        _this.pointTypes = /* copyOf */ p2d.pointTypes.slice(0, p2d.pointTypes.length);
                                        _this.numCoords = p2d.numCoords;
                                        _this.floatCoords = p2d.cloneCoordsFloat(at_1);
                                    }
                                    else {
                                        var pi = s['getPathIterator$java_awt_geom_AffineTransform'](at_1);
                                        _this.setWindingRule(pi.getWindingRule());
                                        _this.pointTypes = (function (s) { var a = []; while (s-- > 0)
                                            a.push(0); return a; })(java.awt.geom.Path2D.INIT_SIZE);
                                        _this.floatCoords = (function (s) { var a = []; while (s-- > 0)
                                            a.push(0); return a; })(java.awt.geom.Path2D.INIT_SIZE * 2);
                                        _this.append$java_awt_geom_PathIterator$boolean(pi, false);
                                    }
                                })();
                            }
                        }
                        else if (((typeof s === 'number') || s === null) && at === undefined) {
                            var __args = arguments;
                            var rule = __args[0];
                            {
                                var __args_4 = arguments;
                                var initialCapacity_2 = java.awt.geom.Path2D.INIT_SIZE;
                                _this = _super.call(this, rule, initialCapacity_2) || this;
                                if (_this.floatCoords === undefined)
                                    _this.floatCoords = null;
                                if (_this.floatCoords === undefined)
                                    _this.floatCoords = null;
                                (function () {
                                    _this.floatCoords = (function (s) { var a = []; while (s-- > 0)
                                        a.push(0); return a; })(initialCapacity_2 * 2);
                                })();
                            }
                        }
                        else if (s === undefined && at === undefined) {
                            var __args = arguments;
                            {
                                var __args_5 = arguments;
                                var rule = java.awt.geom.Path2D.WIND_NON_ZERO_$LI$();
                                var initialCapacity_3 = java.awt.geom.Path2D.INIT_SIZE;
                                _this = _super.call(this, rule, initialCapacity_3) || this;
                                if (_this.floatCoords === undefined)
                                    _this.floatCoords = null;
                                if (_this.floatCoords === undefined)
                                    _this.floatCoords = null;
                                (function () {
                                    _this.floatCoords = (function (s) { var a = []; while (s-- > 0)
                                        a.push(0); return a; })(initialCapacity_3 * 2);
                                })();
                            }
                        }
                        else
                            throw new Error('invalid overload');
                        return _this;
                    }
                    Float.prototype.cloneCoordsFloat = function (at) {
                        var ret;
                        if (at == null) {
                            ret = /* copyOf */ this.floatCoords.slice(0, this.floatCoords.length);
                        }
                        else {
                            ret = (function (s) { var a = []; while (s-- > 0)
                                a.push(0); return a; })(this.floatCoords.length);
                            at.transform$float_A$int$float_A$int$int(this.floatCoords, 0, ret, 0, (this.numCoords / 2 | 0));
                        }
                        return ret;
                    };
                    Float.prototype.cloneCoordsDouble = function (at) {
                        var ret = (function (s) { var a = []; while (s-- > 0)
                            a.push(0); return a; })(this.floatCoords.length);
                        if (at == null) {
                            for (var i = 0; i < this.numCoords; i++) {
                                {
                                    ret[i] = this.floatCoords[i];
                                }
                                ;
                            }
                        }
                        else {
                            at.transform$float_A$int$double_A$int$int(this.floatCoords, 0, ret, 0, (this.numCoords / 2 | 0));
                        }
                        return ret;
                    };
                    Float.prototype.append$float$float = function (x, y) {
                        this.floatCoords[this.numCoords++] = x;
                        this.floatCoords[this.numCoords++] = y;
                    };
                    Float.prototype.append$double$double = function (x, y) {
                        this.floatCoords[this.numCoords++] = x;
                        this.floatCoords[this.numCoords++] = y;
                    };
                    Float.prototype.getPoint = function (coordindex) {
                        return new java.awt.geom.Point2D.Float(this.floatCoords[coordindex], this.floatCoords[coordindex + 1]);
                    };
                    Float.prototype.needRoom = function (needMove, newCoords) {
                        if (needMove && this.numTypes === 0) {
                            throw Object.defineProperty(new Error("missing initial moveto in path definition"), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.Object', 'java.awt.geom.IllegalPathStateException', 'java.lang.RuntimeException', 'java.lang.Exception'] });
                        }
                        var size = this.pointTypes.length;
                        if (this.numTypes >= size) {
                            var grow = size;
                            if (grow > java.awt.geom.Path2D.EXPAND_MAX) {
                                grow = java.awt.geom.Path2D.EXPAND_MAX;
                            }
                            this.pointTypes = /* copyOf */ this.pointTypes.slice(0, size + grow);
                        }
                        size = this.floatCoords.length;
                        if (this.numCoords + newCoords > size) {
                            var grow = size;
                            if (grow > java.awt.geom.Path2D.EXPAND_MAX * 2) {
                                grow = java.awt.geom.Path2D.EXPAND_MAX * 2;
                            }
                            if (grow < newCoords) {
                                grow = newCoords;
                            }
                            this.floatCoords = /* copyOf */ this.floatCoords.slice(0, size + grow);
                        }
                    };
                    Float.prototype.moveTo$double$double = function (x, y) {
                        if (this.numTypes > 0 && this.pointTypes[this.numTypes - 1] === java.awt.geom.Path2D.SEG_MOVETO_$LI$()) {
                            this.floatCoords[this.numCoords - 2] = x;
                            this.floatCoords[this.numCoords - 1] = y;
                        }
                        else {
                            this.needRoom(false, 2);
                            this.pointTypes[this.numTypes++] = java.awt.geom.Path2D.SEG_MOVETO_$LI$();
                            this.floatCoords[this.numCoords++] = x;
                            this.floatCoords[this.numCoords++] = y;
                        }
                    };
                    Float.prototype.moveTo$float$float = function (x, y) {
                        if (this.numTypes > 0 && this.pointTypes[this.numTypes - 1] === java.awt.geom.Path2D.SEG_MOVETO_$LI$()) {
                            this.floatCoords[this.numCoords - 2] = x;
                            this.floatCoords[this.numCoords - 1] = y;
                        }
                        else {
                            this.needRoom(false, 2);
                            this.pointTypes[this.numTypes++] = java.awt.geom.Path2D.SEG_MOVETO_$LI$();
                            this.floatCoords[this.numCoords++] = x;
                            this.floatCoords[this.numCoords++] = y;
                        }
                    };
                    /**
                     * Adds a point to the path by moving to the specified coordinates
                     * specified in float precision.
                     * <p>
                     * This method provides a single precision variant of the double
                     * precision {@code moveTo()} method on the base {@code Path2D} class.
                     *
                     * @param {number} x
                     * the specified X coordinate
                     * @param {number} y
                     * the specified Y coordinate
                     * @see Path2D#moveTo
                     * @since 1.6
                     */
                    Float.prototype.moveTo = function (x, y) {
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                            return this.moveTo$float$float(x, y);
                        }
                        else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                            return this.moveTo$double$double(x, y);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    Float.prototype.lineTo$double$double = function (x, y) {
                        this.needRoom(true, 2);
                        this.pointTypes[this.numTypes++] = java.awt.geom.Path2D.SEG_LINETO_$LI$();
                        this.floatCoords[this.numCoords++] = x;
                        this.floatCoords[this.numCoords++] = y;
                    };
                    Float.prototype.lineTo$float$float = function (x, y) {
                        this.needRoom(true, 2);
                        this.pointTypes[this.numTypes++] = java.awt.geom.Path2D.SEG_LINETO_$LI$();
                        this.floatCoords[this.numCoords++] = x;
                        this.floatCoords[this.numCoords++] = y;
                    };
                    /**
                     * Adds a point to the path by drawing a straight line from the current
                     * coordinates to the new specified coordinates specified in float
                     * precision.
                     * <p>
                     * This method provides a single precision variant of the double
                     * precision {@code lineTo()} method on the base {@code Path2D} class.
                     *
                     * @param {number} x
                     * the specified X coordinate
                     * @param {number} y
                     * the specified Y coordinate
                     * @see Path2D#lineTo
                     * @since 1.6
                     */
                    Float.prototype.lineTo = function (x, y) {
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                            return this.lineTo$float$float(x, y);
                        }
                        else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                            return this.lineTo$double$double(x, y);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    Float.prototype.quadTo$double$double$double$double = function (x1, y1, x2, y2) {
                        this.needRoom(true, 4);
                        this.pointTypes[this.numTypes++] = java.awt.geom.Path2D.SEG_QUADTO_$LI$();
                        this.floatCoords[this.numCoords++] = x1;
                        this.floatCoords[this.numCoords++] = y1;
                        this.floatCoords[this.numCoords++] = x2;
                        this.floatCoords[this.numCoords++] = y2;
                    };
                    Float.prototype.quadTo$float$float$float$float = function (x1, y1, x2, y2) {
                        this.needRoom(true, 4);
                        this.pointTypes[this.numTypes++] = java.awt.geom.Path2D.SEG_QUADTO_$LI$();
                        this.floatCoords[this.numCoords++] = x1;
                        this.floatCoords[this.numCoords++] = y1;
                        this.floatCoords[this.numCoords++] = x2;
                        this.floatCoords[this.numCoords++] = y2;
                    };
                    /**
                     * Adds a curved segment, defined by two new points, to the path by
                     * drawing a Quadratic curve that intersects both the current
                     * coordinates and the specified coordinates {@code (x2,y2)}, using the
                     * specified point {@code (x1,y1)} as a quadratic parametric control
                     * point. All coordinates are specified in float precision.
                     * <p>
                     * This method provides a single precision variant of the double
                     * precision {@code quadTo()} method on the base {@code Path2D} class.
                     *
                     * @param {number} x1
                     * the X coordinate of the quadratic control point
                     * @param {number} y1
                     * the Y coordinate of the quadratic control point
                     * @param {number} x2
                     * the X coordinate of the final end point
                     * @param {number} y2
                     * the Y coordinate of the final end point
                     * @see Path2D#quadTo
                     * @since 1.6
                     */
                    Float.prototype.quadTo = function (x1, y1, x2, y2) {
                        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                            return this.quadTo$float$float$float$float(x1, y1, x2, y2);
                        }
                        else if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                            return this.quadTo$double$double$double$double(x1, y1, x2, y2);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    Float.prototype.curveTo$double$double$double$double$double$double = function (x1, y1, x2, y2, x3, y3) {
                        this.needRoom(true, 6);
                        this.pointTypes[this.numTypes++] = java.awt.geom.Path2D.SEG_CUBICTO_$LI$();
                        this.floatCoords[this.numCoords++] = x1;
                        this.floatCoords[this.numCoords++] = y1;
                        this.floatCoords[this.numCoords++] = x2;
                        this.floatCoords[this.numCoords++] = y2;
                        this.floatCoords[this.numCoords++] = x3;
                        this.floatCoords[this.numCoords++] = y3;
                    };
                    Float.prototype.curveTo$float$float$float$float$float$float = function (x1, y1, x2, y2, x3, y3) {
                        this.needRoom(true, 6);
                        this.pointTypes[this.numTypes++] = java.awt.geom.Path2D.SEG_CUBICTO_$LI$();
                        this.floatCoords[this.numCoords++] = x1;
                        this.floatCoords[this.numCoords++] = y1;
                        this.floatCoords[this.numCoords++] = x2;
                        this.floatCoords[this.numCoords++] = y2;
                        this.floatCoords[this.numCoords++] = x3;
                        this.floatCoords[this.numCoords++] = y3;
                    };
                    /**
                     * Adds a curved segment, defined by three new points, to the path by
                     * drawing a B&eacute;zier curve that intersects both the current
                     * coordinates and the specified coordinates {@code (x3,y3)}, using the
                     * specified points {@code (x1,y1)} and {@code (x2,y2)} as B&eacute;zier
                     * control points. All coordinates are specified in float precision.
                     * <p>
                     * This method provides a single precision variant of the double
                     * precision {@code curveTo()} method on the base {@code Path2D} class.
                     *
                     * @param {number} x1
                     * the X coordinate of the first B&eacute;zier control point
                     * @param {number} y1
                     * the Y coordinate of the first B&eacute;zier control point
                     * @param {number} x2
                     * the X coordinate of the second B&eacute;zier control point
                     * @param {number} y2
                     * the Y coordinate of the second B&eacute;zier control point
                     * @param {number} x3
                     * the X coordinate of the final end point
                     * @param {number} y3
                     * the Y coordinate of the final end point
                     * @see Path2D#curveTo
                     * @since 1.6
                     */
                    Float.prototype.curveTo = function (x1, y1, x2, y2, x3, y3) {
                        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null) && ((typeof x3 === 'number') || x3 === null) && ((typeof y3 === 'number') || y3 === null)) {
                            return this.curveTo$float$float$float$float$float$float(x1, y1, x2, y2, x3, y3);
                        }
                        else if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null) && ((typeof x3 === 'number') || x3 === null) && ((typeof y3 === 'number') || y3 === null)) {
                            return this.curveTo$double$double$double$double$double$double(x1, y1, x2, y2, x3, y3);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    Float.prototype.pointCrossings = function (px, py) {
                        var movx;
                        var movy;
                        var curx;
                        var cury;
                        var endx;
                        var endy;
                        var coords = this.floatCoords;
                        curx = movx = coords[0];
                        cury = movy = coords[1];
                        var crossings = 0;
                        var ci = 2;
                        for (var i = 1; i < this.numTypes; i++) {
                            {
                                switch ((this.pointTypes[i])) {
                                    case java.awt.geom.PathIterator.SEG_MOVETO:
                                        if (cury !== movy) {
                                            crossings += sun.awt.geom.Curve.pointCrossingsForLine(px, py, curx, cury, movx, movy);
                                        }
                                        movx = curx = coords[ci++];
                                        movy = cury = coords[ci++];
                                        break;
                                    case java.awt.geom.PathIterator.SEG_LINETO:
                                        crossings += sun.awt.geom.Curve.pointCrossingsForLine(px, py, curx, cury, endx = coords[ci++], endy = coords[ci++]);
                                        curx = endx;
                                        cury = endy;
                                        break;
                                    case java.awt.geom.PathIterator.SEG_QUADTO:
                                        crossings += sun.awt.geom.Curve.pointCrossingsForQuad(px, py, curx, cury, coords[ci++], coords[ci++], endx = coords[ci++], endy = coords[ci++], 0);
                                        curx = endx;
                                        cury = endy;
                                        break;
                                    case java.awt.geom.PathIterator.SEG_CUBICTO:
                                        crossings += sun.awt.geom.Curve.pointCrossingsForCubic(px, py, curx, cury, coords[ci++], coords[ci++], coords[ci++], coords[ci++], endx = coords[ci++], endy = coords[ci++], 0);
                                        curx = endx;
                                        cury = endy;
                                        break;
                                    case java.awt.geom.PathIterator.SEG_CLOSE:
                                        if (cury !== movy) {
                                            crossings += sun.awt.geom.Curve.pointCrossingsForLine(px, py, curx, cury, movx, movy);
                                        }
                                        curx = movx;
                                        cury = movy;
                                        break;
                                }
                            }
                            ;
                        }
                        if (cury !== movy) {
                            crossings += sun.awt.geom.Curve.pointCrossingsForLine(px, py, curx, cury, movx, movy);
                        }
                        return crossings;
                    };
                    Float.prototype.rectCrossings = function (rxmin, rymin, rxmax, rymax) {
                        var coords = this.floatCoords;
                        var curx;
                        var cury;
                        var movx;
                        var movy;
                        var endx;
                        var endy;
                        curx = movx = coords[0];
                        cury = movy = coords[1];
                        var crossings = 0;
                        var ci = 2;
                        for (var i = 1; crossings !== sun.awt.geom.Curve.RECT_INTERSECTS && i < this.numTypes; i++) {
                            {
                                switch ((this.pointTypes[i])) {
                                    case java.awt.geom.PathIterator.SEG_MOVETO:
                                        if (curx !== movx || cury !== movy) {
                                            crossings = sun.awt.geom.Curve.rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, curx, cury, movx, movy);
                                        }
                                        movx = curx = coords[ci++];
                                        movy = cury = coords[ci++];
                                        break;
                                    case java.awt.geom.PathIterator.SEG_LINETO:
                                        crossings = sun.awt.geom.Curve.rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, curx, cury, endx = coords[ci++], endy = coords[ci++]);
                                        curx = endx;
                                        cury = endy;
                                        break;
                                    case java.awt.geom.PathIterator.SEG_QUADTO:
                                        crossings = sun.awt.geom.Curve.rectCrossingsForQuad(crossings, rxmin, rymin, rxmax, rymax, curx, cury, coords[ci++], coords[ci++], endx = coords[ci++], endy = coords[ci++], 0);
                                        curx = endx;
                                        cury = endy;
                                        break;
                                    case java.awt.geom.PathIterator.SEG_CUBICTO:
                                        crossings = sun.awt.geom.Curve.rectCrossingsForCubic(crossings, rxmin, rymin, rxmax, rymax, curx, cury, coords[ci++], coords[ci++], coords[ci++], coords[ci++], endx = coords[ci++], endy = coords[ci++], 0);
                                        curx = endx;
                                        cury = endy;
                                        break;
                                    case java.awt.geom.PathIterator.SEG_CLOSE:
                                        if (curx !== movx || cury !== movy) {
                                            crossings = sun.awt.geom.Curve.rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, curx, cury, movx, movy);
                                        }
                                        curx = movx;
                                        cury = movy;
                                        break;
                                }
                            }
                            ;
                        }
                        if (crossings !== sun.awt.geom.Curve.RECT_INTERSECTS && (curx !== movx || cury !== movy)) {
                            crossings = sun.awt.geom.Curve.rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, curx, cury, movx, movy);
                        }
                        return crossings;
                    };
                    Float.prototype.append$java_awt_geom_PathIterator$boolean = function (pi, connect) {
                        var coords = [0, 0, 0, 0, 0, 0];
                        while ((!pi.isDone())) {
                            {
                                switch ((pi['currentSegment$float_A'](coords))) {
                                    case 0 /* SEG_MOVETO */:
                                        if (!connect || this.numTypes < 1 || this.numCoords < 1) {
                                            this.moveTo$float$float(coords[0], coords[1]);
                                            break;
                                        }
                                        if (this.pointTypes[this.numTypes - 1] !== java.awt.geom.Path2D.SEG_CLOSE_$LI$() && this.floatCoords[this.numCoords - 2] === coords[0] && this.floatCoords[this.numCoords - 1] === coords[1]) {
                                            break;
                                        }
                                        this.lineTo$float$float(coords[0], coords[1]);
                                        break;
                                    case 1 /* SEG_LINETO */:
                                        this.lineTo$float$float(coords[0], coords[1]);
                                        break;
                                    case 2 /* SEG_QUADTO */:
                                        this.quadTo$float$float$float$float(coords[0], coords[1], coords[2], coords[3]);
                                        break;
                                    case 3 /* SEG_CUBICTO */:
                                        this.curveTo$float$float$float$float$float$float(coords[0], coords[1], coords[2], coords[3], coords[4], coords[5]);
                                        break;
                                    case 4 /* SEG_CLOSE */:
                                        this.closePath();
                                        break;
                                }
                                pi.next();
                                connect = false;
                            }
                        }
                        ;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.6
                     * @param {*} pi
                     * @param {boolean} connect
                     */
                    Float.prototype.append = function (pi, connect) {
                        if (((pi != null && (pi["__interfaces"] != null && pi["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0 || pi.constructor != null && pi.constructor["__interfaces"] != null && pi.constructor["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0)) || pi === null) && ((typeof connect === 'boolean') || connect === null)) {
                            return this.append$java_awt_geom_PathIterator$boolean(pi, connect);
                        }
                        else if (((pi != null && (pi["__interfaces"] != null && pi["__interfaces"].indexOf("java.awt.Shape") >= 0 || pi.constructor != null && pi.constructor["__interfaces"] != null && pi.constructor["__interfaces"].indexOf("java.awt.Shape") >= 0)) || pi === null) && ((typeof connect === 'boolean') || connect === null)) {
                            _super.prototype.append.call(this, pi, connect);
                        }
                        else if (((typeof pi === 'number') || pi === null) && ((typeof connect === 'number') || connect === null)) {
                            return this.append$float$float(pi, connect);
                        }
                        else if (((typeof pi === 'number') || pi === null) && ((typeof connect === 'number') || connect === null)) {
                            return this.append$double$double(pi, connect);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.6
                     * @param {java.awt.geom.AffineTransform} at
                     */
                    Float.prototype.transform = function (at) {
                        at.transform$float_A$int$float_A$int$int(this.floatCoords, 0, this.floatCoords, 0, (this.numCoords / 2 | 0));
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.6
                     * @return {java.awt.geom.Rectangle2D}
                     */
                    Float.prototype.getBounds2D = function () {
                        var x1;
                        var y1;
                        var x2;
                        var y2;
                        var i = this.numCoords;
                        if (i > 0) {
                            y1 = y2 = this.floatCoords[--i];
                            x1 = x2 = this.floatCoords[--i];
                            while ((i > 0)) {
                                {
                                    var y = this.floatCoords[--i];
                                    var x = this.floatCoords[--i];
                                    if (x < x1)
                                        x1 = x;
                                    if (y < y1)
                                        y1 = y;
                                    if (x > x2)
                                        x2 = x;
                                    if (y > y2)
                                        y2 = y;
                                }
                            }
                            ;
                        }
                        else {
                            x1 = y1 = x2 = y2 = 0.0;
                        }
                        return new java.awt.geom.Rectangle2D.Float(x1, y1, x2 - x1, y2 - y1);
                    };
                    /**
                     * {@inheritDoc}
                     * <p>
                     * The iterator for this class is not multi-threaded safe, which means that
                     * this {@code Path2D} class does not guarantee that modifications to the
                     * geometry of this {@code Path2D} object do not affect any iterations of
                     * that geometry that are already in process.
                     *
                     * @since 1.6
                     * @param {java.awt.geom.AffineTransform} at
                     * @param {number} flatness
                     * @return {*}
                     */
                    Float.prototype.getPathIterator = function (at, flatness) {
                        if (((at != null && at instanceof java.awt.geom.AffineTransform) || at === null) && ((typeof flatness === 'number') || flatness === null)) {
                            return _super.prototype.getPathIterator.call(this, at, flatness);
                        }
                        else if (((at != null && at instanceof java.awt.geom.AffineTransform) || at === null) && flatness === undefined) {
                            return this.getPathIterator$java_awt_geom_AffineTransform(at);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    Float.prototype.getPathIterator$java_awt_geom_AffineTransform = function (at) {
                        if (at == null) {
                            return new Float.CopyIterator(this);
                        }
                        else {
                            return new Float.TxIterator(this, at);
                        }
                    };
                    /**
                     * Creates a new object of the same class as this object.
                     *
                     * @return {*} a clone of this instance.
                     * @exception OutOfMemoryError
                     * if there is not enough memory.
                     * @see java.lang.Cloneable
                     * @since 1.6
                     */
                    Float.prototype.clone = function () {
                        if (this != null && this instanceof java.awt.geom.GeneralPath) {
                            return new java.awt.geom.GeneralPath(this);
                        }
                        else {
                            return new java.awt.geom.Path2D.Float(this);
                        }
                    };
                    Float.serialVersionUID = 6990832515060788886;
                    return Float;
                }(java.awt.geom.Path2D));
                Path2D.Float = Float;
                Float["__class"] = "java.awt.geom.Path2D.Float";
                Float["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"];
                (function (Float) {
                    var CopyIterator = /** @class */ (function (_super) {
                        __extends(CopyIterator, _super);
                        function CopyIterator(p2df) {
                            var _this = _super.call(this, p2df) || this;
                            if (_this.floatCoords === undefined)
                                _this.floatCoords = null;
                            _this.floatCoords = p2df.floatCoords;
                            return _this;
                        }
                        CopyIterator.prototype.currentSegment$float_A = function (coords) {
                            var type = this.path.pointTypes[this.typeIdx];
                            var numCoords = java.awt.geom.Path2D.Iterator.curvecoords_$LI$()[type];
                            if (numCoords > 0) {
                                java.awt.geom.Helper.arraycopy(this.floatCoords, this.pointIdx, coords, 0, numCoords);
                            }
                            return type;
                        };
                        CopyIterator.prototype.currentSegment = function (coords) {
                            if (((coords != null && coords instanceof Array && (coords.length == 0 || coords[0] == null || (typeof coords[0] === 'number'))) || coords === null)) {
                                return this.currentSegment$float_A(coords);
                            }
                            else if (((coords != null && coords instanceof Array && (coords.length == 0 || coords[0] == null || (typeof coords[0] === 'number'))) || coords === null)) {
                                return this.currentSegment$double_A(coords);
                            }
                            else
                                throw new Error('invalid overload');
                        };
                        CopyIterator.prototype.currentSegment$double_A = function (coords) {
                            var type = this.path.pointTypes[this.typeIdx];
                            var numCoords = java.awt.geom.Path2D.Iterator.curvecoords_$LI$()[type];
                            if (numCoords > 0) {
                                for (var i = 0; i < numCoords; i++) {
                                    {
                                        coords[i] = this.floatCoords[this.pointIdx + i];
                                    }
                                    ;
                                }
                            }
                            return type;
                        };
                        return CopyIterator;
                    }(java.awt.geom.Path2D.Iterator));
                    Float.CopyIterator = CopyIterator;
                    CopyIterator["__class"] = "java.awt.geom.Path2D.Float.CopyIterator";
                    CopyIterator["__interfaces"] = ["java.awt.geom.PathIterator"];
                    var TxIterator = /** @class */ (function (_super) {
                        __extends(TxIterator, _super);
                        function TxIterator(p2df, at) {
                            var _this = _super.call(this, p2df) || this;
                            if (_this.floatCoords === undefined)
                                _this.floatCoords = null;
                            if (_this.affine === undefined)
                                _this.affine = null;
                            _this.floatCoords = p2df.floatCoords;
                            _this.affine = at;
                            return _this;
                        }
                        TxIterator.prototype.currentSegment$float_A = function (coords) {
                            var type = this.path.pointTypes[this.typeIdx];
                            var numCoords = java.awt.geom.Path2D.Iterator.curvecoords_$LI$()[type];
                            if (numCoords > 0) {
                                this.affine.transform$float_A$int$float_A$int$int(this.floatCoords, this.pointIdx, coords, 0, (numCoords / 2 | 0));
                            }
                            return type;
                        };
                        TxIterator.prototype.currentSegment = function (coords) {
                            if (((coords != null && coords instanceof Array && (coords.length == 0 || coords[0] == null || (typeof coords[0] === 'number'))) || coords === null)) {
                                return this.currentSegment$float_A(coords);
                            }
                            else if (((coords != null && coords instanceof Array && (coords.length == 0 || coords[0] == null || (typeof coords[0] === 'number'))) || coords === null)) {
                                return this.currentSegment$double_A(coords);
                            }
                            else
                                throw new Error('invalid overload');
                        };
                        TxIterator.prototype.currentSegment$double_A = function (coords) {
                            var type = this.path.pointTypes[this.typeIdx];
                            var numCoords = java.awt.geom.Path2D.Iterator.curvecoords_$LI$()[type];
                            if (numCoords > 0) {
                                this.affine.transform$float_A$int$double_A$int$int(this.floatCoords, this.pointIdx, coords, 0, (numCoords / 2 | 0));
                            }
                            return type;
                        };
                        return TxIterator;
                    }(java.awt.geom.Path2D.Iterator));
                    Float.TxIterator = TxIterator;
                    TxIterator["__class"] = "java.awt.geom.Path2D.Float.TxIterator";
                    TxIterator["__interfaces"] = ["java.awt.geom.PathIterator"];
                })(Float = Path2D.Float || (Path2D.Float = {}));
                /**
                 * Constructs a new empty double precision {@code Path2D} object with
                 * the specified winding rule and the specified initial capacity to
                 * store path segments. This number is an initial guess as to how many
                 * path segments are in the path, but the storage is expanded as needed
                 * to store whatever path segments are added to this path.
                 *
                 * @param {number} rule
                 * the winding rule
                 * @param {number} initialCapacity
                 * the estimate for the number of path segments in the path
                 * @see #WIND_EVEN_ODD
                 * @see #WIND_NON_ZERO
                 * @since 1.6
                 * @class
                 * @extends java.awt.geom.Path2D
                 */
                var Double = /** @class */ (function (_super) {
                    __extends(Double, _super);
                    function Double(s, at) {
                        var _this = this;
                        if (((s != null && (s["__interfaces"] != null && s["__interfaces"].indexOf("java.awt.Shape") >= 0 || s.constructor != null && s.constructor["__interfaces"] != null && s.constructor["__interfaces"].indexOf("java.awt.Shape") >= 0)) || s === null) && ((at != null && at instanceof java.awt.geom.AffineTransform) || at === null)) {
                            var __args = arguments;
                            _this = _super.call(this) || this;
                            if (_this.doubleCoords === undefined)
                                _this.doubleCoords = null;
                            if (_this.doubleCoords === undefined)
                                _this.doubleCoords = null;
                            (function () {
                                if (s != null && s instanceof java.awt.geom.Path2D) {
                                    var p2d = s;
                                    _this.setWindingRule(p2d.windingRule);
                                    _this.numTypes = p2d.numTypes;
                                    _this.pointTypes = /* copyOf */ p2d.pointTypes.slice(0, p2d.pointTypes.length);
                                    _this.numCoords = p2d.numCoords;
                                    _this.doubleCoords = p2d.cloneCoordsDouble(at);
                                }
                                else {
                                    var pi = s['getPathIterator$java_awt_geom_AffineTransform'](at);
                                    _this.setWindingRule(pi.getWindingRule());
                                    _this.pointTypes = (function (s) { var a = []; while (s-- > 0)
                                        a.push(0); return a; })(java.awt.geom.Path2D.INIT_SIZE);
                                    _this.doubleCoords = (function (s) { var a = []; while (s-- > 0)
                                        a.push(0); return a; })(java.awt.geom.Path2D.INIT_SIZE * 2);
                                    _this.append$java_awt_geom_PathIterator$boolean(pi, false);
                                }
                            })();
                        }
                        else if (((typeof s === 'number') || s === null) && ((typeof at === 'number') || at === null)) {
                            var __args = arguments;
                            var rule = __args[0];
                            var initialCapacity_4 = __args[1];
                            _this = _super.call(this, rule, initialCapacity_4) || this;
                            if (_this.doubleCoords === undefined)
                                _this.doubleCoords = null;
                            if (_this.doubleCoords === undefined)
                                _this.doubleCoords = null;
                            (function () {
                                _this.doubleCoords = (function (s) { var a = []; while (s-- > 0)
                                    a.push(0); return a; })(initialCapacity_4 * 2);
                            })();
                        }
                        else if (((s != null && (s["__interfaces"] != null && s["__interfaces"].indexOf("java.awt.Shape") >= 0 || s.constructor != null && s.constructor["__interfaces"] != null && s.constructor["__interfaces"].indexOf("java.awt.Shape") >= 0)) || s === null) && at === undefined) {
                            var __args = arguments;
                            {
                                var __args_6 = arguments;
                                var at_2 = null;
                                _this = _super.call(this) || this;
                                if (_this.doubleCoords === undefined)
                                    _this.doubleCoords = null;
                                if (_this.doubleCoords === undefined)
                                    _this.doubleCoords = null;
                                (function () {
                                    if (s != null && s instanceof java.awt.geom.Path2D) {
                                        var p2d = s;
                                        _this.setWindingRule(p2d.windingRule);
                                        _this.numTypes = p2d.numTypes;
                                        _this.pointTypes = /* copyOf */ p2d.pointTypes.slice(0, p2d.pointTypes.length);
                                        _this.numCoords = p2d.numCoords;
                                        _this.doubleCoords = p2d.cloneCoordsDouble(at_2);
                                    }
                                    else {
                                        var pi = s['getPathIterator$java_awt_geom_AffineTransform'](at_2);
                                        _this.setWindingRule(pi.getWindingRule());
                                        _this.pointTypes = (function (s) { var a = []; while (s-- > 0)
                                            a.push(0); return a; })(java.awt.geom.Path2D.INIT_SIZE);
                                        _this.doubleCoords = (function (s) { var a = []; while (s-- > 0)
                                            a.push(0); return a; })(java.awt.geom.Path2D.INIT_SIZE * 2);
                                        _this.append$java_awt_geom_PathIterator$boolean(pi, false);
                                    }
                                })();
                            }
                        }
                        else if (((typeof s === 'number') || s === null) && at === undefined) {
                            var __args = arguments;
                            var rule = __args[0];
                            {
                                var __args_7 = arguments;
                                var initialCapacity_5 = java.awt.geom.Path2D.INIT_SIZE;
                                _this = _super.call(this, rule, initialCapacity_5) || this;
                                if (_this.doubleCoords === undefined)
                                    _this.doubleCoords = null;
                                if (_this.doubleCoords === undefined)
                                    _this.doubleCoords = null;
                                (function () {
                                    _this.doubleCoords = (function (s) { var a = []; while (s-- > 0)
                                        a.push(0); return a; })(initialCapacity_5 * 2);
                                })();
                            }
                        }
                        else if (s === undefined && at === undefined) {
                            var __args = arguments;
                            {
                                var __args_8 = arguments;
                                var rule = java.awt.geom.Path2D.WIND_NON_ZERO_$LI$();
                                var initialCapacity_6 = java.awt.geom.Path2D.INIT_SIZE;
                                _this = _super.call(this, rule, initialCapacity_6) || this;
                                if (_this.doubleCoords === undefined)
                                    _this.doubleCoords = null;
                                if (_this.doubleCoords === undefined)
                                    _this.doubleCoords = null;
                                (function () {
                                    _this.doubleCoords = (function (s) { var a = []; while (s-- > 0)
                                        a.push(0); return a; })(initialCapacity_6 * 2);
                                })();
                            }
                        }
                        else
                            throw new Error('invalid overload');
                        return _this;
                    }
                    Double.prototype.cloneCoordsFloat = function (at) {
                        var ret = (function (s) { var a = []; while (s-- > 0)
                            a.push(0); return a; })(this.doubleCoords.length);
                        if (at == null) {
                            for (var i = 0; i < this.numCoords; i++) {
                                {
                                    ret[i] = this.doubleCoords[i];
                                }
                                ;
                            }
                        }
                        else {
                            at.transform$double_A$int$float_A$int$int(this.doubleCoords, 0, ret, 0, (this.numCoords / 2 | 0));
                        }
                        return ret;
                    };
                    Double.prototype.cloneCoordsDouble = function (at) {
                        var ret;
                        if (at == null) {
                            ret = /* copyOf */ this.doubleCoords.slice(0, this.doubleCoords.length);
                        }
                        else {
                            ret = (function (s) { var a = []; while (s-- > 0)
                                a.push(0); return a; })(this.doubleCoords.length);
                            at.transform$double_A$int$double_A$int$int(this.doubleCoords, 0, ret, 0, (this.numCoords / 2 | 0));
                        }
                        return ret;
                    };
                    Double.prototype.append$float$float = function (x, y) {
                        this.doubleCoords[this.numCoords++] = x;
                        this.doubleCoords[this.numCoords++] = y;
                    };
                    Double.prototype.append$double$double = function (x, y) {
                        this.doubleCoords[this.numCoords++] = x;
                        this.doubleCoords[this.numCoords++] = y;
                    };
                    Double.prototype.getPoint = function (coordindex) {
                        return new java.awt.geom.Point2D.Double(this.doubleCoords[coordindex], this.doubleCoords[coordindex + 1]);
                    };
                    Double.prototype.needRoom = function (needMove, newCoords) {
                        if (needMove && this.numTypes === 0) {
                            throw Object.defineProperty(new Error("missing initial moveto in path definition"), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.Object', 'java.awt.geom.IllegalPathStateException', 'java.lang.RuntimeException', 'java.lang.Exception'] });
                        }
                        var size = this.pointTypes.length;
                        if (this.numTypes >= size) {
                            var grow = size;
                            if (grow > java.awt.geom.Path2D.EXPAND_MAX) {
                                grow = java.awt.geom.Path2D.EXPAND_MAX;
                            }
                            this.pointTypes = /* copyOf */ this.pointTypes.slice(0, size + grow);
                        }
                        size = this.doubleCoords.length;
                        if (this.numCoords + newCoords > size) {
                            var grow = size;
                            if (grow > java.awt.geom.Path2D.EXPAND_MAX * 2) {
                                grow = java.awt.geom.Path2D.EXPAND_MAX * 2;
                            }
                            if (grow < newCoords) {
                                grow = newCoords;
                            }
                            this.doubleCoords = /* copyOf */ this.doubleCoords.slice(0, size + grow);
                        }
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.6
                     * @param {number} x
                     * @param {number} y
                     */
                    Double.prototype.moveTo = function (x, y) {
                        if (this.numTypes > 0 && this.pointTypes[this.numTypes - 1] === java.awt.geom.Path2D.SEG_MOVETO_$LI$()) {
                            this.doubleCoords[this.numCoords - 2] = x;
                            this.doubleCoords[this.numCoords - 1] = y;
                        }
                        else {
                            this.needRoom(false, 2);
                            this.pointTypes[this.numTypes++] = java.awt.geom.Path2D.SEG_MOVETO_$LI$();
                            this.doubleCoords[this.numCoords++] = x;
                            this.doubleCoords[this.numCoords++] = y;
                        }
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.6
                     * @param {number} x
                     * @param {number} y
                     */
                    Double.prototype.lineTo = function (x, y) {
                        this.needRoom(true, 2);
                        this.pointTypes[this.numTypes++] = java.awt.geom.Path2D.SEG_LINETO_$LI$();
                        this.doubleCoords[this.numCoords++] = x;
                        this.doubleCoords[this.numCoords++] = y;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.6
                     * @param {number} x1
                     * @param {number} y1
                     * @param {number} x2
                     * @param {number} y2
                     */
                    Double.prototype.quadTo = function (x1, y1, x2, y2) {
                        this.needRoom(true, 4);
                        this.pointTypes[this.numTypes++] = java.awt.geom.Path2D.SEG_QUADTO_$LI$();
                        this.doubleCoords[this.numCoords++] = x1;
                        this.doubleCoords[this.numCoords++] = y1;
                        this.doubleCoords[this.numCoords++] = x2;
                        this.doubleCoords[this.numCoords++] = y2;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.6
                     * @param {number} x1
                     * @param {number} y1
                     * @param {number} x2
                     * @param {number} y2
                     * @param {number} x3
                     * @param {number} y3
                     */
                    Double.prototype.curveTo = function (x1, y1, x2, y2, x3, y3) {
                        this.needRoom(true, 6);
                        this.pointTypes[this.numTypes++] = java.awt.geom.Path2D.SEG_CUBICTO_$LI$();
                        this.doubleCoords[this.numCoords++] = x1;
                        this.doubleCoords[this.numCoords++] = y1;
                        this.doubleCoords[this.numCoords++] = x2;
                        this.doubleCoords[this.numCoords++] = y2;
                        this.doubleCoords[this.numCoords++] = x3;
                        this.doubleCoords[this.numCoords++] = y3;
                    };
                    Double.prototype.pointCrossings = function (px, py) {
                        var movx;
                        var movy;
                        var curx;
                        var cury;
                        var endx;
                        var endy;
                        var coords = this.doubleCoords;
                        curx = movx = coords[0];
                        cury = movy = coords[1];
                        var crossings = 0;
                        var ci = 2;
                        for (var i = 1; i < this.numTypes; i++) {
                            {
                                switch ((this.pointTypes[i])) {
                                    case java.awt.geom.PathIterator.SEG_MOVETO:
                                        if (cury !== movy) {
                                            crossings += sun.awt.geom.Curve.pointCrossingsForLine(px, py, curx, cury, movx, movy);
                                        }
                                        movx = curx = coords[ci++];
                                        movy = cury = coords[ci++];
                                        break;
                                    case java.awt.geom.PathIterator.SEG_LINETO:
                                        crossings += sun.awt.geom.Curve.pointCrossingsForLine(px, py, curx, cury, endx = coords[ci++], endy = coords[ci++]);
                                        curx = endx;
                                        cury = endy;
                                        break;
                                    case java.awt.geom.PathIterator.SEG_QUADTO:
                                        crossings += sun.awt.geom.Curve.pointCrossingsForQuad(px, py, curx, cury, coords[ci++], coords[ci++], endx = coords[ci++], endy = coords[ci++], 0);
                                        curx = endx;
                                        cury = endy;
                                        break;
                                    case java.awt.geom.PathIterator.SEG_CUBICTO:
                                        crossings += sun.awt.geom.Curve.pointCrossingsForCubic(px, py, curx, cury, coords[ci++], coords[ci++], coords[ci++], coords[ci++], endx = coords[ci++], endy = coords[ci++], 0);
                                        curx = endx;
                                        cury = endy;
                                        break;
                                    case java.awt.geom.PathIterator.SEG_CLOSE:
                                        if (cury !== movy) {
                                            crossings += sun.awt.geom.Curve.pointCrossingsForLine(px, py, curx, cury, movx, movy);
                                        }
                                        curx = movx;
                                        cury = movy;
                                        break;
                                }
                            }
                            ;
                        }
                        if (cury !== movy) {
                            crossings += sun.awt.geom.Curve.pointCrossingsForLine(px, py, curx, cury, movx, movy);
                        }
                        return crossings;
                    };
                    Double.prototype.rectCrossings = function (rxmin, rymin, rxmax, rymax) {
                        var coords = this.doubleCoords;
                        var curx;
                        var cury;
                        var movx;
                        var movy;
                        var endx;
                        var endy;
                        curx = movx = coords[0];
                        cury = movy = coords[1];
                        var crossings = 0;
                        var ci = 2;
                        for (var i = 1; crossings !== sun.awt.geom.Curve.RECT_INTERSECTS && i < this.numTypes; i++) {
                            {
                                switch ((this.pointTypes[i])) {
                                    case java.awt.geom.PathIterator.SEG_MOVETO:
                                        if (curx !== movx || cury !== movy) {
                                            crossings = sun.awt.geom.Curve.rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, curx, cury, movx, movy);
                                        }
                                        movx = curx = coords[ci++];
                                        movy = cury = coords[ci++];
                                        break;
                                    case java.awt.geom.PathIterator.SEG_LINETO:
                                        endx = coords[ci++];
                                        endy = coords[ci++];
                                        crossings = sun.awt.geom.Curve.rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, curx, cury, endx, endy);
                                        curx = endx;
                                        cury = endy;
                                        break;
                                    case java.awt.geom.PathIterator.SEG_QUADTO:
                                        crossings = sun.awt.geom.Curve.rectCrossingsForQuad(crossings, rxmin, rymin, rxmax, rymax, curx, cury, coords[ci++], coords[ci++], endx = coords[ci++], endy = coords[ci++], 0);
                                        curx = endx;
                                        cury = endy;
                                        break;
                                    case java.awt.geom.PathIterator.SEG_CUBICTO:
                                        crossings = sun.awt.geom.Curve.rectCrossingsForCubic(crossings, rxmin, rymin, rxmax, rymax, curx, cury, coords[ci++], coords[ci++], coords[ci++], coords[ci++], endx = coords[ci++], endy = coords[ci++], 0);
                                        curx = endx;
                                        cury = endy;
                                        break;
                                    case java.awt.geom.PathIterator.SEG_CLOSE:
                                        if (curx !== movx || cury !== movy) {
                                            crossings = sun.awt.geom.Curve.rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, curx, cury, movx, movy);
                                        }
                                        curx = movx;
                                        cury = movy;
                                        break;
                                }
                            }
                            ;
                        }
                        if (crossings !== sun.awt.geom.Curve.RECT_INTERSECTS && (curx !== movx || cury !== movy)) {
                            crossings = sun.awt.geom.Curve.rectCrossingsForLine(crossings, rxmin, rymin, rxmax, rymax, curx, cury, movx, movy);
                        }
                        return crossings;
                    };
                    Double.prototype.append$java_awt_geom_PathIterator$boolean = function (pi, connect) {
                        var coords = [0, 0, 0, 0, 0, 0];
                        while ((!pi.isDone())) {
                            {
                                switch ((pi['currentSegment$double_A'](coords))) {
                                    case 0 /* SEG_MOVETO */:
                                        if (!connect || this.numTypes < 1 || this.numCoords < 1) {
                                            this.moveTo(coords[0], coords[1]);
                                            break;
                                        }
                                        if (this.pointTypes[this.numTypes - 1] !== java.awt.geom.Path2D.SEG_CLOSE_$LI$() && this.doubleCoords[this.numCoords - 2] === coords[0] && this.doubleCoords[this.numCoords - 1] === coords[1]) {
                                            break;
                                        }
                                        this.lineTo(coords[0], coords[1]);
                                        break;
                                    case 1 /* SEG_LINETO */:
                                        this.lineTo(coords[0], coords[1]);
                                        break;
                                    case 2 /* SEG_QUADTO */:
                                        this.quadTo(coords[0], coords[1], coords[2], coords[3]);
                                        break;
                                    case 3 /* SEG_CUBICTO */:
                                        this.curveTo(coords[0], coords[1], coords[2], coords[3], coords[4], coords[5]);
                                        break;
                                    case 4 /* SEG_CLOSE */:
                                        this.closePath();
                                        break;
                                }
                                pi.next();
                                connect = false;
                            }
                        }
                        ;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.6
                     * @param {*} pi
                     * @param {boolean} connect
                     */
                    Double.prototype.append = function (pi, connect) {
                        if (((pi != null && (pi["__interfaces"] != null && pi["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0 || pi.constructor != null && pi.constructor["__interfaces"] != null && pi.constructor["__interfaces"].indexOf("java.awt.geom.PathIterator") >= 0)) || pi === null) && ((typeof connect === 'boolean') || connect === null)) {
                            return this.append$java_awt_geom_PathIterator$boolean(pi, connect);
                        }
                        else if (((pi != null && (pi["__interfaces"] != null && pi["__interfaces"].indexOf("java.awt.Shape") >= 0 || pi.constructor != null && pi.constructor["__interfaces"] != null && pi.constructor["__interfaces"].indexOf("java.awt.Shape") >= 0)) || pi === null) && ((typeof connect === 'boolean') || connect === null)) {
                            _super.prototype.append.call(this, pi, connect);
                        }
                        else if (((typeof pi === 'number') || pi === null) && ((typeof connect === 'number') || connect === null)) {
                            return this.append$float$float(pi, connect);
                        }
                        else if (((typeof pi === 'number') || pi === null) && ((typeof connect === 'number') || connect === null)) {
                            return this.append$double$double(pi, connect);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.6
                     * @param {java.awt.geom.AffineTransform} at
                     */
                    Double.prototype.transform = function (at) {
                        at.transform$double_A$int$double_A$int$int(this.doubleCoords, 0, this.doubleCoords, 0, (this.numCoords / 2 | 0));
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.6
                     * @return {java.awt.geom.Rectangle2D}
                     */
                    Double.prototype.getBounds2D = function () {
                        var x1;
                        var y1;
                        var x2;
                        var y2;
                        var i = this.numCoords;
                        if (i > 0) {
                            y1 = y2 = this.doubleCoords[--i];
                            x1 = x2 = this.doubleCoords[--i];
                            while ((i > 0)) {
                                {
                                    var y = this.doubleCoords[--i];
                                    var x = this.doubleCoords[--i];
                                    if (x < x1)
                                        x1 = x;
                                    if (y < y1)
                                        y1 = y;
                                    if (x > x2)
                                        x2 = x;
                                    if (y > y2)
                                        y2 = y;
                                }
                            }
                            ;
                        }
                        else {
                            x1 = y1 = x2 = y2 = 0.0;
                        }
                        return new java.awt.geom.Rectangle2D.Double(x1, y1, x2 - x1, y2 - y1);
                    };
                    /**
                     * {@inheritDoc}
                     * <p>
                     * The iterator for this class is not multi-threaded safe, which means that
                     * this {@code Path2D} class does not guarantee that modifications to the
                     * geometry of this {@code Path2D} object do not affect any iterations of
                     * that geometry that are already in process.
                     *
                     * @since 1.6
                     * @param {java.awt.geom.AffineTransform} at
                     * @param {number} flatness
                     * @return {*}
                     */
                    Double.prototype.getPathIterator = function (at, flatness) {
                        if (((at != null && at instanceof java.awt.geom.AffineTransform) || at === null) && ((typeof flatness === 'number') || flatness === null)) {
                            return _super.prototype.getPathIterator.call(this, at, flatness);
                        }
                        else if (((at != null && at instanceof java.awt.geom.AffineTransform) || at === null) && flatness === undefined) {
                            return this.getPathIterator$java_awt_geom_AffineTransform(at);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    Double.prototype.getPathIterator$java_awt_geom_AffineTransform = function (at) {
                        if (at == null) {
                            return new Double.CopyIterator(this);
                        }
                        else {
                            return new Double.TxIterator(this, at);
                        }
                    };
                    /**
                     * Creates a new object of the same class as this object.
                     *
                     * @return {*} a clone of this instance.
                     * @exception OutOfMemoryError
                     * if there is not enough memory.
                     * @see java.lang.Cloneable
                     * @since 1.6
                     */
                    Double.prototype.clone = function () {
                        return new java.awt.geom.Path2D.Double(this);
                    };
                    Double.serialVersionUID = 1826762518450014216;
                    return Double;
                }(java.awt.geom.Path2D));
                Path2D.Double = Double;
                Double["__class"] = "java.awt.geom.Path2D.Double";
                Double["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"];
                (function (Double) {
                    var CopyIterator = /** @class */ (function (_super) {
                        __extends(CopyIterator, _super);
                        function CopyIterator(p2dd) {
                            var _this = _super.call(this, p2dd) || this;
                            if (_this.doubleCoords === undefined)
                                _this.doubleCoords = null;
                            _this.doubleCoords = p2dd.doubleCoords;
                            return _this;
                        }
                        CopyIterator.prototype.currentSegment$float_A = function (coords) {
                            var type = this.path.pointTypes[this.typeIdx];
                            var numCoords = java.awt.geom.Path2D.Iterator.curvecoords_$LI$()[type];
                            if (numCoords > 0) {
                                for (var i = 0; i < numCoords; i++) {
                                    {
                                        coords[i] = this.doubleCoords[this.pointIdx + i];
                                    }
                                    ;
                                }
                            }
                            return type;
                        };
                        CopyIterator.prototype.currentSegment = function (coords) {
                            if (((coords != null && coords instanceof Array && (coords.length == 0 || coords[0] == null || (typeof coords[0] === 'number'))) || coords === null)) {
                                return this.currentSegment$float_A(coords);
                            }
                            else if (((coords != null && coords instanceof Array && (coords.length == 0 || coords[0] == null || (typeof coords[0] === 'number'))) || coords === null)) {
                                return this.currentSegment$double_A(coords);
                            }
                            else
                                throw new Error('invalid overload');
                        };
                        CopyIterator.prototype.currentSegment$double_A = function (coords) {
                            var type = this.path.pointTypes[this.typeIdx];
                            var numCoords = java.awt.geom.Path2D.Iterator.curvecoords_$LI$()[type];
                            if (numCoords > 0) {
                                java.awt.geom.Helper.arraycopy(this.doubleCoords, this.pointIdx, coords, 0, numCoords);
                            }
                            return type;
                        };
                        return CopyIterator;
                    }(java.awt.geom.Path2D.Iterator));
                    Double.CopyIterator = CopyIterator;
                    CopyIterator["__class"] = "java.awt.geom.Path2D.Double.CopyIterator";
                    CopyIterator["__interfaces"] = ["java.awt.geom.PathIterator"];
                    var TxIterator = /** @class */ (function (_super) {
                        __extends(TxIterator, _super);
                        function TxIterator(p2dd, at) {
                            var _this = _super.call(this, p2dd) || this;
                            if (_this.doubleCoords === undefined)
                                _this.doubleCoords = null;
                            if (_this.affine === undefined)
                                _this.affine = null;
                            _this.doubleCoords = p2dd.doubleCoords;
                            _this.affine = at;
                            return _this;
                        }
                        TxIterator.prototype.currentSegment$float_A = function (coords) {
                            var type = this.path.pointTypes[this.typeIdx];
                            var numCoords = java.awt.geom.Path2D.Iterator.curvecoords_$LI$()[type];
                            if (numCoords > 0) {
                                this.affine.transform$double_A$int$float_A$int$int(this.doubleCoords, this.pointIdx, coords, 0, (numCoords / 2 | 0));
                            }
                            return type;
                        };
                        TxIterator.prototype.currentSegment = function (coords) {
                            if (((coords != null && coords instanceof Array && (coords.length == 0 || coords[0] == null || (typeof coords[0] === 'number'))) || coords === null)) {
                                return this.currentSegment$float_A(coords);
                            }
                            else if (((coords != null && coords instanceof Array && (coords.length == 0 || coords[0] == null || (typeof coords[0] === 'number'))) || coords === null)) {
                                return this.currentSegment$double_A(coords);
                            }
                            else
                                throw new Error('invalid overload');
                        };
                        TxIterator.prototype.currentSegment$double_A = function (coords) {
                            var type = this.path.pointTypes[this.typeIdx];
                            var numCoords = java.awt.geom.Path2D.Iterator.curvecoords_$LI$()[type];
                            if (numCoords > 0) {
                                this.affine.transform$double_A$int$double_A$int$int(this.doubleCoords, this.pointIdx, coords, 0, (numCoords / 2 | 0));
                            }
                            return type;
                        };
                        return TxIterator;
                    }(java.awt.geom.Path2D.Iterator));
                    Double.TxIterator = TxIterator;
                    TxIterator["__class"] = "java.awt.geom.Path2D.Double.TxIterator";
                    TxIterator["__interfaces"] = ["java.awt.geom.PathIterator"];
                })(Double = Path2D.Double || (Path2D.Double = {}));
            })(Path2D = geom.Path2D || (geom.Path2D = {}));
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * The <code>RoundRectangle2D</code> class defines a rectangle with rounded
             * corners defined by a location {@code (x,y)}, a dimension {@code (w x h)}, and
             * the width and height of an arc with which to round the corners.
             * <p>
             * This class is the abstract superclass for all objects that store a 2D rounded
             * rectangle. The actual storage representation of the coordinates is left to
             * the subclass.
             *
             * @author Jim Graham
             * @since 1.2
             * @extends java.awt.geom.RectangularShape
             * @class
             */
            var RoundRectangle2D = /** @class */ (function (_super) {
                __extends(RoundRectangle2D, _super);
                function RoundRectangle2D() {
                    return _super.call(this) || this;
                }
                RoundRectangle2D.prototype.setRoundRect$double$double$double$double$double$double = function (x, y, w, h, arcWidth, arcHeight) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
                /**
                 * Sets the location, size, and corner radii of this
                 * <code>RoundRectangle2D</code> to the specified <code>double</code>
                 * values.
                 *
                 * @param {number} x
                 * the X coordinate to which to set the location of this
                 * <code>RoundRectangle2D</code>
                 * @param {number} y
                 * the Y coordinate to which to set the location of this
                 * <code>RoundRectangle2D</code>
                 * @param {number} w
                 * the width to which to set this <code>RoundRectangle2D</code>
                 * @param {number} h
                 * the height to which to set this <code>RoundRectangle2D</code>
                 * @param {number} arcWidth
                 * the width to which to set the arc of this
                 * <code>RoundRectangle2D</code>
                 * @param {number} arcHeight
                 * the height to which to set the arc of this
                 * <code>RoundRectangle2D</code>
                 * @since 1.2
                 */
                RoundRectangle2D.prototype.setRoundRect = function (x, y, w, h, arcWidth, arcHeight) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((typeof arcWidth === 'number') || arcWidth === null) && ((typeof arcHeight === 'number') || arcHeight === null)) {
                        return this.setRoundRect$double$double$double$double$double$double(x, y, w, h, arcWidth, arcHeight);
                    }
                    else if (((x != null && x instanceof java.awt.geom.RoundRectangle2D) || x === null) && y === undefined && w === undefined && h === undefined && arcWidth === undefined && arcHeight === undefined) {
                        return this.setRoundRect$java_awt_geom_RoundRectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                RoundRectangle2D.prototype.setRoundRect$java_awt_geom_RoundRectangle2D = function (rr) {
                    this.setRoundRect$double$double$double$double$double$double(rr.getX(), rr.getY(), rr.getWidth(), rr.getHeight(), rr.getArcWidth(), rr.getArcHeight());
                };
                RoundRectangle2D.prototype.setFrame$double$double$double$double = function (x, y, w, h) {
                    this.setRoundRect$double$double$double$double$double$double(x, y, w, h, this.getArcWidth(), this.getArcHeight());
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 * @param {number} x
                 * @param {number} y
                 * @param {number} w
                 * @param {number} h
                 */
                RoundRectangle2D.prototype.setFrame = function (x, y, w, h) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        return this.setFrame$double$double$double$double(x, y, w, h);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && ((y != null && y instanceof java.awt.geom.Dimension2D) || y === null) && w === undefined && h === undefined) {
                        return this.setFrame$java_awt_geom_Point2D$java_awt_geom_Dimension2D(x, y);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.setFrame$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                RoundRectangle2D.prototype.contains$double$double = function (x, y) {
                    if (this.isEmpty()) {
                        return false;
                    }
                    var rrx0 = this.getX();
                    var rry0 = this.getY();
                    var rrx1 = rrx0 + this.getWidth();
                    var rry1 = rry0 + this.getHeight();
                    if (x < rrx0 || y < rry0 || x >= rrx1 || y >= rry1) {
                        return false;
                    }
                    var aw = Math.min(this.getWidth(), Math.abs(this.getArcWidth())) / 2.0;
                    var ah = Math.min(this.getHeight(), Math.abs(this.getArcHeight())) / 2.0;
                    if (x >= (rrx0 += aw) && x < (rrx0 = rrx1 - aw)) {
                        return true;
                    }
                    if (y >= (rry0 += ah) && y < (rry0 = rry1 - ah)) {
                        return true;
                    }
                    x = (x - rrx0) / aw;
                    y = (y - rry0) / ah;
                    return (x * x + y * y <= 1.0);
                };
                RoundRectangle2D.prototype.classify = function (coord, left, right, arcsize) {
                    if (coord < left) {
                        return 0;
                    }
                    else if (coord < left + arcsize) {
                        return 1;
                    }
                    else if (coord < right - arcsize) {
                        return 2;
                    }
                    else if (coord < right) {
                        return 3;
                    }
                    else {
                        return 4;
                    }
                };
                RoundRectangle2D.prototype.intersects$double$double$double$double = function (x, y, w, h) {
                    if (this.isEmpty() || w <= 0 || h <= 0) {
                        return false;
                    }
                    var rrx0 = this.getX();
                    var rry0 = this.getY();
                    var rrx1 = rrx0 + this.getWidth();
                    var rry1 = rry0 + this.getHeight();
                    if (x + w <= rrx0 || x >= rrx1 || y + h <= rry0 || y >= rry1) {
                        return false;
                    }
                    var aw = Math.min(this.getWidth(), Math.abs(this.getArcWidth())) / 2.0;
                    var ah = Math.min(this.getHeight(), Math.abs(this.getArcHeight())) / 2.0;
                    var x0class = this.classify(x, rrx0, rrx1, aw);
                    var x1class = this.classify(x + w, rrx0, rrx1, aw);
                    var y0class = this.classify(y, rry0, rry1, ah);
                    var y1class = this.classify(y + h, rry0, rry1, ah);
                    if (x0class === 2 || x1class === 2 || y0class === 2 || y1class === 2) {
                        return true;
                    }
                    if ((x0class < 2 && x1class > 2) || (y0class < 2 && y1class > 2)) {
                        return true;
                    }
                    x = (x1class === 1) ? (x = x + w - (rrx0 + aw)) : (x = x - (rrx1 - aw));
                    y = (y1class === 1) ? (y = y + h - (rry0 + ah)) : (y = y - (rry1 - ah));
                    x = x / aw;
                    y = y / ah;
                    return (x * x + y * y <= 1.0);
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 * @param {number} x
                 * @param {number} y
                 * @param {number} w
                 * @param {number} h
                 * @return {boolean}
                 */
                RoundRectangle2D.prototype.intersects = function (x, y, w, h) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        return this.intersects$double$double$double$double(x, y, w, h);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.intersects$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                RoundRectangle2D.prototype.contains$double$double$double$double = function (x, y, w, h) {
                    if (this.isEmpty() || w <= 0 || h <= 0) {
                        return false;
                    }
                    return (this.contains$double$double(x, y) && this.contains$double$double(x + w, y) && this.contains$double$double(x, y + h) && this.contains$double$double(x + w, y + h));
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 * @param {number} x
                 * @param {number} y
                 * @param {number} w
                 * @param {number} h
                 * @return {boolean}
                 */
                RoundRectangle2D.prototype.contains = function (x, y, w, h) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        return this.contains$double$double$double$double(x, y, w, h);
                    }
                    else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && w === undefined && h === undefined) {
                        return this.contains$double$double(x, y);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.contains$java_awt_geom_Point2D(x);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.contains$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                RoundRectangle2D.prototype.getPathIterator = function (at, flatness) {
                    if (((at != null && at instanceof java.awt.geom.AffineTransform) || at === null) && ((typeof flatness === 'number') || flatness === null)) {
                        return _super.prototype.getPathIterator.call(this, at, flatness);
                    }
                    else if (((at != null && at instanceof java.awt.geom.AffineTransform) || at === null) && flatness === undefined) {
                        return this.getPathIterator$java_awt_geom_AffineTransform(at);
                    }
                    else
                        throw new Error('invalid overload');
                };
                RoundRectangle2D.prototype.getPathIterator$java_awt_geom_AffineTransform = function (at) {
                    return new java.awt.geom.RoundRectIterator(this, at);
                };
                /**
                 * Determines whether or not the specified <code>Object</code> is equal to
                 * this <code>RoundRectangle2D</code>. The specified <code>Object</code> is
                 * equal to this <code>RoundRectangle2D</code> if it is an instance of
                 * <code>RoundRectangle2D</code> and if its location, size, and corner arc
                 * dimensions are the same as this <code>RoundRectangle2D</code>.
                 *
                 * @param {*} obj
                 * an <code>Object</code> to be compared with this
                 * <code>RoundRectangle2D</code>.
                 * @return {boolean} <code>true</code> if <code>obj</code> is an instance of
                 * <code>RoundRectangle2D</code> and has the same values;
                 * <code>false</code> otherwise.
                 * @since 1.6
                 */
                RoundRectangle2D.prototype.equals = function (obj) {
                    if (obj === this) {
                        return true;
                    }
                    if (obj != null && obj instanceof java.awt.geom.RoundRectangle2D) {
                        var rr2d = obj;
                        return ((this.getX() === rr2d.getX()) && (this.getY() === rr2d.getY()) && (this.getWidth() === rr2d.getWidth()) && (this.getHeight() === rr2d.getHeight()) && (this.getArcWidth() === rr2d.getArcWidth()) && (this.getArcHeight() === rr2d.getArcHeight()));
                    }
                    return false;
                };
                return RoundRectangle2D;
            }(java.awt.geom.RectangularShape));
            geom.RoundRectangle2D = RoundRectangle2D;
            RoundRectangle2D["__class"] = "java.awt.geom.RoundRectangle2D";
            RoundRectangle2D["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable"];
            (function (RoundRectangle2D) {
                /**
                 * Constructs and initializes a <code>RoundRectangle2D</code> from the
                 * specified <code>float</code> coordinates.
                 *
                 * @param {number} x
                 * the X coordinate of the newly constructed
                 * <code>RoundRectangle2D</code>
                 * @param {number} y
                 * the Y coordinate of the newly constructed
                 * <code>RoundRectangle2D</code>
                 * @param {number} w
                 * the width to which to set the newly constructed
                 * <code>RoundRectangle2D</code>
                 * @param {number} h
                 * the height to which to set the newly constructed
                 * <code>RoundRectangle2D</code>
                 * @param {number} arcw
                 * the width of the arc to use to round off the corners of
                 * the newly constructed <code>RoundRectangle2D</code>
                 * @param {number} arch
                 * the height of the arc to use to round off the corners of
                 * the newly constructed <code>RoundRectangle2D</code>
                 * @since 1.2
                 * @class
                 * @extends java.awt.geom.RoundRectangle2D
                 */
                var Float = /** @class */ (function (_super) {
                    __extends(Float, _super);
                    function Float(x, y, w, h, arcw, arch) {
                        var _this = this;
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((typeof arcw === 'number') || arcw === null) && ((typeof arch === 'number') || arch === null)) {
                            var __args = arguments;
                            _this = _super.call(this) || this;
                            if (_this.x === undefined)
                                _this.x = 0;
                            if (_this.y === undefined)
                                _this.y = 0;
                            if (_this.width === undefined)
                                _this.width = 0;
                            if (_this.height === undefined)
                                _this.height = 0;
                            if (_this.arcwidth === undefined)
                                _this.arcwidth = 0;
                            if (_this.archeight === undefined)
                                _this.archeight = 0;
                            if (_this.x === undefined)
                                _this.x = 0;
                            if (_this.y === undefined)
                                _this.y = 0;
                            if (_this.width === undefined)
                                _this.width = 0;
                            if (_this.height === undefined)
                                _this.height = 0;
                            if (_this.arcwidth === undefined)
                                _this.arcwidth = 0;
                            if (_this.archeight === undefined)
                                _this.archeight = 0;
                            (function () {
                                _this.setRoundRect$float$float$float$float$float$float(x, y, w, h, arcw, arch);
                            })();
                        }
                        else if (x === undefined && y === undefined && w === undefined && h === undefined && arcw === undefined && arch === undefined) {
                            var __args = arguments;
                            _this = _super.call(this) || this;
                            if (_this.x === undefined)
                                _this.x = 0;
                            if (_this.y === undefined)
                                _this.y = 0;
                            if (_this.width === undefined)
                                _this.width = 0;
                            if (_this.height === undefined)
                                _this.height = 0;
                            if (_this.arcwidth === undefined)
                                _this.arcwidth = 0;
                            if (_this.archeight === undefined)
                                _this.archeight = 0;
                            if (_this.x === undefined)
                                _this.x = 0;
                            if (_this.y === undefined)
                                _this.y = 0;
                            if (_this.width === undefined)
                                _this.width = 0;
                            if (_this.height === undefined)
                                _this.height = 0;
                            if (_this.arcwidth === undefined)
                                _this.arcwidth = 0;
                            if (_this.archeight === undefined)
                                _this.archeight = 0;
                        }
                        else
                            throw new Error('invalid overload');
                        return _this;
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Float.prototype.getX = function () {
                        return this.x;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Float.prototype.getY = function () {
                        return this.y;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Float.prototype.getWidth = function () {
                        return this.width;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Float.prototype.getHeight = function () {
                        return this.height;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Float.prototype.getArcWidth = function () {
                        return this.arcwidth;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Float.prototype.getArcHeight = function () {
                        return this.archeight;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {boolean}
                     */
                    Float.prototype.isEmpty = function () {
                        return (this.width <= 0.0) || (this.height <= 0.0);
                    };
                    Float.prototype.setRoundRect$float$float$float$float$float$float = function (x, y, w, h, arcw, arch) {
                        this.x = x;
                        this.y = y;
                        this.width = w;
                        this.height = h;
                        this.arcwidth = arcw;
                        this.archeight = arch;
                    };
                    /**
                     * Sets the location, size, and corner radii of this
                     * <code>RoundRectangle2D</code> to the specified <code>float</code>
                     * values.
                     *
                     * @param {number} x
                     * the X coordinate to which to set the location of this
                     * <code>RoundRectangle2D</code>
                     * @param {number} y
                     * the Y coordinate to which to set the location of this
                     * <code>RoundRectangle2D</code>
                     * @param {number} w
                     * the width to which to set this
                     * <code>RoundRectangle2D</code>
                     * @param {number} h
                     * the height to which to set this
                     * <code>RoundRectangle2D</code>
                     * @param {number} arcw
                     * the width to which to set the arc of this
                     * <code>RoundRectangle2D</code>
                     * @param {number} arch
                     * the height to which to set the arc of this
                     * <code>RoundRectangle2D</code>
                     * @since 1.2
                     */
                    Float.prototype.setRoundRect = function (x, y, w, h, arcw, arch) {
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((typeof arcw === 'number') || arcw === null) && ((typeof arch === 'number') || arch === null)) {
                            return this.setRoundRect$float$float$float$float$float$float(x, y, w, h, arcw, arch);
                        }
                        else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((typeof arcw === 'number') || arcw === null) && ((typeof arch === 'number') || arch === null)) {
                            return this.setRoundRect$double$double$double$double$double$double(x, y, w, h, arcw, arch);
                        }
                        else if (((x != null && x instanceof java.awt.geom.RoundRectangle2D) || x === null) && y === undefined && w === undefined && h === undefined && arcw === undefined && arch === undefined) {
                            return this.setRoundRect$java_awt_geom_RoundRectangle2D(x);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    Float.prototype.setRoundRect$double$double$double$double$double$double = function (x, y, w, h, arcw, arch) {
                        this.x = x;
                        this.y = y;
                        this.width = w;
                        this.height = h;
                        this.arcwidth = arcw;
                        this.archeight = arch;
                    };
                    Float.prototype.setRoundRect$java_awt_geom_RoundRectangle2D = function (rr) {
                        this.x = rr.getX();
                        this.y = rr.getY();
                        this.width = rr.getWidth();
                        this.height = rr.getHeight();
                        this.arcwidth = rr.getArcWidth();
                        this.archeight = rr.getArcHeight();
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {java.awt.geom.Rectangle2D}
                     */
                    Float.prototype.getBounds2D = function () {
                        return new java.awt.geom.Rectangle2D.Float(this.x, this.y, this.width, this.height);
                    };
                    Float.serialVersionUID = -3423150618393866922;
                    return Float;
                }(java.awt.geom.RoundRectangle2D));
                RoundRectangle2D.Float = Float;
                Float["__class"] = "java.awt.geom.RoundRectangle2D.Float";
                Float["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"];
                /**
                 * Constructs and initializes a <code>RoundRectangle2D</code> from the
                 * specified <code>double</code> coordinates.
                 *
                 * @param {number} x
                 * the X coordinate of the newly constructed
                 * <code>RoundRectangle2D</code>
                 * @param {number} y
                 * the Y coordinate of the newly constructed
                 * <code>RoundRectangle2D</code>
                 * @param {number} w
                 * the width to which to set the newly constructed
                 * <code>RoundRectangle2D</code>
                 * @param {number} h
                 * the height to which to set the newly constructed
                 * <code>RoundRectangle2D</code>
                 * @param {number} arcw
                 * the width of the arc to use to round off the corners of
                 * the newly constructed <code>RoundRectangle2D</code>
                 * @param {number} arch
                 * the height of the arc to use to round off the corners of
                 * the newly constructed <code>RoundRectangle2D</code>
                 * @since 1.2
                 * @class
                 * @extends java.awt.geom.RoundRectangle2D
                 */
                var Double = /** @class */ (function (_super) {
                    __extends(Double, _super);
                    function Double(x, y, w, h, arcw, arch) {
                        var _this = this;
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((typeof arcw === 'number') || arcw === null) && ((typeof arch === 'number') || arch === null)) {
                            var __args = arguments;
                            _this = _super.call(this) || this;
                            if (_this.x === undefined)
                                _this.x = 0;
                            if (_this.y === undefined)
                                _this.y = 0;
                            if (_this.width === undefined)
                                _this.width = 0;
                            if (_this.height === undefined)
                                _this.height = 0;
                            if (_this.arcwidth === undefined)
                                _this.arcwidth = 0;
                            if (_this.archeight === undefined)
                                _this.archeight = 0;
                            if (_this.x === undefined)
                                _this.x = 0;
                            if (_this.y === undefined)
                                _this.y = 0;
                            if (_this.width === undefined)
                                _this.width = 0;
                            if (_this.height === undefined)
                                _this.height = 0;
                            if (_this.arcwidth === undefined)
                                _this.arcwidth = 0;
                            if (_this.archeight === undefined)
                                _this.archeight = 0;
                            (function () {
                                _this.setRoundRect$double$double$double$double$double$double(x, y, w, h, arcw, arch);
                            })();
                        }
                        else if (x === undefined && y === undefined && w === undefined && h === undefined && arcw === undefined && arch === undefined) {
                            var __args = arguments;
                            _this = _super.call(this) || this;
                            if (_this.x === undefined)
                                _this.x = 0;
                            if (_this.y === undefined)
                                _this.y = 0;
                            if (_this.width === undefined)
                                _this.width = 0;
                            if (_this.height === undefined)
                                _this.height = 0;
                            if (_this.arcwidth === undefined)
                                _this.arcwidth = 0;
                            if (_this.archeight === undefined)
                                _this.archeight = 0;
                            if (_this.x === undefined)
                                _this.x = 0;
                            if (_this.y === undefined)
                                _this.y = 0;
                            if (_this.width === undefined)
                                _this.width = 0;
                            if (_this.height === undefined)
                                _this.height = 0;
                            if (_this.arcwidth === undefined)
                                _this.arcwidth = 0;
                            if (_this.archeight === undefined)
                                _this.archeight = 0;
                        }
                        else
                            throw new Error('invalid overload');
                        return _this;
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Double.prototype.getX = function () {
                        return this.x;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Double.prototype.getY = function () {
                        return this.y;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Double.prototype.getWidth = function () {
                        return this.width;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Double.prototype.getHeight = function () {
                        return this.height;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Double.prototype.getArcWidth = function () {
                        return this.arcwidth;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Double.prototype.getArcHeight = function () {
                        return this.archeight;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {boolean}
                     */
                    Double.prototype.isEmpty = function () {
                        return (this.width <= 0.0) || (this.height <= 0.0);
                    };
                    Double.prototype.setRoundRect$double$double$double$double$double$double = function (x, y, w, h, arcw, arch) {
                        this.x = x;
                        this.y = y;
                        this.width = w;
                        this.height = h;
                        this.arcwidth = arcw;
                        this.archeight = arch;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @param {number} x
                     * @param {number} y
                     * @param {number} w
                     * @param {number} h
                     * @param {number} arcw
                     * @param {number} arch
                     */
                    Double.prototype.setRoundRect = function (x, y, w, h, arcw, arch) {
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((typeof arcw === 'number') || arcw === null) && ((typeof arch === 'number') || arch === null)) {
                            return this.setRoundRect$double$double$double$double$double$double(x, y, w, h, arcw, arch);
                        }
                        else if (((x != null && x instanceof java.awt.geom.RoundRectangle2D) || x === null) && y === undefined && w === undefined && h === undefined && arcw === undefined && arch === undefined) {
                            return this.setRoundRect$java_awt_geom_RoundRectangle2D(x);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    Double.prototype.setRoundRect$java_awt_geom_RoundRectangle2D = function (rr) {
                        this.x = rr.getX();
                        this.y = rr.getY();
                        this.width = rr.getWidth();
                        this.height = rr.getHeight();
                        this.arcwidth = rr.getArcWidth();
                        this.archeight = rr.getArcHeight();
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {java.awt.geom.Rectangle2D}
                     */
                    Double.prototype.getBounds2D = function () {
                        return new java.awt.geom.Rectangle2D.Double(this.x, this.y, this.width, this.height);
                    };
                    Double.serialVersionUID = 1048939333485206117;
                    return Double;
                }(java.awt.geom.RoundRectangle2D));
                RoundRectangle2D.Double = Double;
                Double["__class"] = "java.awt.geom.RoundRectangle2D.Double";
                Double["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"];
            })(RoundRectangle2D = geom.RoundRectangle2D || (geom.RoundRectangle2D = {}));
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * The <code>Ellipse2D</code> class describes an ellipse that is defined by a
             * framing rectangle.
             * <p>
             * This class is only the abstract superclass for all objects which store a 2D
             * ellipse. The actual storage representation of the coordinates is left to the
             * subclass.
             *
             * @author Jim Graham
             * @since 1.2
             * @extends java.awt.geom.RectangularShape
             * @class
             */
            var Ellipse2D = /** @class */ (function (_super) {
                __extends(Ellipse2D, _super);
                function Ellipse2D() {
                    return _super.call(this) || this;
                }
                Ellipse2D.prototype.contains$double$double = function (x, y) {
                    var ellw = this.getWidth();
                    if (ellw <= 0.0) {
                        return false;
                    }
                    var normx = (x - this.getX()) / ellw - 0.5;
                    var ellh = this.getHeight();
                    if (ellh <= 0.0) {
                        return false;
                    }
                    var normy = (y - this.getY()) / ellh - 0.5;
                    return (normx * normx + normy * normy) < 0.25;
                };
                Ellipse2D.prototype.intersects$double$double$double$double = function (x, y, w, h) {
                    if (w <= 0.0 || h <= 0.0) {
                        return false;
                    }
                    var ellw = this.getWidth();
                    if (ellw <= 0.0) {
                        return false;
                    }
                    var normx0 = (x - this.getX()) / ellw - 0.5;
                    var normx1 = normx0 + w / ellw;
                    var ellh = this.getHeight();
                    if (ellh <= 0.0) {
                        return false;
                    }
                    var normy0 = (y - this.getY()) / ellh - 0.5;
                    var normy1 = normy0 + h / ellh;
                    var nearx;
                    var neary;
                    if (normx0 > 0.0) {
                        nearx = normx0;
                    }
                    else if (normx1 < 0.0) {
                        nearx = normx1;
                    }
                    else {
                        nearx = 0.0;
                    }
                    if (normy0 > 0.0) {
                        neary = normy0;
                    }
                    else if (normy1 < 0.0) {
                        neary = normy1;
                    }
                    else {
                        neary = 0.0;
                    }
                    return (nearx * nearx + neary * neary) < 0.25;
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 * @param {number} x
                 * @param {number} y
                 * @param {number} w
                 * @param {number} h
                 * @return {boolean}
                 */
                Ellipse2D.prototype.intersects = function (x, y, w, h) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        return this.intersects$double$double$double$double(x, y, w, h);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.intersects$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Ellipse2D.prototype.contains$double$double$double$double = function (x, y, w, h) {
                    return (this.contains$double$double(x, y) && this.contains$double$double(x + w, y) && this.contains$double$double(x, y + h) && this.contains$double$double(x + w, y + h));
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 * @param {number} x
                 * @param {number} y
                 * @param {number} w
                 * @param {number} h
                 * @return {boolean}
                 */
                Ellipse2D.prototype.contains = function (x, y, w, h) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        return this.contains$double$double$double$double(x, y, w, h);
                    }
                    else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && w === undefined && h === undefined) {
                        return this.contains$double$double(x, y);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.contains$java_awt_geom_Point2D(x);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.contains$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Ellipse2D.prototype.getPathIterator = function (at, flatness) {
                    if (((at != null && at instanceof java.awt.geom.AffineTransform) || at === null) && ((typeof flatness === 'number') || flatness === null)) {
                        return _super.prototype.getPathIterator.call(this, at, flatness);
                    }
                    else if (((at != null && at instanceof java.awt.geom.AffineTransform) || at === null) && flatness === undefined) {
                        return this.getPathIterator$java_awt_geom_AffineTransform(at);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Ellipse2D.prototype.getPathIterator$java_awt_geom_AffineTransform = function (at) {
                    return new java.awt.geom.EllipseIterator(this, at);
                };
                /**
                 * Determines whether or not the specified <code>Object</code> is equal to
                 * this <code>Ellipse2D</code>. The specified <code>Object</code> is equal
                 * to this <code>Ellipse2D</code> if it is an instance of
                 * <code>Ellipse2D</code> and if its location and size are the same as this
                 * <code>Ellipse2D</code>.
                 *
                 * @param {*} obj
                 * an <code>Object</code> to be compared with this
                 * <code>Ellipse2D</code>.
                 * @return {boolean} <code>true</code> if <code>obj</code> is an instance of
                 * <code>Ellipse2D</code> and has the same values;
                 * <code>false</code> otherwise.
                 * @since 1.6
                 */
                Ellipse2D.prototype.equals = function (obj) {
                    if (obj === this) {
                        return true;
                    }
                    if (obj != null && obj instanceof java.awt.geom.Ellipse2D) {
                        var e2d = obj;
                        return ((this.getX() === e2d.getX()) && (this.getY() === e2d.getY()) && (this.getWidth() === e2d.getWidth()) && (this.getHeight() === e2d.getHeight()));
                    }
                    return false;
                };
                return Ellipse2D;
            }(java.awt.geom.RectangularShape));
            geom.Ellipse2D = Ellipse2D;
            Ellipse2D["__class"] = "java.awt.geom.Ellipse2D";
            Ellipse2D["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable"];
            (function (Ellipse2D) {
                /**
                 * Constructs and initializes an <code>Ellipse2D</code> from the
                 * specified coordinates.
                 *
                 * @param {number} x
                 * the X coordinate of the upper-left corner of the framing
                 * rectangle
                 * @param {number} y
                 * the Y coordinate of the upper-left corner of the framing
                 * rectangle
                 * @param {number} w
                 * the width of the framing rectangle
                 * @param {number} h
                 * the height of the framing rectangle
                 * @since 1.2
                 * @class
                 * @extends java.awt.geom.Ellipse2D
                 */
                var Float = /** @class */ (function (_super) {
                    __extends(Float, _super);
                    function Float(x, y, w, h) {
                        var _this = this;
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                            var __args = arguments;
                            _this = _super.call(this) || this;
                            if (_this.x === undefined)
                                _this.x = 0;
                            if (_this.y === undefined)
                                _this.y = 0;
                            if (_this.width === undefined)
                                _this.width = 0;
                            if (_this.height === undefined)
                                _this.height = 0;
                            if (_this.x === undefined)
                                _this.x = 0;
                            if (_this.y === undefined)
                                _this.y = 0;
                            if (_this.width === undefined)
                                _this.width = 0;
                            if (_this.height === undefined)
                                _this.height = 0;
                            (function () {
                                _this.setFrame$float$float$float$float(x, y, w, h);
                            })();
                        }
                        else if (x === undefined && y === undefined && w === undefined && h === undefined) {
                            var __args = arguments;
                            _this = _super.call(this) || this;
                            if (_this.x === undefined)
                                _this.x = 0;
                            if (_this.y === undefined)
                                _this.y = 0;
                            if (_this.width === undefined)
                                _this.width = 0;
                            if (_this.height === undefined)
                                _this.height = 0;
                            if (_this.x === undefined)
                                _this.x = 0;
                            if (_this.y === undefined)
                                _this.y = 0;
                            if (_this.width === undefined)
                                _this.width = 0;
                            if (_this.height === undefined)
                                _this.height = 0;
                        }
                        else
                            throw new Error('invalid overload');
                        return _this;
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Float.prototype.getX = function () {
                        return this.x;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Float.prototype.getY = function () {
                        return this.y;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Float.prototype.getWidth = function () {
                        return this.width;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Float.prototype.getHeight = function () {
                        return this.height;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {boolean}
                     */
                    Float.prototype.isEmpty = function () {
                        return (this.width <= 0.0 || this.height <= 0.0);
                    };
                    Float.prototype.setFrame$float$float$float$float = function (x, y, w, h) {
                        this.x = x;
                        this.y = y;
                        this.width = w;
                        this.height = h;
                    };
                    /**
                     * Sets the location and size of the framing rectangle of this
                     * <code>Shape</code> to the specified rectangular values.
                     *
                     * @param {number} x
                     * the X coordinate of the upper-left corner of the specified
                     * rectangular shape
                     * @param {number} y
                     * the Y coordinate of the upper-left corner of the specified
                     * rectangular shape
                     * @param {number} w
                     * the width of the specified rectangular shape
                     * @param {number} h
                     * the height of the specified rectangular shape
                     * @since 1.2
                     */
                    Float.prototype.setFrame = function (x, y, w, h) {
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                            return this.setFrame$float$float$float$float(x, y, w, h);
                        }
                        else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                            return this.setFrame$double$double$double$double(x, y, w, h);
                        }
                        else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && ((y != null && y instanceof java.awt.geom.Dimension2D) || y === null) && w === undefined && h === undefined) {
                            return this.setFrame$java_awt_geom_Point2D$java_awt_geom_Dimension2D(x, y);
                        }
                        else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                            return this.setFrame$java_awt_geom_Rectangle2D(x);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    Float.prototype.setFrame$double$double$double$double = function (x, y, w, h) {
                        this.x = x;
                        this.y = y;
                        this.width = w;
                        this.height = h;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {java.awt.geom.Rectangle2D}
                     */
                    Float.prototype.getBounds2D = function () {
                        return new java.awt.geom.Rectangle2D.Float(this.x, this.y, this.width, this.height);
                    };
                    Float.serialVersionUID = -6633761252372475977;
                    return Float;
                }(java.awt.geom.Ellipse2D));
                Ellipse2D.Float = Float;
                Float["__class"] = "java.awt.geom.Ellipse2D.Float";
                Float["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"];
                /**
                 * Constructs and initializes an <code>Ellipse2D</code> from the
                 * specified coordinates.
                 *
                 * @param {number} x
                 * the X coordinate of the upper-left corner of the framing
                 * rectangle
                 * @param {number} y
                 * the Y coordinate of the upper-left corner of the framing
                 * rectangle
                 * @param {number} w
                 * the width of the framing rectangle
                 * @param {number} h
                 * the height of the framing rectangle
                 * @since 1.2
                 * @class
                 * @extends java.awt.geom.Ellipse2D
                 */
                var Double = /** @class */ (function (_super) {
                    __extends(Double, _super);
                    function Double(x, y, w, h) {
                        var _this = this;
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                            var __args = arguments;
                            _this = _super.call(this) || this;
                            if (_this.x === undefined)
                                _this.x = 0;
                            if (_this.y === undefined)
                                _this.y = 0;
                            if (_this.width === undefined)
                                _this.width = 0;
                            if (_this.height === undefined)
                                _this.height = 0;
                            if (_this.x === undefined)
                                _this.x = 0;
                            if (_this.y === undefined)
                                _this.y = 0;
                            if (_this.width === undefined)
                                _this.width = 0;
                            if (_this.height === undefined)
                                _this.height = 0;
                            (function () {
                                _this.setFrame$double$double$double$double(x, y, w, h);
                            })();
                        }
                        else if (x === undefined && y === undefined && w === undefined && h === undefined) {
                            var __args = arguments;
                            _this = _super.call(this) || this;
                            if (_this.x === undefined)
                                _this.x = 0;
                            if (_this.y === undefined)
                                _this.y = 0;
                            if (_this.width === undefined)
                                _this.width = 0;
                            if (_this.height === undefined)
                                _this.height = 0;
                            if (_this.x === undefined)
                                _this.x = 0;
                            if (_this.y === undefined)
                                _this.y = 0;
                            if (_this.width === undefined)
                                _this.width = 0;
                            if (_this.height === undefined)
                                _this.height = 0;
                        }
                        else
                            throw new Error('invalid overload');
                        return _this;
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Double.prototype.getX = function () {
                        return this.x;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Double.prototype.getY = function () {
                        return this.y;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Double.prototype.getWidth = function () {
                        return this.width;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Double.prototype.getHeight = function () {
                        return this.height;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {boolean}
                     */
                    Double.prototype.isEmpty = function () {
                        return (this.width <= 0.0 || this.height <= 0.0);
                    };
                    Double.prototype.setFrame$double$double$double$double = function (x, y, w, h) {
                        this.x = x;
                        this.y = y;
                        this.width = w;
                        this.height = h;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @param {number} x
                     * @param {number} y
                     * @param {number} w
                     * @param {number} h
                     */
                    Double.prototype.setFrame = function (x, y, w, h) {
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                            return this.setFrame$double$double$double$double(x, y, w, h);
                        }
                        else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && ((y != null && y instanceof java.awt.geom.Dimension2D) || y === null) && w === undefined && h === undefined) {
                            return this.setFrame$java_awt_geom_Point2D$java_awt_geom_Dimension2D(x, y);
                        }
                        else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                            return this.setFrame$java_awt_geom_Rectangle2D(x);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {java.awt.geom.Rectangle2D}
                     */
                    Double.prototype.getBounds2D = function () {
                        return new java.awt.geom.Rectangle2D.Double(this.x, this.y, this.width, this.height);
                    };
                    Double.serialVersionUID = 5555464816372320683;
                    return Double;
                }(java.awt.geom.Ellipse2D));
                Ellipse2D.Double = Double;
                Double["__class"] = "java.awt.geom.Ellipse2D.Double";
                Double["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"];
            })(Ellipse2D = geom.Ellipse2D || (geom.Ellipse2D = {}));
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * <CODE>Arc2D</CODE> is the abstract superclass for all objects that
             * store a 2D arc defined by a framing rectangle,
             * start angle, angular extent (length of the arc), and a closure type
             * (<CODE>OPEN</CODE>, <CODE>CHORD</CODE>, or <CODE>PIE</CODE>).
             * <p>
             * <a name="inscribes">
             * The arc is a partial section of a full ellipse which
             * inscribes the framing rectangle of its parent {@link RectangularShape}.
             * </a>
             * <a name="angles">
             * The angles are specified relative to the non-square
             * framing rectangle such that 45 degrees always falls on the line from
             * the center of the ellipse to the upper right corner of the framing
             * rectangle.
             * As a result, if the framing rectangle is noticeably longer along one
             * axis than the other, the angles to the start and end of the arc segment
             * will be skewed farther along the longer axis of the frame.
             * </a>
             * <p>
             * The actual storage representation of the coordinates is left to
             * the subclass.
             *
             * @author      Jim Graham
             * @since 1.2
             * @extends java.awt.geom.RectangularShape
             * @class
             */
            var Arc2D = /** @class */ (function (_super) {
                __extends(Arc2D, _super);
                function Arc2D(type) {
                    var _this = this;
                    if (((typeof type === 'number') || type === null)) {
                        var __args = arguments;
                        _this = _super.call(this) || this;
                        if (_this.type === undefined)
                            _this.type = 0;
                        if (_this.type === undefined)
                            _this.type = 0;
                        (function () {
                            _this.setArcType(type);
                        })();
                    }
                    else if (type === undefined) {
                        var __args = arguments;
                        {
                            var __args_9 = arguments;
                            var type_1 = Arc2D.OPEN;
                            _this = _super.call(this) || this;
                            if (_this.type === undefined)
                                _this.type = 0;
                            if (_this.type === undefined)
                                _this.type = 0;
                            (function () {
                                _this.setArcType(type_1);
                            })();
                        }
                    }
                    else
                        throw new Error('invalid overload');
                    return _this;
                }
                /**
                 * Returns the arc closure type of the arc: {@link #OPEN},
                 * {@link #CHORD}, or {@link #PIE}.
                 * @return {number} One of the integer constant closure types defined
                 * in this class.
                 * @see #setArcType
                 * @since 1.2
                 */
                Arc2D.prototype.getArcType = function () {
                    return this.type;
                };
                /**
                 * Returns the starting point of the arc.  This point is the
                 * intersection of the ray from the center defined by the
                 * starting angle and the elliptical boundary of the arc.
                 *
                 * @return {java.awt.geom.Point2D} A <CODE>Point2D</CODE> object representing the
                 * x,y coordinates of the starting point of the arc.
                 * @since 1.2
                 */
                Arc2D.prototype.getStartPoint = function () {
                    var angle = (function (x) { return x * Math.PI / 180; })(-this.getAngleStart());
                    var x = this.getX() + (Math.cos(angle) * 0.5 + 0.5) * this.getWidth();
                    var y = this.getY() + (Math.sin(angle) * 0.5 + 0.5) * this.getHeight();
                    return new java.awt.geom.Point2D.Double(x, y);
                };
                /**
                 * Returns the ending point of the arc.  This point is the
                 * intersection of the ray from the center defined by the
                 * starting angle plus the angular extent of the arc and the
                 * elliptical boundary of the arc.
                 *
                 * @return {java.awt.geom.Point2D} A <CODE>Point2D</CODE> object representing the
                 * x,y coordinates  of the ending point of the arc.
                 * @since 1.2
                 */
                Arc2D.prototype.getEndPoint = function () {
                    var angle = (function (x) { return x * Math.PI / 180; })(-this.getAngleStart() - this.getAngleExtent());
                    var x = this.getX() + (Math.cos(angle) * 0.5 + 0.5) * this.getWidth();
                    var y = this.getY() + (Math.sin(angle) * 0.5 + 0.5) * this.getHeight();
                    return new java.awt.geom.Point2D.Double(x, y);
                };
                Arc2D.prototype.setArc$double$double$double$double$double$double$int = function (x, y, w, h, angSt, angExt, closure) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
                /**
                 * Sets the location, size, angular extents, and closure type of
                 * this arc to the specified double values.
                 *
                 * @param {number} x The X coordinate of the upper-left corner of the arc.
                 * @param {number} y The Y coordinate of the upper-left corner of the arc.
                 * @param {number} w The overall width of the full ellipse of which
                 * this arc is a partial section.
                 * @param {number} h The overall height of the full ellipse of which
                 * this arc is a partial section.
                 * @param {number} angSt The starting angle of the arc in degrees.
                 * @param {number} angExt The angular extent of the arc in degrees.
                 * @param {number} closure The closure type for the arc:
                 * {@link #OPEN}, {@link #CHORD}, or {@link #PIE}.
                 * @since 1.2
                 */
                Arc2D.prototype.setArc = function (x, y, w, h, angSt, angExt, closure) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((typeof angSt === 'number') || angSt === null) && ((typeof angExt === 'number') || angExt === null) && ((typeof closure === 'number') || closure === null)) {
                        return this.setArc$double$double$double$double$double$double$int(x, y, w, h, angSt, angExt, closure);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && ((y != null && y instanceof java.awt.geom.Dimension2D) || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((typeof angSt === 'number') || angSt === null) && angExt === undefined && closure === undefined) {
                        return this.setArc$java_awt_geom_Point2D$java_awt_geom_Dimension2D$double$double$int(x, y, w, h, angSt);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && angSt === undefined && angExt === undefined && closure === undefined) {
                        return this.setArc$java_awt_geom_Rectangle2D$double$double$int(x, y, w, h);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Arc2D) || x === null) && y === undefined && w === undefined && h === undefined && angSt === undefined && angExt === undefined && closure === undefined) {
                        return this.setArc$java_awt_geom_Arc2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Arc2D.prototype.setArc$java_awt_geom_Point2D$java_awt_geom_Dimension2D$double$double$int = function (loc, size, angSt, angExt, closure) {
                    this.setArc$double$double$double$double$double$double$int(loc.getX(), loc.getY(), size.getWidth(), size.getHeight(), angSt, angExt, closure);
                };
                Arc2D.prototype.setArc$java_awt_geom_Rectangle2D$double$double$int = function (rect, angSt, angExt, closure) {
                    this.setArc$double$double$double$double$double$double$int(rect.getX(), rect.getY(), rect.getWidth(), rect.getHeight(), angSt, angExt, closure);
                };
                Arc2D.prototype.setArc$java_awt_geom_Arc2D = function (a) {
                    this.setArc$double$double$double$double$double$double$int(a.getX(), a.getY(), a.getWidth(), a.getHeight(), a.getAngleStart(), a.getAngleExtent(), a.type);
                };
                /**
                 * Sets the position, bounds, angular extents, and closure type of
                 * this arc to the specified values. The arc is defined by a center
                 * point and a radius rather than a framing rectangle for the full ellipse.
                 *
                 * @param {number} x The X coordinate of the center of the arc.
                 * @param {number} y The Y coordinate of the center of the arc.
                 * @param {number} radius The radius of the arc.
                 * @param {number} angSt The starting angle of the arc in degrees.
                 * @param {number} angExt The angular extent of the arc in degrees.
                 * @param {number} closure The closure type for the arc:
                 * {@link #OPEN}, {@link #CHORD}, or {@link #PIE}.
                 * @since 1.2
                 */
                Arc2D.prototype.setArcByCenter = function (x, y, radius, angSt, angExt, closure) {
                    this.setArc$double$double$double$double$double$double$int(x - radius, y - radius, radius * 2.0, radius * 2.0, angSt, angExt, closure);
                };
                /**
                 * Sets the position, bounds, and angular extents of this arc to the
                 * specified value. The starting angle of the arc is tangent to the
                 * line specified by points (p1, p2), the ending angle is tangent to
                 * the line specified by points (p2, p3), and the arc has the
                 * specified radius.
                 *
                 * @param {java.awt.geom.Point2D} p1 The first point that defines the arc. The starting
                 * angle of the arc is tangent to the line specified by points (p1, p2).
                 * @param {java.awt.geom.Point2D} p2 The second point that defines the arc. The starting
                 * angle of the arc is tangent to the line specified by points (p1, p2).
                 * The ending angle of the arc is tangent to the line specified by
                 * points (p2, p3).
                 * @param {java.awt.geom.Point2D} p3 The third point that defines the arc. The ending angle
                 * of the arc is tangent to the line specified by points (p2, p3).
                 * @param {number} radius The radius of the arc.
                 * @since 1.2
                 */
                Arc2D.prototype.setArcByTangent = function (p1, p2, p3, radius) {
                    var ang1 = Math.atan2(p1.getY() - p2.getY(), p1.getX() - p2.getX());
                    var ang2 = Math.atan2(p3.getY() - p2.getY(), p3.getX() - p2.getX());
                    var diff = ang2 - ang1;
                    if (diff > Math.PI) {
                        ang2 -= Math.PI * 2.0;
                    }
                    else if (diff < -Math.PI) {
                        ang2 += Math.PI * 2.0;
                    }
                    var bisect = (ang1 + ang2) / 2.0;
                    var theta = Math.abs(ang2 - bisect);
                    var dist = radius / Math.sin(theta);
                    var x = p2.getX() + dist * Math.cos(bisect);
                    var y = p2.getY() + dist * Math.sin(bisect);
                    if (ang1 < ang2) {
                        ang1 -= Math.PI / 2.0;
                        ang2 += Math.PI / 2.0;
                    }
                    else {
                        ang1 += Math.PI / 2.0;
                        ang2 -= Math.PI / 2.0;
                    }
                    ang1 = /* toDegrees */ (function (x) { return x * 180 / Math.PI; })(-ang1);
                    ang2 = /* toDegrees */ (function (x) { return x * 180 / Math.PI; })(-ang2);
                    diff = ang2 - ang1;
                    if (diff < 0) {
                        diff += 360;
                    }
                    else {
                        diff -= 360;
                    }
                    this.setArcByCenter(x, y, radius, ang1, diff, this.type);
                };
                Arc2D.prototype.setAngleStart$double = function (angSt) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
                Arc2D.prototype.setAngleStart$java_awt_geom_Point2D = function (p) {
                    var dx = this.getHeight() * (p.getX() - this.getCenterX());
                    var dy = this.getWidth() * (p.getY() - this.getCenterY());
                    this.setAngleStart$double(-(function (x) { return x * 180 / Math.PI; })(Math.atan2(dy, dx)));
                };
                /**
                 * Sets the starting angle of this arc to the angle that the
                 * specified point defines relative to the center of this arc.
                 * The angular extent of the arc will remain the same.
                 *
                 * @param {java.awt.geom.Point2D} p The <CODE>Point2D</CODE> that defines the starting angle.
                 * @see #getAngleStart
                 * @since 1.2
                 */
                Arc2D.prototype.setAngleStart = function (p) {
                    if (((p != null && p instanceof java.awt.geom.Point2D) || p === null)) {
                        return this.setAngleStart$java_awt_geom_Point2D(p);
                    }
                    else if (((typeof p === 'number') || p === null)) {
                        return this.setAngleStart$double(p);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Arc2D.prototype.setAngles$double$double$double$double = function (x1, y1, x2, y2) {
                    var x = this.getCenterX();
                    var y = this.getCenterY();
                    var w = this.getWidth();
                    var h = this.getHeight();
                    var ang1 = Math.atan2(w * (y - y1), h * (x1 - x));
                    var ang2 = Math.atan2(w * (y - y2), h * (x2 - x));
                    ang2 -= ang1;
                    if (ang2 <= 0.0) {
                        ang2 += Math.PI * 2.0;
                    }
                    this.setAngleStart$double(/* toDegrees */ (function (x) { return x * 180 / Math.PI; })(ang1));
                    this.setAngleExtent(/* toDegrees */ (function (x) { return x * 180 / Math.PI; })(ang2));
                };
                /**
                 * Sets the starting angle and angular extent of this arc using two
                 * sets of coordinates. The first set of coordinates is used to
                 * determine the angle of the starting point relative to the arc's
                 * center. The second set of coordinates is used to determine the
                 * angle of the end point relative to the arc's center.
                 * The arc will always be non-empty and extend counterclockwise
                 * from the first point around to the second point.
                 *
                 * @param {number} x1 The X coordinate of the arc's starting point.
                 * @param {number} y1 The Y coordinate of the arc's starting point.
                 * @param {number} x2 The X coordinate of the arc's ending point.
                 * @param {number} y2 The Y coordinate of the arc's ending point.
                 * @since 1.2
                 */
                Arc2D.prototype.setAngles = function (x1, y1, x2, y2) {
                    if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                        return this.setAngles$double$double$double$double(x1, y1, x2, y2);
                    }
                    else if (((x1 != null && x1 instanceof java.awt.geom.Point2D) || x1 === null) && ((y1 != null && y1 instanceof java.awt.geom.Point2D) || y1 === null) && x2 === undefined && y2 === undefined) {
                        return this.setAngles$java_awt_geom_Point2D$java_awt_geom_Point2D(x1, y1);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Arc2D.prototype.setAngles$java_awt_geom_Point2D$java_awt_geom_Point2D = function (p1, p2) {
                    this.setAngles$double$double$double$double(p1.getX(), p1.getY(), p2.getX(), p2.getY());
                };
                /**
                 * Sets the closure type of this arc to the specified value:
                 * <CODE>OPEN</CODE>, <CODE>CHORD</CODE>, or <CODE>PIE</CODE>.
                 *
                 * @param {number} type The integer constant that represents the closure
                 * type of this arc: {@link #OPEN}, {@link #CHORD}, or
                 * {@link #PIE}.
                 *
                 * @throws IllegalArgumentException if <code>type</code> is not
                 * 0, 1, or 2.+
                 * @see #getArcType
                 * @since 1.2
                 */
                Arc2D.prototype.setArcType = function (type) {
                    if (type < Arc2D.OPEN || type > Arc2D.PIE) {
                        throw Object.defineProperty(new Error("invalid type for Arc: " + type), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.Object', 'java.lang.RuntimeException', 'java.lang.IllegalArgumentException', 'java.lang.Exception'] });
                    }
                    this.type = type;
                };
                Arc2D.prototype.setFrame$double$double$double$double = function (x, y, w, h) {
                    this.setArc$double$double$double$double$double$double$int(x, y, w, h, this.getAngleStart(), this.getAngleExtent(), this.type);
                };
                /**
                 * {@inheritDoc}
                 * Note that the arc
                 * <a href="Arc2D.html#inscribes">partially inscribes</a>
                 * the framing rectangle of this {@code RectangularShape}.
                 *
                 * @since 1.2
                 * @param {number} x
                 * @param {number} y
                 * @param {number} w
                 * @param {number} h
                 */
                Arc2D.prototype.setFrame = function (x, y, w, h) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        return this.setFrame$double$double$double$double(x, y, w, h);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && ((y != null && y instanceof java.awt.geom.Dimension2D) || y === null) && w === undefined && h === undefined) {
                        return this.setFrame$java_awt_geom_Point2D$java_awt_geom_Dimension2D(x, y);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.setFrame$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns the high-precision framing rectangle of the arc.  The framing
                 * rectangle contains only the part of this <code>Arc2D</code> that is
                 * in between the starting and ending angles and contains the pie
                 * wedge, if this <code>Arc2D</code> has a <code>PIE</code> closure type.
                 * <p>
                 * This method differs from the
                 * {@link RectangularShape#getBounds() getBounds} in that the
                 * <code>getBounds</code> method only returns the bounds of the
                 * enclosing ellipse of this <code>Arc2D</code> without considering
                 * the starting and ending angles of this <code>Arc2D</code>.
                 *
                 * @return {java.awt.geom.Rectangle2D} the <CODE>Rectangle2D</CODE> that represents the arc's
                 * framing rectangle.
                 * @since 1.2
                 */
                Arc2D.prototype.getBounds2D = function () {
                    if (this.isEmpty()) {
                        return this.makeBounds(this.getX(), this.getY(), this.getWidth(), this.getHeight());
                    }
                    var x1;
                    var y1;
                    var x2;
                    var y2;
                    if (this.getArcType() === Arc2D.PIE) {
                        x1 = y1 = x2 = y2 = 0.0;
                    }
                    else {
                        x1 = y1 = 1.0;
                        x2 = y2 = -1.0;
                    }
                    var angle = 0.0;
                    for (var i = 0; i < 6; i++) {
                        {
                            if (i < 4) {
                                angle += 90.0;
                                if (!this.containsAngle(angle)) {
                                    continue;
                                }
                            }
                            else if (i === 4) {
                                angle = this.getAngleStart();
                            }
                            else {
                                angle += this.getAngleExtent();
                            }
                            var rads = (function (x) { return x * Math.PI / 180; })(-angle);
                            var xe = Math.cos(rads);
                            var ye = Math.sin(rads);
                            x1 = Math.min(x1, xe);
                            y1 = Math.min(y1, ye);
                            x2 = Math.max(x2, xe);
                            y2 = Math.max(y2, ye);
                        }
                        ;
                    }
                    var w = this.getWidth();
                    var h = this.getHeight();
                    x2 = (x2 - x1) * 0.5 * w;
                    y2 = (y2 - y1) * 0.5 * h;
                    x1 = this.getX() + (x1 * 0.5 + 0.5) * w;
                    y1 = this.getY() + (y1 * 0.5 + 0.5) * h;
                    return this.makeBounds(x1, y1, x2, y2);
                };
                Arc2D.normalizeDegrees = function (angle) {
                    if (angle > 180.0) {
                        if (angle <= (180.0 + 360.0)) {
                            angle = angle - 360.0;
                        }
                        else {
                            angle = /* IEEEremainder */ (function (f1, f2) { var r = Math.abs(f1 % f2); if (isNaN(r) || r == f2 || r <= Math.abs(f2) / 2.0) {
                                return r;
                            }
                            else {
                                return (f1 > 0 ? 1 : -1) * (r - f2);
                            } })(angle, 360.0);
                            if (angle === -180.0) {
                                angle = 180.0;
                            }
                        }
                    }
                    else if (angle <= -180.0) {
                        if (angle > (-180.0 - 360.0)) {
                            angle = angle + 360.0;
                        }
                        else {
                            angle = /* IEEEremainder */ (function (f1, f2) { var r = Math.abs(f1 % f2); if (isNaN(r) || r == f2 || r <= Math.abs(f2) / 2.0) {
                                return r;
                            }
                            else {
                                return (f1 > 0 ? 1 : -1) * (r - f2);
                            } })(angle, 360.0);
                            if (angle === -180.0) {
                                angle = 180.0;
                            }
                        }
                    }
                    return angle;
                };
                /**
                 * Determines whether or not the specified angle is within the
                 * angular extents of the arc.
                 *
                 * @param {number} angle The angle to test.
                 *
                 * @return {boolean} <CODE>true</CODE> if the arc contains the angle,
                 * <CODE>false</CODE> if the arc doesn't contain the angle.
                 * @since 1.2
                 */
                Arc2D.prototype.containsAngle = function (angle) {
                    var angExt = this.getAngleExtent();
                    var backwards = (angExt < 0.0);
                    if (backwards) {
                        angExt = -angExt;
                    }
                    if (angExt >= 360.0) {
                        return true;
                    }
                    angle = Arc2D.normalizeDegrees(angle) - Arc2D.normalizeDegrees(this.getAngleStart());
                    if (backwards) {
                        angle = -angle;
                    }
                    if (angle < 0.0) {
                        angle += 360.0;
                    }
                    return (angle >= 0.0) && (angle < angExt);
                };
                Arc2D.prototype.contains$double$double = function (x, y) {
                    var ellw = this.getWidth();
                    if (ellw <= 0.0) {
                        return false;
                    }
                    var normx = (x - this.getX()) / ellw - 0.5;
                    var ellh = this.getHeight();
                    if (ellh <= 0.0) {
                        return false;
                    }
                    var normy = (y - this.getY()) / ellh - 0.5;
                    var distSq = (normx * normx + normy * normy);
                    if (distSq >= 0.25) {
                        return false;
                    }
                    var angExt = Math.abs(this.getAngleExtent());
                    if (angExt >= 360.0) {
                        return true;
                    }
                    var inarc = this.containsAngle(-(function (x) { return x * 180 / Math.PI; })(Math.atan2(normy, normx)));
                    if (this.type === Arc2D.PIE) {
                        return inarc;
                    }
                    if (inarc) {
                        if (angExt >= 180.0) {
                            return true;
                        }
                    }
                    else {
                        if (angExt <= 180.0) {
                            return false;
                        }
                    }
                    var angle = (function (x) { return x * Math.PI / 180; })(-this.getAngleStart());
                    var x1 = Math.cos(angle);
                    var y1 = Math.sin(angle);
                    angle += /* toRadians */ (function (x) { return x * Math.PI / 180; })(-this.getAngleExtent());
                    var x2 = Math.cos(angle);
                    var y2 = Math.sin(angle);
                    var inside = (java.awt.geom.Line2D.relativeCCW(x1, y1, x2, y2, 2 * normx, 2 * normy) * java.awt.geom.Line2D.relativeCCW(x1, y1, x2, y2, 0, 0) >= 0);
                    return inarc ? !inside : inside;
                };
                Arc2D.prototype.intersects$double$double$double$double = function (x, y, w, h) {
                    var aw = this.getWidth();
                    var ah = this.getHeight();
                    if (w <= 0 || h <= 0 || aw <= 0 || ah <= 0) {
                        return false;
                    }
                    var ext = this.getAngleExtent();
                    if (ext === 0) {
                        return false;
                    }
                    var ax = this.getX();
                    var ay = this.getY();
                    var axw = ax + aw;
                    var ayh = ay + ah;
                    var xw = x + w;
                    var yh = y + h;
                    if (x >= axw || y >= ayh || xw <= ax || yh <= ay) {
                        return false;
                    }
                    var axc = this.getCenterX();
                    var ayc = this.getCenterY();
                    var sp = this.getStartPoint();
                    var ep = this.getEndPoint();
                    var sx = sp.getX();
                    var sy = sp.getY();
                    var ex = ep.getX();
                    var ey = ep.getY();
                    if (ayc >= y && ayc <= yh) {
                        if ((sx < xw && ex < xw && axc < xw && axw > x && this.containsAngle(0)) || (sx > x && ex > x && axc > x && ax < xw && this.containsAngle(180))) {
                            return true;
                        }
                    }
                    if (axc >= x && axc <= xw) {
                        if ((sy > y && ey > y && ayc > y && ay < yh && this.containsAngle(90)) || (sy < yh && ey < yh && ayc < yh && ayh > y && this.containsAngle(270))) {
                            return true;
                        }
                    }
                    var rect = new java.awt.geom.Rectangle2D.Double(x, y, w, h);
                    if (this.type === Arc2D.PIE || Math.abs(ext) > 180) {
                        if (rect.intersectsLine$double$double$double$double(axc, ayc, sx, sy) || rect.intersectsLine$double$double$double$double(axc, ayc, ex, ey)) {
                            return true;
                        }
                    }
                    else {
                        if (rect.intersectsLine$double$double$double$double(sx, sy, ex, ey)) {
                            return true;
                        }
                    }
                    if (this.contains$double$double(x, y) || this.contains$double$double(x + w, y) || this.contains$double$double(x, y + h) || this.contains$double$double(x + w, y + h)) {
                        return true;
                    }
                    return false;
                };
                /**
                 * Determines whether or not the interior of the arc intersects
                 * the interior of the specified rectangle.
                 *
                 * @param {number} x The X coordinate of the rectangle's upper-left corner.
                 * @param {number} y The Y coordinate of the rectangle's upper-left corner.
                 * @param {number} w The width of the rectangle.
                 * @param {number} h The height of the rectangle.
                 *
                 * @return {boolean} <CODE>true</CODE> if the arc intersects the rectangle,
                 * <CODE>false</CODE> if the arc doesn't intersect the rectangle.
                 * @since 1.2
                 */
                Arc2D.prototype.intersects = function (x, y, w, h) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        return this.intersects$double$double$double$double(x, y, w, h);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.intersects$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Arc2D.prototype.contains$double$double$double$double = function (x, y, w, h) {
                    return this.contains$double$double$double$double$java_awt_geom_Rectangle2D(x, y, w, h, null);
                };
                Arc2D.prototype.contains$java_awt_geom_Rectangle2D = function (r) {
                    return this.contains$double$double$double$double$java_awt_geom_Rectangle2D(r.getX(), r.getY(), r.getWidth(), r.getHeight(), r);
                };
                Arc2D.prototype.contains$double$double$double$double$java_awt_geom_Rectangle2D = function (x, y, w, h, origrect) {
                    if (!(this.contains$double$double(x, y) && this.contains$double$double(x + w, y) && this.contains$double$double(x, y + h) && this.contains$double$double(x + w, y + h))) {
                        return false;
                    }
                    if (this.type !== Arc2D.PIE || Math.abs(this.getAngleExtent()) <= 180.0) {
                        return true;
                    }
                    if (origrect == null) {
                        origrect = new java.awt.geom.Rectangle2D.Double(x, y, w, h);
                    }
                    var halfW = this.getWidth() / 2.0;
                    var halfH = this.getHeight() / 2.0;
                    var xc = this.getX() + halfW;
                    var yc = this.getY() + halfH;
                    var angle = (function (x) { return x * Math.PI / 180; })(-this.getAngleStart());
                    var xe = xc + halfW * Math.cos(angle);
                    var ye = yc + halfH * Math.sin(angle);
                    if (origrect.intersectsLine$double$double$double$double(xc, yc, xe, ye)) {
                        return false;
                    }
                    angle += /* toRadians */ (function (x) { return x * Math.PI / 180; })(-this.getAngleExtent());
                    xe = xc + halfW * Math.cos(angle);
                    ye = yc + halfH * Math.sin(angle);
                    return !origrect.intersectsLine$double$double$double$double(xc, yc, xe, ye);
                };
                Arc2D.prototype.contains = function (x, y, w, h, origrect) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((origrect != null && origrect instanceof java.awt.geom.Rectangle2D) || origrect === null)) {
                        return this.contains$double$double$double$double$java_awt_geom_Rectangle2D(x, y, w, h, origrect);
                    }
                    else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && origrect === undefined) {
                        return this.contains$double$double$double$double(x, y, w, h);
                    }
                    else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && w === undefined && h === undefined && origrect === undefined) {
                        return this.contains$double$double(x, y);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined && origrect === undefined) {
                        return this.contains$java_awt_geom_Rectangle2D(x);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && y === undefined && w === undefined && h === undefined && origrect === undefined) {
                        return this.contains$java_awt_geom_Point2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Arc2D.prototype.getPathIterator = function (at, flatness) {
                    if (((at != null && at instanceof java.awt.geom.AffineTransform) || at === null) && ((typeof flatness === 'number') || flatness === null)) {
                        return _super.prototype.getPathIterator.call(this, at, flatness);
                    }
                    else if (((at != null && at instanceof java.awt.geom.AffineTransform) || at === null) && flatness === undefined) {
                        return this.getPathIterator$java_awt_geom_AffineTransform(at);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Arc2D.prototype.getPathIterator$java_awt_geom_AffineTransform = function (at) {
                    return new java.awt.geom.ArcIterator(this, at);
                };
                /**
                 * Determines whether or not the specified <code>Object</code> is
                 * equal to this <code>Arc2D</code>.  The specified
                 * <code>Object</code> is equal to this <code>Arc2D</code>
                 * if it is an instance of <code>Arc2D</code> and if its
                 * location, size, arc extents and type are the same as this
                 * <code>Arc2D</code>.
                 * @param {*} obj  an <code>Object</code> to be compared with this
                 * <code>Arc2D</code>.
                 * @return  {boolean} <code>true</code> if <code>obj</code> is an instance
                 * of <code>Arc2D</code> and has the same values;
                 * <code>false</code> otherwise.
                 * @since 1.6
                 */
                Arc2D.prototype.equals = function (obj) {
                    if (obj === this) {
                        return true;
                    }
                    if (obj != null && obj instanceof java.awt.geom.Arc2D) {
                        var a2d = obj;
                        return ((this.getX() === a2d.getX()) && (this.getY() === a2d.getY()) && (this.getWidth() === a2d.getWidth()) && (this.getHeight() === a2d.getHeight()) && (this.getAngleStart() === a2d.getAngleStart()) && (this.getAngleExtent() === a2d.getAngleExtent()) && (this.getArcType() === a2d.getArcType()));
                    }
                    return false;
                };
                /**
                 * The closure type for an open arc with no path segments
                 * connecting the two ends of the arc segment.
                 * @since 1.2
                 */
                Arc2D.OPEN = 0;
                /**
                 * The closure type for an arc closed by drawing a straight
                 * line segment from the start of the arc segment to the end of the
                 * arc segment.
                 * @since 1.2
                 */
                Arc2D.CHORD = 1;
                /**
                 * The closure type for an arc closed by drawing straight line
                 * segments from the start of the arc segment to the center
                 * of the full ellipse and from that point to the end of the arc segment.
                 * @since 1.2
                 */
                Arc2D.PIE = 2;
                return Arc2D;
            }(java.awt.geom.RectangularShape));
            geom.Arc2D = Arc2D;
            Arc2D["__class"] = "java.awt.geom.Arc2D";
            Arc2D["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable"];
            (function (Arc2D) {
                /**
                 * Constructs a new arc, initialized to the specified location,
                 * size, angular extents, and closure type.
                 *
                 * @param {number} x The X coordinate of the upper-left corner of
                 * the arc's framing rectangle.
                 * @param {number} y The Y coordinate of the upper-left corner of
                 * the arc's framing rectangle.
                 * @param {number} w The overall width of the full ellipse of which
                 * this arc is a partial section.
                 * @param {number} h The overall height of the full ellipse of which this
                 * arc is a partial section.
                 * @param {number} start The starting angle of the arc in degrees.
                 * @param {number} extent The angular extent of the arc in degrees.
                 * @param {number} type The closure type for the arc:
                 * {@link #OPEN}, {@link #CHORD}, or {@link #PIE}.
                 * @since 1.2
                 * @class
                 * @extends java.awt.geom.Arc2D
                 */
                var Float = /** @class */ (function (_super) {
                    __extends(Float, _super);
                    function Float(x, y, w, h, start, extent, type) {
                        var _this = this;
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((typeof start === 'number') || start === null) && ((typeof extent === 'number') || extent === null) && ((typeof type === 'number') || type === null)) {
                            var __args = arguments;
                            _this = _super.call(this, type) || this;
                            if (_this.x === undefined)
                                _this.x = 0;
                            if (_this.y === undefined)
                                _this.y = 0;
                            if (_this.width === undefined)
                                _this.width = 0;
                            if (_this.height === undefined)
                                _this.height = 0;
                            if (_this.start === undefined)
                                _this.start = 0;
                            if (_this.extent === undefined)
                                _this.extent = 0;
                            if (_this.x === undefined)
                                _this.x = 0;
                            if (_this.y === undefined)
                                _this.y = 0;
                            if (_this.width === undefined)
                                _this.width = 0;
                            if (_this.height === undefined)
                                _this.height = 0;
                            if (_this.start === undefined)
                                _this.start = 0;
                            if (_this.extent === undefined)
                                _this.extent = 0;
                            (function () {
                                _this.x = x;
                                _this.y = y;
                                _this.width = w;
                                _this.height = h;
                                _this.start = start;
                                _this.extent = extent;
                            })();
                        }
                        else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && start === undefined && extent === undefined && type === undefined) {
                            var __args = arguments;
                            var ellipseBounds_1 = __args[0];
                            var start_1 = __args[1];
                            var extent_1 = __args[2];
                            var type_2 = __args[3];
                            _this = _super.call(this, type_2) || this;
                            if (_this.x === undefined)
                                _this.x = 0;
                            if (_this.y === undefined)
                                _this.y = 0;
                            if (_this.width === undefined)
                                _this.width = 0;
                            if (_this.height === undefined)
                                _this.height = 0;
                            if (_this.start === undefined)
                                _this.start = 0;
                            if (_this.extent === undefined)
                                _this.extent = 0;
                            if (_this.x === undefined)
                                _this.x = 0;
                            if (_this.y === undefined)
                                _this.y = 0;
                            if (_this.width === undefined)
                                _this.width = 0;
                            if (_this.height === undefined)
                                _this.height = 0;
                            if (_this.start === undefined)
                                _this.start = 0;
                            if (_this.extent === undefined)
                                _this.extent = 0;
                            (function () {
                                _this.x = ellipseBounds_1.getX();
                                _this.y = ellipseBounds_1.getY();
                                _this.width = ellipseBounds_1.getWidth();
                                _this.height = ellipseBounds_1.getHeight();
                                _this.start = start_1;
                                _this.extent = extent_1;
                            })();
                        }
                        else if (((typeof x === 'number') || x === null) && y === undefined && w === undefined && h === undefined && start === undefined && extent === undefined && type === undefined) {
                            var __args = arguments;
                            var type_3 = __args[0];
                            _this = _super.call(this, type_3) || this;
                            if (_this.x === undefined)
                                _this.x = 0;
                            if (_this.y === undefined)
                                _this.y = 0;
                            if (_this.width === undefined)
                                _this.width = 0;
                            if (_this.height === undefined)
                                _this.height = 0;
                            if (_this.start === undefined)
                                _this.start = 0;
                            if (_this.extent === undefined)
                                _this.extent = 0;
                            if (_this.x === undefined)
                                _this.x = 0;
                            if (_this.y === undefined)
                                _this.y = 0;
                            if (_this.width === undefined)
                                _this.width = 0;
                            if (_this.height === undefined)
                                _this.height = 0;
                            if (_this.start === undefined)
                                _this.start = 0;
                            if (_this.extent === undefined)
                                _this.extent = 0;
                        }
                        else if (x === undefined && y === undefined && w === undefined && h === undefined && start === undefined && extent === undefined && type === undefined) {
                            var __args = arguments;
                            _this = _super.call(this, java.awt.geom.Arc2D.OPEN) || this;
                            if (_this.x === undefined)
                                _this.x = 0;
                            if (_this.y === undefined)
                                _this.y = 0;
                            if (_this.width === undefined)
                                _this.width = 0;
                            if (_this.height === undefined)
                                _this.height = 0;
                            if (_this.start === undefined)
                                _this.start = 0;
                            if (_this.extent === undefined)
                                _this.extent = 0;
                            if (_this.x === undefined)
                                _this.x = 0;
                            if (_this.y === undefined)
                                _this.y = 0;
                            if (_this.width === undefined)
                                _this.width = 0;
                            if (_this.height === undefined)
                                _this.height = 0;
                            if (_this.start === undefined)
                                _this.start = 0;
                            if (_this.extent === undefined)
                                _this.extent = 0;
                        }
                        else
                            throw new Error('invalid overload');
                        return _this;
                    }
                    /**
                     * {@inheritDoc}
                     * Note that the arc
                     * <a href="Arc2D.html#inscribes">partially inscribes</a>
                     * the framing rectangle of this {@code RectangularShape}.
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Float.prototype.getX = function () {
                        return this.x;
                    };
                    /**
                     * {@inheritDoc}
                     * Note that the arc
                     * <a href="Arc2D.html#inscribes">partially inscribes</a>
                     * the framing rectangle of this {@code RectangularShape}.
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Float.prototype.getY = function () {
                        return this.y;
                    };
                    /**
                     * {@inheritDoc}
                     * Note that the arc
                     * <a href="Arc2D.html#inscribes">partially inscribes</a>
                     * the framing rectangle of this {@code RectangularShape}.
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Float.prototype.getWidth = function () {
                        return this.width;
                    };
                    /**
                     * {@inheritDoc}
                     * Note that the arc
                     * <a href="Arc2D.html#inscribes">partially inscribes</a>
                     * the framing rectangle of this {@code RectangularShape}.
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Float.prototype.getHeight = function () {
                        return this.height;
                    };
                    /**
                     * {@inheritDoc}
                     * @since 1.2
                     * @return {number}
                     */
                    Float.prototype.getAngleStart = function () {
                        return this.start;
                    };
                    /**
                     * {@inheritDoc}
                     * @since 1.2
                     * @return {number}
                     */
                    Float.prototype.getAngleExtent = function () {
                        return this.extent;
                    };
                    /**
                     * {@inheritDoc}
                     * @since 1.2
                     * @return {boolean}
                     */
                    Float.prototype.isEmpty = function () {
                        return (this.width <= 0.0 || this.height <= 0.0);
                    };
                    Float.prototype.setArc$double$double$double$double$double$double$int = function (x, y, w, h, angSt, angExt, closure) {
                        this.setArcType(closure);
                        this.x = x;
                        this.y = y;
                        this.width = w;
                        this.height = h;
                        this.start = angSt;
                        this.extent = angExt;
                    };
                    /**
                     * {@inheritDoc}
                     * @since 1.2
                     * @param {number} x
                     * @param {number} y
                     * @param {number} w
                     * @param {number} h
                     * @param {number} angSt
                     * @param {number} angExt
                     * @param {number} closure
                     */
                    Float.prototype.setArc = function (x, y, w, h, angSt, angExt, closure) {
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((typeof angSt === 'number') || angSt === null) && ((typeof angExt === 'number') || angExt === null) && ((typeof closure === 'number') || closure === null)) {
                            return this.setArc$double$double$double$double$double$double$int(x, y, w, h, angSt, angExt, closure);
                        }
                        else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && ((y != null && y instanceof java.awt.geom.Dimension2D) || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((typeof angSt === 'number') || angSt === null) && angExt === undefined && closure === undefined) {
                            return this.setArc$java_awt_geom_Point2D$java_awt_geom_Dimension2D$double$double$int(x, y, w, h, angSt);
                        }
                        else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && angSt === undefined && angExt === undefined && closure === undefined) {
                            return this.setArc$java_awt_geom_Rectangle2D$double$double$int(x, y, w, h);
                        }
                        else if (((x != null && x instanceof java.awt.geom.Arc2D) || x === null) && y === undefined && w === undefined && h === undefined && angSt === undefined && angExt === undefined && closure === undefined) {
                            return this.setArc$java_awt_geom_Arc2D(x);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * Sets the starting angle of this arc to the angle that the
                     * specified point defines relative to the center of this arc.
                     * The angular extent of the arc will remain the same.
                     *
                     * @param {java.awt.geom.Point2D} p The <CODE>Point2D</CODE> that defines the starting angle.
                     * @see #getAngleStart
                     * @since 1.2
                     */
                    Float.prototype.setAngleStart = function (p) {
                        if (((p != null && p instanceof java.awt.geom.Point2D) || p === null)) {
                            _super.prototype.setAngleStart.call(this, p);
                        }
                        else if (((typeof p === 'number') || p === null)) {
                            return this.setAngleStart$double(p);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    Float.prototype.setAngleStart$double = function (angSt) {
                        this.start = angSt;
                    };
                    /**
                     * {@inheritDoc}
                     * @since 1.2
                     * @param {number} angExt
                     */
                    Float.prototype.setAngleExtent = function (angExt) {
                        this.extent = angExt;
                    };
                    /**
                     * {@inheritDoc}
                     * @since 1.2
                     * @param {number} x
                     * @param {number} y
                     * @param {number} w
                     * @param {number} h
                     * @return {java.awt.geom.Rectangle2D}
                     */
                    Float.prototype.makeBounds = function (x, y, w, h) {
                        return new java.awt.geom.Rectangle2D.Float(x, y, w, h);
                    };
                    Float.serialVersionUID = 9130893014586380278;
                    return Float;
                }(java.awt.geom.Arc2D));
                Arc2D.Float = Float;
                Float["__class"] = "java.awt.geom.Arc2D.Float";
                Float["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"];
                /**
                 * Constructs a new arc, initialized to the specified location,
                 * size, angular extents, and closure type.
                 *
                 * @param {number} x The X coordinate of the upper-left corner
                 * of the arc's framing rectangle.
                 * @param {number} y The Y coordinate of the upper-left corner
                 * of the arc's framing rectangle.
                 * @param {number} w The overall width of the full ellipse of which this
                 * arc is a partial section.
                 * @param {number} h The overall height of the full ellipse of which this
                 * arc is a partial section.
                 * @param {number} start The starting angle of the arc in degrees.
                 * @param {number} extent The angular extent of the arc in degrees.
                 * @param {number} type The closure type for the arc:
                 * {@link #OPEN}, {@link #CHORD}, or {@link #PIE}.
                 * @since 1.2
                 * @class
                 * @extends java.awt.geom.Arc2D
                 */
                var Double = /** @class */ (function (_super) {
                    __extends(Double, _super);
                    function Double(x, y, w, h, start, extent, type) {
                        var _this = this;
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((typeof start === 'number') || start === null) && ((typeof extent === 'number') || extent === null) && ((typeof type === 'number') || type === null)) {
                            var __args = arguments;
                            _this = _super.call(this, type) || this;
                            if (_this.x === undefined)
                                _this.x = 0;
                            if (_this.y === undefined)
                                _this.y = 0;
                            if (_this.width === undefined)
                                _this.width = 0;
                            if (_this.height === undefined)
                                _this.height = 0;
                            if (_this.start === undefined)
                                _this.start = 0;
                            if (_this.extent === undefined)
                                _this.extent = 0;
                            if (_this.x === undefined)
                                _this.x = 0;
                            if (_this.y === undefined)
                                _this.y = 0;
                            if (_this.width === undefined)
                                _this.width = 0;
                            if (_this.height === undefined)
                                _this.height = 0;
                            if (_this.start === undefined)
                                _this.start = 0;
                            if (_this.extent === undefined)
                                _this.extent = 0;
                            (function () {
                                _this.x = x;
                                _this.y = y;
                                _this.width = w;
                                _this.height = h;
                                _this.start = start;
                                _this.extent = extent;
                            })();
                        }
                        else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && start === undefined && extent === undefined && type === undefined) {
                            var __args = arguments;
                            var ellipseBounds_2 = __args[0];
                            var start_2 = __args[1];
                            var extent_2 = __args[2];
                            var type_4 = __args[3];
                            _this = _super.call(this, type_4) || this;
                            if (_this.x === undefined)
                                _this.x = 0;
                            if (_this.y === undefined)
                                _this.y = 0;
                            if (_this.width === undefined)
                                _this.width = 0;
                            if (_this.height === undefined)
                                _this.height = 0;
                            if (_this.start === undefined)
                                _this.start = 0;
                            if (_this.extent === undefined)
                                _this.extent = 0;
                            if (_this.x === undefined)
                                _this.x = 0;
                            if (_this.y === undefined)
                                _this.y = 0;
                            if (_this.width === undefined)
                                _this.width = 0;
                            if (_this.height === undefined)
                                _this.height = 0;
                            if (_this.start === undefined)
                                _this.start = 0;
                            if (_this.extent === undefined)
                                _this.extent = 0;
                            (function () {
                                _this.x = ellipseBounds_2.getX();
                                _this.y = ellipseBounds_2.getY();
                                _this.width = ellipseBounds_2.getWidth();
                                _this.height = ellipseBounds_2.getHeight();
                                _this.start = start_2;
                                _this.extent = extent_2;
                            })();
                        }
                        else if (((typeof x === 'number') || x === null) && y === undefined && w === undefined && h === undefined && start === undefined && extent === undefined && type === undefined) {
                            var __args = arguments;
                            var type_5 = __args[0];
                            _this = _super.call(this, type_5) || this;
                            if (_this.x === undefined)
                                _this.x = 0;
                            if (_this.y === undefined)
                                _this.y = 0;
                            if (_this.width === undefined)
                                _this.width = 0;
                            if (_this.height === undefined)
                                _this.height = 0;
                            if (_this.start === undefined)
                                _this.start = 0;
                            if (_this.extent === undefined)
                                _this.extent = 0;
                            if (_this.x === undefined)
                                _this.x = 0;
                            if (_this.y === undefined)
                                _this.y = 0;
                            if (_this.width === undefined)
                                _this.width = 0;
                            if (_this.height === undefined)
                                _this.height = 0;
                            if (_this.start === undefined)
                                _this.start = 0;
                            if (_this.extent === undefined)
                                _this.extent = 0;
                        }
                        else if (x === undefined && y === undefined && w === undefined && h === undefined && start === undefined && extent === undefined && type === undefined) {
                            var __args = arguments;
                            _this = _super.call(this, java.awt.geom.Arc2D.OPEN) || this;
                            if (_this.x === undefined)
                                _this.x = 0;
                            if (_this.y === undefined)
                                _this.y = 0;
                            if (_this.width === undefined)
                                _this.width = 0;
                            if (_this.height === undefined)
                                _this.height = 0;
                            if (_this.start === undefined)
                                _this.start = 0;
                            if (_this.extent === undefined)
                                _this.extent = 0;
                            if (_this.x === undefined)
                                _this.x = 0;
                            if (_this.y === undefined)
                                _this.y = 0;
                            if (_this.width === undefined)
                                _this.width = 0;
                            if (_this.height === undefined)
                                _this.height = 0;
                            if (_this.start === undefined)
                                _this.start = 0;
                            if (_this.extent === undefined)
                                _this.extent = 0;
                        }
                        else
                            throw new Error('invalid overload');
                        return _this;
                    }
                    /**
                     * {@inheritDoc}
                     * Note that the arc
                     * <a href="Arc2D.html#inscribes">partially inscribes</a>
                     * the framing rectangle of this {@code RectangularShape}.
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Double.prototype.getX = function () {
                        return this.x;
                    };
                    /**
                     * {@inheritDoc}
                     * Note that the arc
                     * <a href="Arc2D.html#inscribes">partially inscribes</a>
                     * the framing rectangle of this {@code RectangularShape}.
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Double.prototype.getY = function () {
                        return this.y;
                    };
                    /**
                     * {@inheritDoc}
                     * Note that the arc
                     * <a href="Arc2D.html#inscribes">partially inscribes</a>
                     * the framing rectangle of this {@code RectangularShape}.
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Double.prototype.getWidth = function () {
                        return this.width;
                    };
                    /**
                     * {@inheritDoc}
                     * Note that the arc
                     * <a href="Arc2D.html#inscribes">partially inscribes</a>
                     * the framing rectangle of this {@code RectangularShape}.
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Double.prototype.getHeight = function () {
                        return this.height;
                    };
                    /**
                     * {@inheritDoc}
                     * @since 1.2
                     * @return {number}
                     */
                    Double.prototype.getAngleStart = function () {
                        return this.start;
                    };
                    /**
                     * {@inheritDoc}
                     * @since 1.2
                     * @return {number}
                     */
                    Double.prototype.getAngleExtent = function () {
                        return this.extent;
                    };
                    /**
                     * {@inheritDoc}
                     * @since 1.2
                     * @return {boolean}
                     */
                    Double.prototype.isEmpty = function () {
                        return (this.width <= 0.0 || this.height <= 0.0);
                    };
                    Double.prototype.setArc$double$double$double$double$double$double$int = function (x, y, w, h, angSt, angExt, closure) {
                        this.setArcType(closure);
                        this.x = x;
                        this.y = y;
                        this.width = w;
                        this.height = h;
                        this.start = angSt;
                        this.extent = angExt;
                    };
                    /**
                     * {@inheritDoc}
                     * @since 1.2
                     * @param {number} x
                     * @param {number} y
                     * @param {number} w
                     * @param {number} h
                     * @param {number} angSt
                     * @param {number} angExt
                     * @param {number} closure
                     */
                    Double.prototype.setArc = function (x, y, w, h, angSt, angExt, closure) {
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((typeof angSt === 'number') || angSt === null) && ((typeof angExt === 'number') || angExt === null) && ((typeof closure === 'number') || closure === null)) {
                            return this.setArc$double$double$double$double$double$double$int(x, y, w, h, angSt, angExt, closure);
                        }
                        else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && ((y != null && y instanceof java.awt.geom.Dimension2D) || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && ((typeof angSt === 'number') || angSt === null) && angExt === undefined && closure === undefined) {
                            return this.setArc$java_awt_geom_Point2D$java_awt_geom_Dimension2D$double$double$int(x, y, w, h, angSt);
                        }
                        else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null) && angSt === undefined && angExt === undefined && closure === undefined) {
                            return this.setArc$java_awt_geom_Rectangle2D$double$double$int(x, y, w, h);
                        }
                        else if (((x != null && x instanceof java.awt.geom.Arc2D) || x === null) && y === undefined && w === undefined && h === undefined && angSt === undefined && angExt === undefined && closure === undefined) {
                            return this.setArc$java_awt_geom_Arc2D(x);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * Sets the starting angle of this arc to the angle that the
                     * specified point defines relative to the center of this arc.
                     * The angular extent of the arc will remain the same.
                     *
                     * @param {java.awt.geom.Point2D} p The <CODE>Point2D</CODE> that defines the starting angle.
                     * @see #getAngleStart
                     * @since 1.2
                     */
                    Double.prototype.setAngleStart = function (p) {
                        if (((p != null && p instanceof java.awt.geom.Point2D) || p === null)) {
                            _super.prototype.setAngleStart.call(this, p);
                        }
                        else if (((typeof p === 'number') || p === null)) {
                            return this.setAngleStart$double(p);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    Double.prototype.setAngleStart$double = function (angSt) {
                        this.start = angSt;
                    };
                    /**
                     * {@inheritDoc}
                     * @since 1.2
                     * @param {number} angExt
                     */
                    Double.prototype.setAngleExtent = function (angExt) {
                        this.extent = angExt;
                    };
                    /**
                     * {@inheritDoc}
                     * @since 1.2
                     * @param {number} x
                     * @param {number} y
                     * @param {number} w
                     * @param {number} h
                     * @return {java.awt.geom.Rectangle2D}
                     */
                    Double.prototype.makeBounds = function (x, y, w, h) {
                        return new java.awt.geom.Rectangle2D.Double(x, y, w, h);
                    };
                    Double.serialVersionUID = 728264085846882001;
                    return Double;
                }(java.awt.geom.Arc2D));
                Arc2D.Double = Double;
                Double["__class"] = "java.awt.geom.Arc2D.Double";
                Double["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"];
            })(Arc2D = geom.Arc2D || (geom.Arc2D = {}));
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * The <code>Rectangle2D</code> class describes a rectangle defined by a
             * location {@code (x,y)} and dimension {@code (w x h)}.
             * <p>
             * This class is only the abstract superclass for all objects that store a 2D
             * rectangle. The actual storage representation of the coordinates is left to
             * the subclass.
             *
             * @author Jim Graham
             * @since 1.2
             * @extends java.awt.geom.RectangularShape
             * @class
             */
            var Rectangle2D = /** @class */ (function (_super) {
                __extends(Rectangle2D, _super);
                function Rectangle2D() {
                    return _super.call(this) || this;
                }
                Rectangle2D.prototype.setRect$double$double$double$double = function (x, y, w, h) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
                /**
                 * Sets the location and size of this <code>Rectangle2D</code> to the
                 * specified <code>double</code> values.
                 *
                 * @param {number} x
                 * the X coordinate of the upper-left corner of this
                 * <code>Rectangle2D</code>
                 * @param {number} y
                 * the Y coordinate of the upper-left corner of this
                 * <code>Rectangle2D</code>
                 * @param {number} w
                 * the width of this <code>Rectangle2D</code>
                 * @param {number} h
                 * the height of this <code>Rectangle2D</code>
                 * @since 1.2
                 */
                Rectangle2D.prototype.setRect = function (x, y, w, h) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        return this.setRect$double$double$double$double(x, y, w, h);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.setRect$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Rectangle2D.prototype.setRect$java_awt_geom_Rectangle2D = function (r) {
                    this.setRect$double$double$double$double(r.getX(), r.getY(), r.getWidth(), r.getHeight());
                };
                Rectangle2D.prototype.intersectsLine$double$double$double$double = function (x1, y1, x2, y2) {
                    var out1;
                    var out2;
                    if ((out2 = this.outcode$double$double(x2, y2)) === 0) {
                        return true;
                    }
                    while (((out1 = this.outcode$double$double(x1, y1)) !== 0)) {
                        {
                            if ((out1 & out2) !== 0) {
                                return false;
                            }
                            if ((out1 & (Rectangle2D.OUT_LEFT | Rectangle2D.OUT_RIGHT)) !== 0) {
                                var x = this.getX();
                                if ((out1 & Rectangle2D.OUT_RIGHT) !== 0) {
                                    x += this.getWidth();
                                }
                                y1 = y1 + (x - x1) * (y2 - y1) / (x2 - x1);
                                x1 = x;
                            }
                            else {
                                var y = this.getY();
                                if ((out1 & Rectangle2D.OUT_BOTTOM) !== 0) {
                                    y += this.getHeight();
                                }
                                x1 = x1 + (y - y1) * (x2 - x1) / (y2 - y1);
                                y1 = y;
                            }
                        }
                    }
                    ;
                    return true;
                };
                /**
                 * Tests if the specified line segment intersects the interior of this
                 * <code>Rectangle2D</code>.
                 *
                 * @param {number} x1
                 * the X coordinate of the start point of the specified line
                 * segment
                 * @param {number} y1
                 * the Y coordinate of the start point of the specified line
                 * segment
                 * @param {number} x2
                 * the X coordinate of the end point of the specified line
                 * segment
                 * @param {number} y2
                 * the Y coordinate of the end point of the specified line
                 * segment
                 * @return {boolean} <code>true</code> if the specified line segment intersects the
                 * interior of this <code>Rectangle2D</code>; <code>false</code>
                 * otherwise.
                 * @since 1.2
                 */
                Rectangle2D.prototype.intersectsLine = function (x1, y1, x2, y2) {
                    if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null)) {
                        return this.intersectsLine$double$double$double$double(x1, y1, x2, y2);
                    }
                    else if (((x1 != null && x1 instanceof java.awt.geom.Line2D) || x1 === null) && y1 === undefined && x2 === undefined && y2 === undefined) {
                        return this.intersectsLine$java_awt_geom_Line2D(x1);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Rectangle2D.prototype.intersectsLine$java_awt_geom_Line2D = function (l) {
                    return this.intersectsLine$double$double$double$double(l.getX1(), l.getY1(), l.getX2(), l.getY2());
                };
                Rectangle2D.prototype.outcode$double$double = function (x, y) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
                /**
                 * Determines where the specified coordinates lie with respect to this
                 * <code>Rectangle2D</code>. This method computes a binary OR of the
                 * appropriate mask values indicating, for each side of this
                 * <code>Rectangle2D</code>, whether or not the specified coordinates are on
                 * the same side of the edge as the rest of this <code>Rectangle2D</code>.
                 *
                 * @param {number} x
                 * the specified X coordinate
                 * @param {number} y
                 * the specified Y coordinate
                 * @return {number} the logical OR of all appropriate out codes.
                 * @see #OUT_LEFT
                 * @see #OUT_TOP
                 * @see #OUT_RIGHT
                 * @see #OUT_BOTTOM
                 * @since 1.2
                 */
                Rectangle2D.prototype.outcode = function (x, y) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.outcode$double$double(x, y);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && y === undefined) {
                        return this.outcode$java_awt_geom_Point2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Rectangle2D.prototype.outcode$java_awt_geom_Point2D = function (p) {
                    return this.outcode$double$double(p.getX(), p.getY());
                };
                Rectangle2D.prototype.setFrame$double$double$double$double = function (x, y, w, h) {
                    this.setRect$double$double$double$double(x, y, w, h);
                };
                /**
                 * Sets the location and size of the outer bounds of this
                 * <code>Rectangle2D</code> to the specified rectangular values.
                 *
                 * @param {number} x
                 * the X coordinate of the upper-left corner of this
                 * <code>Rectangle2D</code>
                 * @param {number} y
                 * the Y coordinate of the upper-left corner of this
                 * <code>Rectangle2D</code>
                 * @param {number} w
                 * the width of this <code>Rectangle2D</code>
                 * @param {number} h
                 * the height of this <code>Rectangle2D</code>
                 * @since 1.2
                 */
                Rectangle2D.prototype.setFrame = function (x, y, w, h) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        return this.setFrame$double$double$double$double(x, y, w, h);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && ((y != null && y instanceof java.awt.geom.Dimension2D) || y === null) && w === undefined && h === undefined) {
                        return this.setFrame$java_awt_geom_Point2D$java_awt_geom_Dimension2D(x, y);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.setFrame$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 * @return {java.awt.geom.Rectangle2D}
                 */
                Rectangle2D.prototype.getBounds2D = function () {
                    return (function (o) { if (o.clone != undefined) {
                        return o.clone();
                    }
                    else {
                        var clone = Object.create(o);
                        for (var p in o) {
                            if (o.hasOwnProperty(p))
                                clone[p] = o[p];
                        }
                        return clone;
                    } })(this);
                };
                Rectangle2D.prototype.contains$double$double = function (x, y) {
                    var x0 = this.getX();
                    var y0 = this.getY();
                    return (x >= x0 && y >= y0 && x < x0 + this.getWidth() && y < y0 + this.getHeight());
                };
                Rectangle2D.prototype.intersects$double$double$double$double = function (x, y, w, h) {
                    if (this.isEmpty() || w <= 0 || h <= 0) {
                        return false;
                    }
                    var x0 = this.getX();
                    var y0 = this.getY();
                    return (x + w > x0 && y + h > y0 && x < x0 + this.getWidth() && y < y0 + this.getHeight());
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 * @param {number} x
                 * @param {number} y
                 * @param {number} w
                 * @param {number} h
                 * @return {boolean}
                 */
                Rectangle2D.prototype.intersects = function (x, y, w, h) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        return this.intersects$double$double$double$double(x, y, w, h);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.intersects$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Rectangle2D.prototype.contains$double$double$double$double = function (x, y, w, h) {
                    if (this.isEmpty() || w <= 0 || h <= 0) {
                        return false;
                    }
                    var x0 = this.getX();
                    var y0 = this.getY();
                    return (x >= x0 && y >= y0 && (x + w) <= x0 + this.getWidth() && (y + h) <= y0 + this.getHeight());
                };
                /**
                 * {@inheritDoc}
                 *
                 * @since 1.2
                 * @param {number} x
                 * @param {number} y
                 * @param {number} w
                 * @param {number} h
                 * @return {boolean}
                 */
                Rectangle2D.prototype.contains = function (x, y, w, h) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                        return this.contains$double$double$double$double(x, y, w, h);
                    }
                    else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && w === undefined && h === undefined) {
                        return this.contains$double$double(x, y);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.contains$java_awt_geom_Point2D(x);
                    }
                    else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                        return this.contains$java_awt_geom_Rectangle2D(x);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Intersects the pair of specified source <code>Rectangle2D</code> objects
                 * and puts the result into the specified destination
                 * <code>Rectangle2D</code> object. One of the source rectangles can also be
                 * the destination to avoid creating a third Rectangle2D object, but in this
                 * case the original points of this source rectangle will be overwritten by
                 * this method.
                 *
                 * @param {java.awt.geom.Rectangle2D} src1
                 * the first of a pair of <code>Rectangle2D</code> objects to be
                 * intersected with each other
                 * @param {java.awt.geom.Rectangle2D} src2
                 * the second of a pair of <code>Rectangle2D</code> objects to be
                 * intersected with each other
                 * @param {java.awt.geom.Rectangle2D} dest
                 * the <code>Rectangle2D</code> that holds the results of the
                 * intersection of <code>src1</code> and <code>src2</code>
                 * @since 1.2
                 */
                Rectangle2D.intersect = function (src1, src2, dest) {
                    var x1 = Math.max(src1.getMinX(), src2.getMinX());
                    var y1 = Math.max(src1.getMinY(), src2.getMinY());
                    var x2 = Math.min(src1.getMaxX(), src2.getMaxX());
                    var y2 = Math.min(src1.getMaxY(), src2.getMaxY());
                    dest.setFrame$double$double$double$double(x1, y1, x2 - x1, y2 - y1);
                };
                /**
                 * Unions the pair of source <code>Rectangle2D</code> objects and puts the
                 * result into the specified destination <code>Rectangle2D</code> object.
                 * One of the source rectangles can also be the destination to avoid
                 * creating a third Rectangle2D object, but in this case the original points
                 * of this source rectangle will be overwritten by this method.
                 *
                 * @param {java.awt.geom.Rectangle2D} src1
                 * the first of a pair of <code>Rectangle2D</code> objects to be
                 * combined with each other
                 * @param {java.awt.geom.Rectangle2D} src2
                 * the second of a pair of <code>Rectangle2D</code> objects to be
                 * combined with each other
                 * @param {java.awt.geom.Rectangle2D} dest
                 * the <code>Rectangle2D</code> that holds the results of the
                 * union of <code>src1</code> and <code>src2</code>
                 * @since 1.2
                 */
                Rectangle2D.union = function (src1, src2, dest) {
                    var x1 = Math.min(src1.getMinX(), src2.getMinX());
                    var y1 = Math.min(src1.getMinY(), src2.getMinY());
                    var x2 = Math.max(src1.getMaxX(), src2.getMaxX());
                    var y2 = Math.max(src1.getMaxY(), src2.getMaxY());
                    dest.setFrameFromDiagonal$double$double$double$double(x1, y1, x2, y2);
                };
                Rectangle2D.prototype.add$double$double = function (newx, newy) {
                    var x1 = Math.min(this.getMinX(), newx);
                    var x2 = Math.max(this.getMaxX(), newx);
                    var y1 = Math.min(this.getMinY(), newy);
                    var y2 = Math.max(this.getMaxY(), newy);
                    this.setRect$double$double$double$double(x1, y1, x2 - x1, y2 - y1);
                };
                /**
                 * Adds a point, specified by the double precision arguments
                 * <code>newx</code> and <code>newy</code>, to this <code>Rectangle2D</code>
                 * . The resulting <code>Rectangle2D</code> is the smallest
                 * <code>Rectangle2D</code> that contains both the original
                 * <code>Rectangle2D</code> and the specified point.
                 * <p>
                 * After adding a point, a call to <code>contains</code> with the added
                 * point as an argument does not necessarily return <code>true</code>. The
                 * <code>contains</code> method does not return <code>true</code> for points
                 * on the right or bottom edges of a rectangle. Therefore, if the added
                 * point falls on the left or bottom edge of the enlarged rectangle,
                 * <code>contains</code> returns <code>false</code> for that point.
                 *
                 * @param {number} newx
                 * the X coordinate of the new point
                 * @param {number} newy
                 * the Y coordinate of the new point
                 * @since 1.2
                 */
                Rectangle2D.prototype.add = function (newx, newy) {
                    if (((typeof newx === 'number') || newx === null) && ((typeof newy === 'number') || newy === null)) {
                        return this.add$double$double(newx, newy);
                    }
                    else if (((newx != null && newx instanceof java.awt.geom.Point2D) || newx === null) && newy === undefined) {
                        return this.add$java_awt_geom_Point2D(newx);
                    }
                    else if (((newx != null && newx instanceof java.awt.geom.Rectangle2D) || newx === null) && newy === undefined) {
                        return this.add$java_awt_geom_Rectangle2D(newx);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Rectangle2D.prototype.add$java_awt_geom_Point2D = function (pt) {
                    this.add$double$double(pt.getX(), pt.getY());
                };
                Rectangle2D.prototype.add$java_awt_geom_Rectangle2D = function (r) {
                    var x1 = Math.min(this.getMinX(), r.getMinX());
                    var x2 = Math.max(this.getMaxX(), r.getMaxX());
                    var y1 = Math.min(this.getMinY(), r.getMinY());
                    var y2 = Math.max(this.getMaxY(), r.getMaxY());
                    this.setRect$double$double$double$double(x1, y1, x2 - x1, y2 - y1);
                };
                Rectangle2D.prototype.getPathIterator$java_awt_geom_AffineTransform = function (at) {
                    return new java.awt.geom.RectIterator(this, at);
                };
                Rectangle2D.prototype.getPathIterator$java_awt_geom_AffineTransform$double = function (at, flatness) {
                    return new java.awt.geom.RectIterator(this, at);
                };
                /**
                 * Returns an iteration object that defines the boundary of the flattened
                 * <code>Rectangle2D</code>. Since rectangles are already flat, the
                 * <code>flatness</code> parameter is ignored. The iterator for this class
                 * is multi-threaded safe, which means that this <code>Rectangle2D</code>
                 * class guarantees that modifications to the geometry of this
                 * <code>Rectangle2D</code> object do not affect any iterations of that
                 * geometry that are already in process.
                 *
                 * @param {java.awt.geom.AffineTransform} at
                 * an optional <code>AffineTransform</code> to be applied to the
                 * coordinates as they are returned in the iteration, or
                 * <code>null</code> if untransformed coordinates are desired
                 * @param {number} flatness
                 * the maximum distance that the line segments used to
                 * approximate the curved segments are allowed to deviate from
                 * any point on the original curve. Since rectangles are already
                 * flat, the <code>flatness</code> parameter is ignored.
                 * @return {*} the <code>PathIterator</code> object that returns the geometry of
                 * the outline of this <code>Rectangle2D</code>, one segment at a
                 * time.
                 * @since 1.2
                 */
                Rectangle2D.prototype.getPathIterator = function (at, flatness) {
                    if (((at != null && at instanceof java.awt.geom.AffineTransform) || at === null) && ((typeof flatness === 'number') || flatness === null)) {
                        return this.getPathIterator$java_awt_geom_AffineTransform$double(at, flatness);
                    }
                    else if (((at != null && at instanceof java.awt.geom.AffineTransform) || at === null) && flatness === undefined) {
                        return this.getPathIterator$java_awt_geom_AffineTransform(at);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Determines whether or not the specified <code>Object</code> is equal to
                 * this <code>Rectangle2D</code>. The specified <code>Object</code> is equal
                 * to this <code>Rectangle2D</code> if it is an instance of
                 * <code>Rectangle2D</code> and if its location and size are the same as
                 * this <code>Rectangle2D</code>.
                 *
                 * @param {*} obj
                 * an <code>Object</code> to be compared with this
                 * <code>Rectangle2D</code>.
                 * @return {boolean} <code>true</code> if <code>obj</code> is an instance of
                 * <code>Rectangle2D</code> and has the same values;
                 * <code>false</code> otherwise.
                 * @since 1.2
                 */
                Rectangle2D.prototype.equals = function (obj) {
                    if (obj === this) {
                        return true;
                    }
                    if (obj != null && obj instanceof java.awt.geom.Rectangle2D) {
                        var r2d = obj;
                        return ((this.getX() === r2d.getX()) && (this.getY() === r2d.getY()) && (this.getWidth() === r2d.getWidth()) && (this.getHeight() === r2d.getHeight()));
                    }
                    return false;
                };
                /**
                 * The bitmask that indicates that a point lies to the left of this
                 * <code>Rectangle2D</code>.
                 *
                 * @since 1.2
                 */
                Rectangle2D.OUT_LEFT = 1;
                /**
                 * The bitmask that indicates that a point lies above this
                 * <code>Rectangle2D</code>.
                 *
                 * @since 1.2
                 */
                Rectangle2D.OUT_TOP = 2;
                /**
                 * The bitmask that indicates that a point lies to the right of this
                 * <code>Rectangle2D</code>.
                 *
                 * @since 1.2
                 */
                Rectangle2D.OUT_RIGHT = 4;
                /**
                 * The bitmask that indicates that a point lies below this
                 * <code>Rectangle2D</code>.
                 *
                 * @since 1.2
                 */
                Rectangle2D.OUT_BOTTOM = 8;
                return Rectangle2D;
            }(java.awt.geom.RectangularShape));
            geom.Rectangle2D = Rectangle2D;
            Rectangle2D["__class"] = "java.awt.geom.Rectangle2D";
            Rectangle2D["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable"];
            (function (Rectangle2D) {
                /**
                 * Constructs and initializes a <code>Rectangle2D</code> from the
                 * specified <code>float</code> coordinates.
                 *
                 * @param {number} x
                 * the X coordinate of the upper-left corner of the newly
                 * constructed <code>Rectangle2D</code>
                 * @param {number} y
                 * the Y coordinate of the upper-left corner of the newly
                 * constructed <code>Rectangle2D</code>
                 * @param {number} w
                 * the width of the newly constructed
                 * <code>Rectangle2D</code>
                 * @param {number} h
                 * the height of the newly constructed
                 * <code>Rectangle2D</code>
                 * @since 1.2
                 * @class
                 * @extends java.awt.geom.Rectangle2D
                 */
                var Float = /** @class */ (function (_super) {
                    __extends(Float, _super);
                    function Float(x, y, w, h) {
                        var _this = this;
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                            var __args = arguments;
                            _this = _super.call(this) || this;
                            if (_this.x === undefined)
                                _this.x = 0;
                            if (_this.y === undefined)
                                _this.y = 0;
                            if (_this.width === undefined)
                                _this.width = 0;
                            if (_this.height === undefined)
                                _this.height = 0;
                            if (_this.x === undefined)
                                _this.x = 0;
                            if (_this.y === undefined)
                                _this.y = 0;
                            if (_this.width === undefined)
                                _this.width = 0;
                            if (_this.height === undefined)
                                _this.height = 0;
                            (function () {
                                _this.setRect$float$float$float$float(x, y, w, h);
                            })();
                        }
                        else if (x === undefined && y === undefined && w === undefined && h === undefined) {
                            var __args = arguments;
                            _this = _super.call(this) || this;
                            if (_this.x === undefined)
                                _this.x = 0;
                            if (_this.y === undefined)
                                _this.y = 0;
                            if (_this.width === undefined)
                                _this.width = 0;
                            if (_this.height === undefined)
                                _this.height = 0;
                            if (_this.x === undefined)
                                _this.x = 0;
                            if (_this.y === undefined)
                                _this.y = 0;
                            if (_this.width === undefined)
                                _this.width = 0;
                            if (_this.height === undefined)
                                _this.height = 0;
                        }
                        else
                            throw new Error('invalid overload');
                        return _this;
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Float.prototype.getX = function () {
                        return this.x;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Float.prototype.getY = function () {
                        return this.y;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Float.prototype.getWidth = function () {
                        return this.width;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Float.prototype.getHeight = function () {
                        return this.height;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {boolean}
                     */
                    Float.prototype.isEmpty = function () {
                        return (this.width <= 0.0) || (this.height <= 0.0);
                    };
                    Float.prototype.setRect$float$float$float$float = function (x, y, w, h) {
                        this.x = x;
                        this.y = y;
                        this.width = w;
                        this.height = h;
                    };
                    /**
                     * Sets the location and size of this <code>Rectangle2D</code> to the
                     * specified <code>float</code> values.
                     *
                     * @param {number} x
                     * the X coordinate of the upper-left corner of this
                     * <code>Rectangle2D</code>
                     * @param {number} y
                     * the Y coordinate of the upper-left corner of this
                     * <code>Rectangle2D</code>
                     * @param {number} w
                     * the width of this <code>Rectangle2D</code>
                     * @param {number} h
                     * the height of this <code>Rectangle2D</code>
                     * @since 1.2
                     */
                    Float.prototype.setRect = function (x, y, w, h) {
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                            return this.setRect$float$float$float$float(x, y, w, h);
                        }
                        else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                            return this.setRect$double$double$double$double(x, y, w, h);
                        }
                        else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                            return this.setRect$java_awt_geom_Rectangle2D(x);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    Float.prototype.setRect$double$double$double$double = function (x, y, w, h) {
                        this.x = x;
                        this.y = y;
                        this.width = w;
                        this.height = h;
                    };
                    Float.prototype.setRect$java_awt_geom_Rectangle2D = function (r) {
                        this.x = r.getX();
                        this.y = r.getY();
                        this.width = r.getWidth();
                        this.height = r.getHeight();
                    };
                    Float.prototype.outcode$double$double = function (x, y) {
                        var out = 0;
                        if (this.width <= 0) {
                            out |= java.awt.geom.Rectangle2D.OUT_LEFT | java.awt.geom.Rectangle2D.OUT_RIGHT;
                        }
                        else if (x < this.x) {
                            out |= java.awt.geom.Rectangle2D.OUT_LEFT;
                        }
                        else if (x > this.x + this.width) {
                            out |= java.awt.geom.Rectangle2D.OUT_RIGHT;
                        }
                        if (this.height <= 0) {
                            out |= java.awt.geom.Rectangle2D.OUT_TOP | java.awt.geom.Rectangle2D.OUT_BOTTOM;
                        }
                        else if (y < this.y) {
                            out |= java.awt.geom.Rectangle2D.OUT_TOP;
                        }
                        else if (y > this.y + this.height) {
                            out |= java.awt.geom.Rectangle2D.OUT_BOTTOM;
                        }
                        return out;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @param {number} x
                     * @param {number} y
                     * @return {number}
                     */
                    Float.prototype.outcode = function (x, y) {
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                            return this.outcode$double$double(x, y);
                        }
                        else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && y === undefined) {
                            return this.outcode$java_awt_geom_Point2D(x);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {java.awt.geom.Rectangle2D}
                     */
                    Float.prototype.getBounds2D = function () {
                        return new Rectangle2D.Float(this.x, this.y, this.width, this.height);
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @param {java.awt.geom.Rectangle2D} r
                     * @return {java.awt.geom.Rectangle2D}
                     */
                    Float.prototype.createIntersection = function (r) {
                        var dest;
                        if (r != null && r instanceof java.awt.geom.Rectangle2D.Float) {
                            dest = new java.awt.geom.Rectangle2D.Float();
                        }
                        else {
                            dest = new java.awt.geom.Rectangle2D.Double();
                        }
                        java.awt.geom.Rectangle2D.intersect(this, r, dest);
                        return dest;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @param {java.awt.geom.Rectangle2D} r
                     * @return {java.awt.geom.Rectangle2D}
                     */
                    Float.prototype.createUnion = function (r) {
                        var dest;
                        if (r != null && r instanceof java.awt.geom.Rectangle2D.Float) {
                            dest = new java.awt.geom.Rectangle2D.Float();
                        }
                        else {
                            dest = new java.awt.geom.Rectangle2D.Double();
                        }
                        java.awt.geom.Rectangle2D.union(this, r, dest);
                        return dest;
                    };
                    /**
                     * Returns the <code>String</code> representation of this
                     * <code>Rectangle2D</code>.
                     *
                     * @return {string} a <code>String</code> representing this
                     * <code>Rectangle2D</code>.
                     * @since 1.2
                     */
                    Float.prototype.toString = function () {
                        return /* getName */ (function (c) { return c["__class"] ? c["__class"] : c["name"]; })(Rectangle2D.Float) + "[x=" + this.x + ",y=" + this.y + ",w=" + this.width + ",h=" + this.height + "]";
                    };
                    Float.serialVersionUID = 3798716824173675777;
                    return Float;
                }(java.awt.geom.Rectangle2D));
                Rectangle2D.Float = Float;
                Float["__class"] = "java.awt.geom.Rectangle2D.Float";
                Float["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"];
                /**
                 * Constructs and initializes a <code>Rectangle2D</code> from the
                 * specified <code>double</code> coordinates.
                 *
                 * @param {number} x
                 * the X coordinate of the upper-left corner of the newly
                 * constructed <code>Rectangle2D</code>
                 * @param {number} y
                 * the Y coordinate of the upper-left corner of the newly
                 * constructed <code>Rectangle2D</code>
                 * @param {number} w
                 * the width of the newly constructed
                 * <code>Rectangle2D</code>
                 * @param {number} h
                 * the height of the newly constructed
                 * <code>Rectangle2D</code>
                 * @since 1.2
                 * @class
                 * @extends java.awt.geom.Rectangle2D
                 */
                var Double = /** @class */ (function (_super) {
                    __extends(Double, _super);
                    function Double(x, y, w, h) {
                        var _this = this;
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                            var __args = arguments;
                            _this = _super.call(this) || this;
                            if (_this.x === undefined)
                                _this.x = 0;
                            if (_this.y === undefined)
                                _this.y = 0;
                            if (_this.width === undefined)
                                _this.width = 0;
                            if (_this.height === undefined)
                                _this.height = 0;
                            if (_this.x === undefined)
                                _this.x = 0;
                            if (_this.y === undefined)
                                _this.y = 0;
                            if (_this.width === undefined)
                                _this.width = 0;
                            if (_this.height === undefined)
                                _this.height = 0;
                            (function () {
                                _this.setRect$double$double$double$double(x, y, w, h);
                            })();
                        }
                        else if (x === undefined && y === undefined && w === undefined && h === undefined) {
                            var __args = arguments;
                            _this = _super.call(this) || this;
                            if (_this.x === undefined)
                                _this.x = 0;
                            if (_this.y === undefined)
                                _this.y = 0;
                            if (_this.width === undefined)
                                _this.width = 0;
                            if (_this.height === undefined)
                                _this.height = 0;
                            if (_this.x === undefined)
                                _this.x = 0;
                            if (_this.y === undefined)
                                _this.y = 0;
                            if (_this.width === undefined)
                                _this.width = 0;
                            if (_this.height === undefined)
                                _this.height = 0;
                        }
                        else
                            throw new Error('invalid overload');
                        return _this;
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Double.prototype.getX = function () {
                        return this.x;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Double.prototype.getY = function () {
                        return this.y;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Double.prototype.getWidth = function () {
                        return this.width;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {number}
                     */
                    Double.prototype.getHeight = function () {
                        return this.height;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {boolean}
                     */
                    Double.prototype.isEmpty = function () {
                        return (this.width <= 0.0) || (this.height <= 0.0);
                    };
                    Double.prototype.setRect$double$double$double$double = function (x, y, w, h) {
                        this.x = x;
                        this.y = y;
                        this.width = w;
                        this.height = h;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @param {number} x
                     * @param {number} y
                     * @param {number} w
                     * @param {number} h
                     */
                    Double.prototype.setRect = function (x, y, w, h) {
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof w === 'number') || w === null) && ((typeof h === 'number') || h === null)) {
                            return this.setRect$double$double$double$double(x, y, w, h);
                        }
                        else if (((x != null && x instanceof java.awt.geom.Rectangle2D) || x === null) && y === undefined && w === undefined && h === undefined) {
                            return this.setRect$java_awt_geom_Rectangle2D(x);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    Double.prototype.setRect$java_awt_geom_Rectangle2D = function (r) {
                        this.x = r.getX();
                        this.y = r.getY();
                        this.width = r.getWidth();
                        this.height = r.getHeight();
                    };
                    Double.prototype.outcode$double$double = function (x, y) {
                        var out = 0;
                        if (this.width <= 0) {
                            out |= java.awt.geom.Rectangle2D.OUT_LEFT | java.awt.geom.Rectangle2D.OUT_RIGHT;
                        }
                        else if (x < this.x) {
                            out |= java.awt.geom.Rectangle2D.OUT_LEFT;
                        }
                        else if (x > this.x + this.width) {
                            out |= java.awt.geom.Rectangle2D.OUT_RIGHT;
                        }
                        if (this.height <= 0) {
                            out |= java.awt.geom.Rectangle2D.OUT_TOP | java.awt.geom.Rectangle2D.OUT_BOTTOM;
                        }
                        else if (y < this.y) {
                            out |= java.awt.geom.Rectangle2D.OUT_TOP;
                        }
                        else if (y > this.y + this.height) {
                            out |= java.awt.geom.Rectangle2D.OUT_BOTTOM;
                        }
                        return out;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @param {number} x
                     * @param {number} y
                     * @return {number}
                     */
                    Double.prototype.outcode = function (x, y) {
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                            return this.outcode$double$double(x, y);
                        }
                        else if (((x != null && x instanceof java.awt.geom.Point2D) || x === null) && y === undefined) {
                            return this.outcode$java_awt_geom_Point2D(x);
                        }
                        else
                            throw new Error('invalid overload');
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @return {java.awt.geom.Rectangle2D}
                     */
                    Double.prototype.getBounds2D = function () {
                        return new Rectangle2D.Double(this.x, this.y, this.width, this.height);
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @param {java.awt.geom.Rectangle2D} r
                     * @return {java.awt.geom.Rectangle2D}
                     */
                    Double.prototype.createIntersection = function (r) {
                        var dest = new java.awt.geom.Rectangle2D.Double();
                        java.awt.geom.Rectangle2D.intersect(this, r, dest);
                        return dest;
                    };
                    /**
                     * {@inheritDoc}
                     *
                     * @since 1.2
                     * @param {java.awt.geom.Rectangle2D} r
                     * @return {java.awt.geom.Rectangle2D}
                     */
                    Double.prototype.createUnion = function (r) {
                        var dest = new java.awt.geom.Rectangle2D.Double();
                        java.awt.geom.Rectangle2D.union(this, r, dest);
                        return dest;
                    };
                    /**
                     * Returns the <code>String</code> representation of this
                     * <code>Rectangle2D</code>.
                     *
                     * @return {string} a <code>String</code> representing this
                     * <code>Rectangle2D</code>.
                     * @since 1.2
                     */
                    Double.prototype.toString = function () {
                        return /* getName */ (function (c) { return c["__class"] ? c["__class"] : c["name"]; })(Rectangle2D.Double) + "[x=" + this.x + ",y=" + this.y + ",w=" + this.width + ",h=" + this.height + "]";
                    };
                    Double.serialVersionUID = 7771313791441850493;
                    return Double;
                }(java.awt.geom.Rectangle2D));
                Rectangle2D.Double = Double;
                Double["__class"] = "java.awt.geom.Rectangle2D.Double";
                Double["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"];
            })(Rectangle2D = geom.Rectangle2D || (geom.Rectangle2D = {}));
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            /**
             * Constructs a new <code>GeneralPath</code> object with the specified
             * winding rule and the specified initial capacity to store path
             * coordinates. This number is an initial guess as to how many path segments
             * will be added to the path, but the storage is expanded as needed to store
             * whatever path segments are added.
             *
             * @param {number} rule
             * the winding rule
             * @param {number} initialCapacity
             * the estimate for the number of path segments in the path
             * @see #WIND_EVEN_ODD
             * @see #WIND_NON_ZERO
             * @since 1.2
             * @class
             * @extends java.awt.geom.Path2D.Float
             * @author Jim Graham
             */
            var GeneralPath = /** @class */ (function (_super) {
                __extends(GeneralPath, _super);
                function GeneralPath(windingRule, pointTypes, numTypes, pointCoords, numCoords) {
                    var _this = this;
                    if (((typeof windingRule === 'number') || windingRule === null) && ((pointTypes != null && pointTypes instanceof Array && (pointTypes.length == 0 || pointTypes[0] == null || (typeof pointTypes[0] === 'number'))) || pointTypes === null) && ((typeof numTypes === 'number') || numTypes === null) && ((pointCoords != null && pointCoords instanceof Array && (pointCoords.length == 0 || pointCoords[0] == null || (typeof pointCoords[0] === 'number'))) || pointCoords === null) && ((typeof numCoords === 'number') || numCoords === null)) {
                        var __args = arguments;
                        _this = _super.call(this) || this;
                        (function () {
                            _this.windingRule = windingRule;
                            _this.pointTypes = pointTypes;
                            _this.numTypes = numTypes;
                            _this.floatCoords = pointCoords;
                            _this.numCoords = numCoords;
                        })();
                    }
                    else if (((typeof windingRule === 'number') || windingRule === null) && ((typeof pointTypes === 'number') || pointTypes === null) && numTypes === undefined && pointCoords === undefined && numCoords === undefined) {
                        var __args = arguments;
                        var rule = __args[0];
                        var initialCapacity = __args[1];
                        _this = _super.call(this, rule, initialCapacity) || this;
                    }
                    else if (((windingRule != null && (windingRule["__interfaces"] != null && windingRule["__interfaces"].indexOf("java.awt.Shape") >= 0 || windingRule.constructor != null && windingRule.constructor["__interfaces"] != null && windingRule.constructor["__interfaces"].indexOf("java.awt.Shape") >= 0)) || windingRule === null) && pointTypes === undefined && numTypes === undefined && pointCoords === undefined && numCoords === undefined) {
                        var __args = arguments;
                        var s = __args[0];
                        _this = _super.call(this, s, null) || this;
                    }
                    else if (((typeof windingRule === 'number') || windingRule === null) && pointTypes === undefined && numTypes === undefined && pointCoords === undefined && numCoords === undefined) {
                        var __args = arguments;
                        var rule = __args[0];
                        _this = _super.call(this, rule, java.awt.geom.Path2D.INIT_SIZE) || this;
                    }
                    else if (windingRule === undefined && pointTypes === undefined && numTypes === undefined && pointCoords === undefined && numCoords === undefined) {
                        var __args = arguments;
                        _this = _super.call(this, java.awt.geom.Path2D.WIND_NON_ZERO_$LI$(), java.awt.geom.Path2D.INIT_SIZE) || this;
                    }
                    else
                        throw new Error('invalid overload');
                    return _this;
                }
                GeneralPath.__java_awt_geom_GeneralPath_serialVersionUID = -8327096662768731142;
                return GeneralPath;
            }(java.awt.geom.Path2D.Float));
            geom.GeneralPath = GeneralPath;
            GeneralPath["__class"] = "java.awt.geom.GeneralPath";
            GeneralPath["__interfaces"] = ["java.awt.Shape", "java.lang.Cloneable", "java.io.Serializable"];
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java || (java = {}));
java.awt.geom.Path2D.Iterator.curvecoords_$LI$();
java.awt.geom.Path2D.SEG_CLOSE_$LI$();
java.awt.geom.Path2D.SEG_CUBICTO_$LI$();
java.awt.geom.Path2D.SEG_QUADTO_$LI$();
java.awt.geom.Path2D.SEG_LINETO_$LI$();
java.awt.geom.Path2D.SEG_MOVETO_$LI$();
java.awt.geom.Path2D.WIND_NON_ZERO_$LI$();
java.awt.geom.Path2D.WIND_EVEN_ODD_$LI$();
sun.awt.geom.AreaOp.EmptyChainList_$LI$();
sun.awt.geom.AreaOp.EmptyLinkList_$LI$();
sun.awt.geom.AreaOp.YXTopComparator_$LI$();
java.awt.geom.EllipseIterator.ctrlpts_$LI$();
java.awt.geom.EllipseIterator.ncv_$LI$();
java.awt.geom.EllipseIterator.pcv_$LI$();
java.awt.geom.Area.EmptyCurves_$LI$();
java.awt.geom.AffineTransform.rot90conversion_$LI$();
java.awt.geom.AffineTransform.HI_SHEAR_$LI$();
java.awt.geom.AffineTransform.HI_SCALE_$LI$();
java.awt.geom.AffineTransform.HI_TRANSLATE_$LI$();
java.awt.geom.AffineTransform.HI_IDENTITY_$LI$();
java.awt.geom.AffineTransform.TYPE_MASK_ROTATION_$LI$();
java.awt.geom.AffineTransform.TYPE_MASK_SCALE_$LI$();
java.awt.geom.RoundRectIterator.types_$LI$();
java.awt.geom.RoundRectIterator.ctrlpts_$LI$();
java.awt.geom.RoundRectIterator.acv_$LI$();
java.awt.geom.RoundRectIterator.cv_$LI$();
java.awt.geom.RoundRectIterator.c_$LI$();
java.awt.geom.RoundRectIterator.b_$LI$();
java.awt.geom.RoundRectIterator.a_$LI$();
java.awt.geom.RoundRectIterator.angle_$LI$();
